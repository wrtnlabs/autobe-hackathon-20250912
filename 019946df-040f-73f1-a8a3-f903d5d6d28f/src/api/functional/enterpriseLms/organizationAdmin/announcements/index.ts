import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEnterpriseLmsAnnouncement } from "../../../../structures/IEnterpriseLmsAnnouncement";
import { IPageIEnterpriseLmsAnnouncement } from "../../../../structures/IPageIEnterpriseLmsAnnouncement";

/**
 * Create a new announcement in the tenant context.
 *
 * Create a new announcement record for a tenant organization. The announcement
 * must specify title, body content, target audience, and status. The creator is
 * recorded as the current organization administrator.
 *
 * This operation validates input fields and enforces status constraints such as
 * draft or sent. Tenant association is ensured through security context.
 *
 * Used in administrative portals to create announcement broadcasts to users and
 * departments. Errors are returned if validation fails or tenant context is
 * missing.
 *
 * @param props.connection
 * @param props.body Announcement creation payload with title, body, creator,
 *   and status
 * @path /enterpriseLms/organizationAdmin/announcements
 * @accessor api.functional.enterpriseLms.organizationAdmin.announcements.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Announcement creation payload with title, body, creator, and status */
    body: IEnterpriseLmsAnnouncement.ICreate;
  };
  export type Body = IEnterpriseLmsAnnouncement.ICreate;
  export type Response = IEnterpriseLmsAnnouncement;

  export const METADATA = {
    method: "POST",
    path: "/enterpriseLms/organizationAdmin/announcements",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/enterpriseLms/organizationAdmin/announcements";
  export const random = (): IEnterpriseLmsAnnouncement =>
    typia.random<IEnterpriseLmsAnnouncement>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated list of announcements.
 *
 * Retrieve a filtered and paginated list of announcements within the enterprise
 * LMS. This operation allows clients to query announcements created by
 * organization administrators scoped to their tenant organization. It supports
 * advanced filtering by title, body content, status, and target audience
 * description for precise retrieval.
 *
 * The API responds with paginated announcement summaries including ID, title,
 * status, and creation timestamp. Role-based access control ensures only
 * organization administrators, department managers, or users with appropriate
 * permissions can view announcements.
 *
 * Security includes enforcement of tenant data isolation to prevent
 * cross-tenant data leakage. Search parameters support partial matching and
 * sorting by creation date or title.
 *
 * Use this operation from administrative dashboards or management UIs to
 * display announcements lists and enable management workflows such as review or
 * status updates.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for announcements
 *   filtering
 * @path /enterpriseLms/organizationAdmin/announcements
 * @accessor api.functional.enterpriseLms.organizationAdmin.announcements.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search criteria and pagination parameters for announcements filtering */
    body: IEnterpriseLmsAnnouncement.IRequest;
  };
  export type Body = IEnterpriseLmsAnnouncement.IRequest;
  export type Response = IPageIEnterpriseLmsAnnouncement;

  export const METADATA = {
    method: "PATCH",
    path: "/enterpriseLms/organizationAdmin/announcements",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/enterpriseLms/organizationAdmin/announcements";
  export const random = (): IPageIEnterpriseLmsAnnouncement =>
    typia.random<IPageIEnterpriseLmsAnnouncement>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed announcement information by ID.
 *
 * Retrieve detailed information of a specific announcement identified by its
 * ID. This operation returns full announcement content, creator details
 * (organization administrator), and lifecycle information including status and
 * timestamps.
 *
 * Access is restricted to users within the same tenant organization with
 * appropriate roles such as organization administrator or department manager.
 * Tenant isolation and authorization checks ensure data security.
 *
 * This endpoint is essential for announcement management features such as
 * editing, review, or detailed display in the UI. It handles errors gracefully
 * when announcements are not found or deleted.
 *
 * @param props.connection
 * @param props.announcementId Unique identifier of the announcement
 * @path /enterpriseLms/organizationAdmin/announcements/:announcementId
 * @accessor api.functional.enterpriseLms.organizationAdmin.announcements.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the announcement */
    announcementId: string & tags.Format<"uuid">;
  };
  export type Response = IEnterpriseLmsAnnouncement;

  export const METADATA = {
    method: "GET",
    path: "/enterpriseLms/organizationAdmin/announcements/:announcementId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/organizationAdmin/announcements/${encodeURIComponent(props.announcementId ?? "null")}`;
  export const random = (): IEnterpriseLmsAnnouncement =>
    typia.random<IEnterpriseLmsAnnouncement>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("announcementId")(() => typia.assert(props.announcementId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing announcement by ID.
 *
 * Update an existing announcement identified by ID. Allows modifying title,
 * body, audience description, and status fields. Tenant scope enforcement
 * limits update to authorized organization administrators.
 *
 * The API validates input and checks announcement existence and status before
 * updating.
 *
 * Used by administrative tools to manage announcement lifecycle such as sending
 * or archiving announcements.
 *
 * Returns the updated announcement information.
 *
 * @param props.connection
 * @param props.announcementId Unique identifier of the announcement to update
 * @param props.body Announcement update payload with optional modified fields
 * @path /enterpriseLms/organizationAdmin/announcements/:announcementId
 * @accessor api.functional.enterpriseLms.organizationAdmin.announcements.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the announcement to update */
    announcementId: string & tags.Format<"uuid">;

    /** Announcement update payload with optional modified fields */
    body: IEnterpriseLmsAnnouncement.IUpdate;
  };
  export type Body = IEnterpriseLmsAnnouncement.IUpdate;
  export type Response = IEnterpriseLmsAnnouncement;

  export const METADATA = {
    method: "PUT",
    path: "/enterpriseLms/organizationAdmin/announcements/:announcementId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/organizationAdmin/announcements/${encodeURIComponent(props.announcementId ?? "null")}`;
  export const random = (): IEnterpriseLmsAnnouncement =>
    typia.random<IEnterpriseLmsAnnouncement>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("announcementId")(() => typia.assert(props.announcementId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific announcement by its ID.
 *
 * Deletes an existing announcement identified by its announcementId from the
 * enterprise LMS system.
 *
 * This operation targets the enterprise_lms_announcements table ensuring that
 * the announcement is permanently removed from the database. Any associated
 * data such as delivery receipts or related metadata is also deleted. Soft
 * deletion fields exist but this endpoint performs a full removal.
 *
 * Appropriate authentication and authorization are required to perform this
 * operation, generally limited to organization administrators.
 *
 * If the announcementId does not exist, an error is returned. This operation
 * has no response body for efficiency.
 *
 * @param props.connection
 * @param props.announcementId Unique identifier of the announcement to delete
 * @path /enterpriseLms/organizationAdmin/announcements/:announcementId
 * @accessor api.functional.enterpriseLms.organizationAdmin.announcements.eraseAnnouncement
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseAnnouncement(
  connection: IConnection,
  props: eraseAnnouncement.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseAnnouncement.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseAnnouncement.METADATA,
          path: eraseAnnouncement.path(props),
          status: null,
        },
      );
}
export namespace eraseAnnouncement {
  export type Props = {
    /** Unique identifier of the announcement to delete */
    announcementId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/enterpriseLms/organizationAdmin/announcements/:announcementId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/organizationAdmin/announcements/${encodeURIComponent(props.announcementId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseAnnouncement.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseAnnouncement.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("announcementId")(() => typia.assert(props.announcementId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
