import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEnterpriseLmsCertificationExpiration } from "../../../../../structures/IEnterpriseLmsCertificationExpiration";
import { IPageIEnterpriseLmsCertificationExpiration } from "../../../../../structures/IPageIEnterpriseLmsCertificationExpiration";

/**
 * Create a certification expiration policy for a certification.
 *
 * Create a new certification expiration policy for a given certification
 * identified by its ID. The operation is tenant-aware via the certification
 * context and allows specifying the duration in days after which the
 * certification expires, whether renewal is required, and the notification
 * period before expiration.
 *
 * Security considerations include authorization limited to users with roles
 * able to manage certifications and certification expiration settings. Input
 * validation enforces positive expiration period and non-negative notification
 * periods.
 *
 * This operation integrates with the enterprise_lms_certification_expirations
 * table defined in the Prisma schema, utilizing all relevant fields to
 * represent expiration policies. The created record is stored permanently and
 * influences downstream certification workflows and compliance actions.
 *
 * Related operations include retrieval, update, and deletion of certification
 * expiration policies. Proper error handling returns informative messages for
 * invalid input or unauthorized access.
 *
 * This operation is a POST method creating resources consistent with REST
 * principles.
 *
 * @param props.connection
 * @param props.certificationId Unique identifier of the certification
 * @param props.body Creation info of the certification expiration policy
 * @path /enterpriseLms/organizationAdmin/certifications/:certificationId/certificationExpirations
 * @accessor api.functional.enterpriseLms.organizationAdmin.certifications.certificationExpirations.createCertificationExpirationPolicy
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createCertificationExpirationPolicy(
  connection: IConnection,
  props: createCertificationExpirationPolicy.Props,
): Promise<createCertificationExpirationPolicy.Response> {
  return true === connection.simulate
    ? createCertificationExpirationPolicy.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createCertificationExpirationPolicy.METADATA,
          path: createCertificationExpirationPolicy.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createCertificationExpirationPolicy {
  export type Props = {
    /** Unique identifier of the certification */
    certificationId: string & tags.Format<"uuid">;

    /** Creation info of the certification expiration policy */
    body: IEnterpriseLmsCertificationExpiration.ICreate;
  };
  export type Body = IEnterpriseLmsCertificationExpiration.ICreate;
  export type Response = IEnterpriseLmsCertificationExpiration;

  export const METADATA = {
    method: "POST",
    path: "/enterpriseLms/organizationAdmin/certifications/:certificationId/certificationExpirations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/organizationAdmin/certifications/${encodeURIComponent(props.certificationId ?? "null")}/certificationExpirations`;
  export const random = (): IEnterpriseLmsCertificationExpiration =>
    typia.random<IEnterpriseLmsCertificationExpiration>();
  export const simulate = (
    connection: IConnection,
    props: createCertificationExpirationPolicy.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createCertificationExpirationPolicy.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("certificationId")(() =>
        typia.assert(props.certificationId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List certification expiration policies by certification ID.
 *
 * Get paginated list of expiration policies for a certification.
 *
 * Returns certification expiration rules including period of validity, renewal
 * requirements, and notification settings.
 *
 * Supports pagination and filtering in the request body.
 *
 * Accessible by organization administrators.
 *
 * Filters by the specified certification ID in the path parameter.
 *
 * Returns summarized expiration policy data for UI listing.
 *
 * Handles errors for invalid certification ID or access restrictions.
 *
 * @param props.connection
 * @param props.certificationId Unique identifier of the certification to list
 *   expiration policies for
 * @param props.body Paging, filter, and sort parameters for expiration policies
 * @path /enterpriseLms/organizationAdmin/certifications/:certificationId/certificationExpirations
 * @accessor api.functional.enterpriseLms.organizationAdmin.certifications.certificationExpirations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the certification to list expiration policies
     * for
     */
    certificationId: string & tags.Format<"uuid">;

    /** Paging, filter, and sort parameters for expiration policies */
    body: IEnterpriseLmsCertificationExpiration.IRequest;
  };
  export type Body = IEnterpriseLmsCertificationExpiration.IRequest;
  export type Response = IPageIEnterpriseLmsCertificationExpiration.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/enterpriseLms/organizationAdmin/certifications/:certificationId/certificationExpirations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/organizationAdmin/certifications/${encodeURIComponent(props.certificationId ?? "null")}/certificationExpirations`;
  export const random =
    (): IPageIEnterpriseLmsCertificationExpiration.ISummary =>
      typia.random<IPageIEnterpriseLmsCertificationExpiration.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("certificationId")(() =>
        typia.assert(props.certificationId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get certification expiration details by expiration ID.
 *
 * Retrieve detailed information about a specific certification expiration
 * policy.
 *
 * Requires certification ID and expiration policy ID as path parameters.
 *
 * Accessible to authorized organization administrators only.
 *
 * Returns full details including expiration periods, renewal flags, and
 * notification settings.
 *
 * Handles errors such as invalid IDs and access violations.
 *
 * @param props.connection
 * @param props.certificationId Unique identifier of the parent certification
 * @param props.expirationId Unique identifier of the expiration policy
 * @path /enterpriseLms/organizationAdmin/certifications/:certificationId/certificationExpirations/:expirationId
 * @accessor api.functional.enterpriseLms.organizationAdmin.certifications.certificationExpirations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the parent certification */
    certificationId: string & tags.Format<"uuid">;

    /** Unique identifier of the expiration policy */
    expirationId: string & tags.Format<"uuid">;
  };
  export type Response = IEnterpriseLmsCertificationExpiration;

  export const METADATA = {
    method: "GET",
    path: "/enterpriseLms/organizationAdmin/certifications/:certificationId/certificationExpirations/:expirationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/organizationAdmin/certifications/${encodeURIComponent(props.certificationId ?? "null")}/certificationExpirations/${encodeURIComponent(props.expirationId ?? "null")}`;
  export const random = (): IEnterpriseLmsCertificationExpiration =>
    typia.random<IEnterpriseLmsCertificationExpiration>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("certificationId")(() =>
        typia.assert(props.certificationId),
      );
      assert.param("expirationId")(() => typia.assert(props.expirationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a certification expiration policy for a certification.
 *
 * Update the certification expiration policy identified by expirationId,
 * associated with the provided certificationId. Users with organizationAdmin
 * role can modify the expiration period in days, renewal requirements, and
 * notification period. Validation ensures values are within business
 * constraints.
 *
 * This operation updates the enterprise_lms_certification_expirations table
 * records corresponding to the specified expiration policy. Changes are
 * persisted permanently and affect certification lifecycle management.
 *
 * Appropriate feedback is provided for invalid inputs or unauthorized access.
 *
 * @param props.connection
 * @param props.certificationId Unique identifier of the certification
 * @param props.expirationId Unique identifier of the certification expiration
 *   policy
 * @param props.body Information to update the certification expiration policy
 * @path /enterpriseLms/organizationAdmin/certifications/:certificationId/certificationExpirations/:expirationId
 * @accessor api.functional.enterpriseLms.organizationAdmin.certifications.certificationExpirations.updateCertificationExpirationPolicy
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateCertificationExpirationPolicy(
  connection: IConnection,
  props: updateCertificationExpirationPolicy.Props,
): Promise<updateCertificationExpirationPolicy.Response> {
  return true === connection.simulate
    ? updateCertificationExpirationPolicy.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateCertificationExpirationPolicy.METADATA,
          path: updateCertificationExpirationPolicy.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateCertificationExpirationPolicy {
  export type Props = {
    /** Unique identifier of the certification */
    certificationId: string & tags.Format<"uuid">;

    /** Unique identifier of the certification expiration policy */
    expirationId: string & tags.Format<"uuid">;

    /** Information to update the certification expiration policy */
    body: IEnterpriseLmsCertificationExpiration.IUpdate;
  };
  export type Body = IEnterpriseLmsCertificationExpiration.IUpdate;
  export type Response = IEnterpriseLmsCertificationExpiration;

  export const METADATA = {
    method: "PUT",
    path: "/enterpriseLms/organizationAdmin/certifications/:certificationId/certificationExpirations/:expirationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/organizationAdmin/certifications/${encodeURIComponent(props.certificationId ?? "null")}/certificationExpirations/${encodeURIComponent(props.expirationId ?? "null")}`;
  export const random = (): IEnterpriseLmsCertificationExpiration =>
    typia.random<IEnterpriseLmsCertificationExpiration>();
  export const simulate = (
    connection: IConnection,
    props: updateCertificationExpirationPolicy.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateCertificationExpirationPolicy.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("certificationId")(() =>
        typia.assert(props.certificationId),
      );
      assert.param("expirationId")(() => typia.assert(props.expirationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a certification expiration policy for a certification.
 *
 * Delete the certification expiration policy identified by expirationId
 * belonging to the certification specified by certificationId. This action
 * permanently removes the record from storage with no recovery option.
 *
 * Role-based security restricts access to organizationAdmin users. Validation
 * ensures the existence of the policy before deletion.
 *
 * Deletion affects certification expiration management and may require client
 * updates to certification workflows.
 *
 * This operation is designed as a hard delete action consistent with the Prisma
 * schema structure.
 *
 * @param props.connection
 * @param props.certificationId Unique identifier of the certification
 * @param props.expirationId Unique identifier of the certification expiration
 *   policy
 * @path /enterpriseLms/organizationAdmin/certifications/:certificationId/certificationExpirations/:expirationId
 * @accessor api.functional.enterpriseLms.organizationAdmin.certifications.certificationExpirations.eraseCertificationExpirationPolicy
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseCertificationExpirationPolicy(
  connection: IConnection,
  props: eraseCertificationExpirationPolicy.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseCertificationExpirationPolicy.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseCertificationExpirationPolicy.METADATA,
          path: eraseCertificationExpirationPolicy.path(props),
          status: null,
        },
      );
}
export namespace eraseCertificationExpirationPolicy {
  export type Props = {
    /** Unique identifier of the certification */
    certificationId: string & tags.Format<"uuid">;

    /** Unique identifier of the certification expiration policy */
    expirationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/enterpriseLms/organizationAdmin/certifications/:certificationId/certificationExpirations/:expirationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/organizationAdmin/certifications/${encodeURIComponent(props.certificationId ?? "null")}/certificationExpirations/${encodeURIComponent(props.expirationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseCertificationExpirationPolicy.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseCertificationExpirationPolicy.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("certificationId")(() =>
        typia.assert(props.certificationId),
      );
      assert.param("expirationId")(() => typia.assert(props.expirationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
