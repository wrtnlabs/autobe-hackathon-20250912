import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEnterpriseLmsForumThread } from "../../../../../structures/IEnterpriseLmsForumThread";
import { IEnterpriseLmsForumThreads } from "../../../../../structures/IEnterpriseLmsForumThreads";
import { IPageIEnterpriseLmsForumThreads } from "../../../../../structures/IPageIEnterpriseLmsForumThreads";
export * as forumPosts from "./forumPosts/index";

/**
 * Create a new forum thread in a forum.
 *
 * Create a new forum thread inside the forum identified by 'forumId'. The body
 * of the request carries the thread details complying with
 * 'IEnterpriseLmsForumThread.ICreate' schema.
 *
 * Authorization is granted to roles: systemAdmin, organizationAdmin,
 * departmentManager, contentCreatorInstructor, corporateLearner,
 * externalLearner, and guest.
 *
 * This API allows enterprise tenants to add new discussion threads, enhancing
 * intra-organization communications.
 *
 * @param props.connection
 * @param props.forumId Unique identifier of the target forum, UUID format
 * @param props.body Forum thread creation payload
 * @path /enterpriseLms/organizationAdmin/forums/:forumId/forumThreads
 * @accessor api.functional.enterpriseLms.organizationAdmin.forums.forumThreads.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target forum, UUID format */
    forumId: string & tags.Format<"uuid">;

    /** Forum thread creation payload */
    body: IEnterpriseLmsForumThread.ICreate;
  };
  export type Body = IEnterpriseLmsForumThread.ICreate;
  export type Response = IEnterpriseLmsForumThread;

  export const METADATA = {
    method: "POST",
    path: "/enterpriseLms/organizationAdmin/forums/:forumId/forumThreads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/organizationAdmin/forums/${encodeURIComponent(props.forumId ?? "null")}/forumThreads`;
  export const random = (): IEnterpriseLmsForumThread =>
    typia.random<IEnterpriseLmsForumThread>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forumId")(() => typia.assert(props.forumId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated list of forum threads by forumId.
 *
 * Retrieve a paginated list of forum threads within the specified forum
 * identified by forumId. Supports search and sorting options by thread title,
 * creation date, or update date. The operation ensures only threads belonging
 * to the tenant's forum are returned and that tenant data isolation is
 * enforced.
 *
 * Authorization is typically granted to authenticated users with access rights
 * to the forum's tenant data, including organization administrators and content
 * creators. This operation helps display threads for browsing and participation
 * in discussions.
 *
 * Results are paginated and can include summary thread information such as
 * title, author, and timestamps to optimize UI rendering and user navigation.
 *
 * @param props.connection
 * @param props.forumId Unique identifier of the target forum
 * @param props.body Search and pagination parameters for forum threads
 *   filtering
 * @path /enterpriseLms/organizationAdmin/forums/:forumId/forumThreads
 * @accessor api.functional.enterpriseLms.organizationAdmin.forums.forumThreads.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the target forum */
    forumId: string & tags.Format<"uuid">;

    /** Search and pagination parameters for forum threads filtering */
    body: IEnterpriseLmsForumThreads.IRequest;
  };
  export type Body = IEnterpriseLmsForumThreads.IRequest;
  export type Response = IPageIEnterpriseLmsForumThreads.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/enterpriseLms/organizationAdmin/forums/:forumId/forumThreads",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/organizationAdmin/forums/${encodeURIComponent(props.forumId ?? "null")}/forumThreads`;
  export const random = (): IPageIEnterpriseLmsForumThreads.ISummary =>
    typia.random<IPageIEnterpriseLmsForumThreads.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forumId")(() => typia.assert(props.forumId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information of a forum thread by ID.
 *
 * Retrieve a forum thread by its unique ID within a specified forum. This
 * operation fetches the forum thread's title, body, author information,
 * timestamps, and soft deletion status from the 'enterprise_lms_forum_threads'
 * table.
 *
 * Access is restricted to authenticated users of roles: systemAdmin,
 * organizationAdmin, departmentManager, contentCreatorInstructor,
 * corporateLearner, externalLearner, and guest, enforcing multi-tenant data
 * isolation and permissions.
 *
 * This API endpoint is essential for displaying detailed discussion within
 * enterprise learning forums.
 *
 * @param props.connection
 * @param props.forumId Unique identifier of the target forum, UUID format
 * @param props.forumThreadId Unique identifier of the target forum thread, UUID
 *   format
 * @path /enterpriseLms/organizationAdmin/forums/:forumId/forumThreads/:forumThreadId
 * @accessor api.functional.enterpriseLms.organizationAdmin.forums.forumThreads.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target forum, UUID format */
    forumId: string & tags.Format<"uuid">;

    /** Unique identifier of the target forum thread, UUID format */
    forumThreadId: string & tags.Format<"uuid">;
  };
  export type Response = IEnterpriseLmsForumThread;

  export const METADATA = {
    method: "GET",
    path: "/enterpriseLms/organizationAdmin/forums/:forumId/forumThreads/:forumThreadId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/organizationAdmin/forums/${encodeURIComponent(props.forumId ?? "null")}/forumThreads/${encodeURIComponent(props.forumThreadId ?? "null")}`;
  export const random = (): IEnterpriseLmsForumThread =>
    typia.random<IEnterpriseLmsForumThread>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forumId")(() => typia.assert(props.forumId));
      assert.param("forumThreadId")(() => typia.assert(props.forumThreadId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a forum thread by ID within a forum.
 *
 * Update details of a forum thread specified by 'forumThreadId' within the
 * forum 'forumId'. Request body must comply with
 * 'IEnterpriseLmsForumThread.IUpdate' schema.
 *
 * Access control allows roles: systemAdmin, organizationAdmin,
 * departmentManager, contentCreatorInstructor, corporateLearner,
 * externalLearner, and guest.
 *
 * This endpoint supports editing of thread title, body, and maintaining audit
 * safety within multitenant boundaries.
 *
 * @param props.connection
 * @param props.forumId Unique identifier of the target forum, UUID format
 * @param props.forumThreadId Unique identifier of the target forum thread, UUID
 *   format
 * @param props.body Forum thread update payload
 * @path /enterpriseLms/organizationAdmin/forums/:forumId/forumThreads/:forumThreadId
 * @accessor api.functional.enterpriseLms.organizationAdmin.forums.forumThreads.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target forum, UUID format */
    forumId: string & tags.Format<"uuid">;

    /** Unique identifier of the target forum thread, UUID format */
    forumThreadId: string & tags.Format<"uuid">;

    /** Forum thread update payload */
    body: IEnterpriseLmsForumThread.IUpdate;
  };
  export type Body = IEnterpriseLmsForumThread.IUpdate;
  export type Response = IEnterpriseLmsForumThread;

  export const METADATA = {
    method: "PUT",
    path: "/enterpriseLms/organizationAdmin/forums/:forumId/forumThreads/:forumThreadId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/organizationAdmin/forums/${encodeURIComponent(props.forumId ?? "null")}/forumThreads/${encodeURIComponent(props.forumThreadId ?? "null")}`;
  export const random = (): IEnterpriseLmsForumThread =>
    typia.random<IEnterpriseLmsForumThread>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forumId")(() => typia.assert(props.forumId));
      assert.param("forumThreadId")(() => typia.assert(props.forumThreadId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a forum thread by ID within a forum.
 *
 * Soft delete a forum thread identified by 'forumThreadId' inside forum
 * 'forumId'. This operation marks the thread as deleted by setting 'deleted_at'
 * timestamp.
 *
 * Authorization granted to roles: systemAdmin, organizationAdmin,
 * departmentManager, contentCreatorInstructor, corporateLearner,
 * externalLearner, and guest.
 *
 * Soft deletion preserves data for audit and compliance within multi-tenant
 * architecture.
 *
 * No content response returned upon successful deletion.
 *
 * @param props.connection
 * @param props.forumId Unique identifier of the target forum, UUID format
 * @param props.forumThreadId Unique identifier of the target forum thread, UUID
 *   format
 * @path /enterpriseLms/organizationAdmin/forums/:forumId/forumThreads/:forumThreadId
 * @accessor api.functional.enterpriseLms.organizationAdmin.forums.forumThreads.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target forum, UUID format */
    forumId: string & tags.Format<"uuid">;

    /** Unique identifier of the target forum thread, UUID format */
    forumThreadId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/enterpriseLms/organizationAdmin/forums/:forumId/forumThreads/:forumThreadId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/organizationAdmin/forums/${encodeURIComponent(props.forumId ?? "null")}/forumThreads/${encodeURIComponent(props.forumThreadId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forumId")(() => typia.assert(props.forumId));
      assert.param("forumThreadId")(() => typia.assert(props.forumThreadId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
