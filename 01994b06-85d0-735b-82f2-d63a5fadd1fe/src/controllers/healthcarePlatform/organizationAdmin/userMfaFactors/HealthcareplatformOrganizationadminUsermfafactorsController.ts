import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { posthealthcarePlatformOrganizationAdminUserMfaFactors } from "../../../../providers/posthealthcarePlatformOrganizationAdminUserMfaFactors";
import { OrganizationadminAuth } from "../../../../decorators/OrganizationadminAuth";
import { OrganizationadminPayload } from "../../../../decorators/payload/OrganizationadminPayload";
import { patchhealthcarePlatformOrganizationAdminUserMfaFactors } from "../../../../providers/patchhealthcarePlatformOrganizationAdminUserMfaFactors";
import { gethealthcarePlatformOrganizationAdminUserMfaFactorsUserMfaFactorId } from "../../../../providers/gethealthcarePlatformOrganizationAdminUserMfaFactorsUserMfaFactorId";
import { puthealthcarePlatformOrganizationAdminUserMfaFactorsUserMfaFactorId } from "../../../../providers/puthealthcarePlatformOrganizationAdminUserMfaFactorsUserMfaFactorId";
import { deletehealthcarePlatformOrganizationAdminUserMfaFactorsUserMfaFactorId } from "../../../../providers/deletehealthcarePlatformOrganizationAdminUserMfaFactorsUserMfaFactorId";

import { IHealthcarePlatformUserMfaFactor } from "../../../../api/structures/IHealthcarePlatformUserMfaFactor";
import { IPageIHealthcarePlatformUserMfaFactor } from "../../../../api/structures/IPageIHealthcarePlatformUserMfaFactor";

@Controller("/healthcarePlatform/organizationAdmin/userMfaFactors")
export class HealthcareplatformOrganizationadminUsermfafactorsController {
  /**
   * Create a new user MFA factor for a user (TOTP, SMS, email, etc).
   *
   * Create a new user MFA factor record by providing the user, type, factor
   * value, priority, and status. The operation validates business
   * logic—ensuring only one primary factor per type, appropriate credential
   * security, and correct scoping by user type. It enforces RBAC: only
   * admin-level roles can add MFA factors for users/scenarios such as user
   * onboarding, compliance rollout, or factor replacement after credential
   * expiry/misuse.
   *
   * Returns the created MFA factor's configuration and metadata, with the
   * credential field redacted. If duplicate or conflicting factors are
   * requested, a business error is returned with remediation direction.
   *
   * Audit logs record all MFA factor creation for compliance.
   *
   * @param connection
   * @param body MFA factor creation data—user, type, value, priority, and
   *   settings.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @OrganizationadminAuth()
    organizationAdmin: OrganizationadminPayload,
    @TypedBody()
    body: IHealthcarePlatformUserMfaFactor.ICreate,
  ): Promise<IHealthcarePlatformUserMfaFactor> {
    try {
      return await posthealthcarePlatformOrganizationAdminUserMfaFactors({
        organizationAdmin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and list user MFA factors for security and compliance review.
   *
   * Retrieve a list of user MFA factors, supporting complex search, filtering,
   * and pagination on the healthcare_platform_user_mfa_factors table. The
   * operation is available to system administrators and organization
   * administrators for conducting compliance reviews or managing user MFA
   * configurations.
   *
   * Returns paginated data, allowing filtering by factor type, user type,
   * priority, is_active status, and creation/update ranges. The response
   * enables downstream UI and reporting features for security audits. Sensitive
   * credential values are never returned.
   *
   * Security is strictly enforced: only users with admin privileges may list
   * MFA factors, and sensitive credential secrets are always redacted. Large
   * result sets are paginated for scalability and performance. Errors for
   * insufficient permissions or invalid filters return clear, actionable
   * details.
   *
   * @param connection
   * @param body Query/filter criteria and pagination options for searching user
   *   MFA factors.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @OrganizationadminAuth()
    organizationAdmin: OrganizationadminPayload,
    @TypedBody()
    body: IHealthcarePlatformUserMfaFactor.IRequest,
  ): Promise<IPageIHealthcarePlatformUserMfaFactor> {
    try {
      return await patchhealthcarePlatformOrganizationAdminUserMfaFactors({
        organizationAdmin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get full detail of a user MFA factor by ID.
   *
   * Retrieve full configuration and metadata for a specific MFA factor record,
   * addressed by userMfaFactorId (UUID primary key) in
   * healthcare_platform_user_mfa_factors. Intended for system or organization
   * admins reviewing MFA history or handling user access issues.
   *
   * Returns factor type, status, creation/update info, and associated user
   * context, never exposing the credential secret. If the record does not
   * exist, a standardized not-found error is returned.
   *
   * Strict RBAC is enforced. Only admins with permitted scope may access
   * details.
   *
   * @param connection
   * @param userMfaFactorId UUID of the user MFA factor record to retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":userMfaFactorId")
  public async at(
    @OrganizationadminAuth()
    organizationAdmin: OrganizationadminPayload,
    @TypedParam("userMfaFactorId")
    userMfaFactorId: string & tags.Format<"uuid">,
  ): Promise<IHealthcarePlatformUserMfaFactor> {
    try {
      return await gethealthcarePlatformOrganizationAdminUserMfaFactorsUserMfaFactorId(
        {
          organizationAdmin,
          userMfaFactorId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update user MFA factor configuration and settings.
   *
   * Modify an existing user MFA factor record, addressed by userMfaFactorId
   * (UUID primary key). Allows for changes to factor type, value, status,
   * priority, and other configuration due to user request, credential rotation,
   * or compliance enforcement. The operation strictly enforces security
   * rules—redacting secrets, preventing privilege escalation, and allowing only
   * permitted fields for update depending on admin role.
   *
   * On success, returns the updated MFA factor record with masked credential
   * info. Handles not-found errors, insufficient permissions, and business rule
   * violations with clear error responses. All update actions are appended to
   * audit logs for full traceability.
   *
   * @param connection
   * @param userMfaFactorId UUID of the MFA factor record to update.
   * @param body New configuration data for the user MFA factor (type, status,
   *   value, priority).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":userMfaFactorId")
  public async update(
    @OrganizationadminAuth()
    organizationAdmin: OrganizationadminPayload,
    @TypedParam("userMfaFactorId")
    userMfaFactorId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IHealthcarePlatformUserMfaFactor.IUpdate,
  ): Promise<IHealthcarePlatformUserMfaFactor> {
    try {
      return await puthealthcarePlatformOrganizationAdminUserMfaFactorsUserMfaFactorId(
        {
          organizationAdmin,
          userMfaFactorId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Permanently delete a user MFA factor by ID from the
   * healthcare_platform_user_mfa_factors table.
   *
   * This API operation is designed to facilitate the permanent deletion of a
   * specific MFA (multi-factor authentication) factor from a user's security
   * profile in the healthcarePlatform system. MFA factors increase login
   * security, and users may have more than one factor registered (such as TOTP
   * apps, SMS numbers, or email codes). When users lose access to one of these
   * factors, switch devices, or an administrator detects a potential security
   * issue, it may be necessary to remove the MFA factor record from the
   * database.
   *
   * Deleting an MFA factor is a sensitive operation requiring audit and
   * authentication. All delete actions should be accompanied by a reason in the
   * audit log and must comply with organizational retention and recovery
   * policies. This deletion is hard (the factor record and its credentials are
   * not recoverable) unless regulatory requirements dictate otherwise.
   * Attempting to delete a non-existent or already-deleted factor should result
   * in an error explaining the missing resource.
   *
   * This endpoint uses the unique UUID identifier userMfaFactorId and will
   * enforce permissions based on the role of the actor and the relationship to
   * the user.
   *
   * Other critical considerations include checking that the factor is not the
   * last active factor for the user when organization policy requires
   * multifactor authentication, and ensuring the operation is performed by an
   * authorized administrator or support user. All actions must be fully
   * auditable as per requirements and schema.
   *
   * @param connection
   * @param userMfaFactorId Unique identifier for the MFA factor to delete.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":userMfaFactorId")
  public async erase(
    @OrganizationadminAuth()
    organizationAdmin: OrganizationadminPayload,
    @TypedParam("userMfaFactorId")
    userMfaFactorId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletehealthcarePlatformOrganizationAdminUserMfaFactorsUserMfaFactorId(
        {
          organizationAdmin,
          userMfaFactorId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
