import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformDecisionSupportRule } from "../../../../structures/IHealthcarePlatformDecisionSupportRule";
import { IPageIHealthcarePlatformDecisionSupportRule } from "../../../../structures/IPageIHealthcarePlatformDecisionSupportRule";

/**
 * Create a new clinical decision support rule (CDS) in the platform.
 *
 * Create a new clinical decision support (CDS) rule by submitting all required
 * configuration and business fields to the
 * 'healthcare_platform_decision_support_rules' table. Request requires valid
 * authentication and privileged roles such as systemAdmin or organizationAdmin,
 * with scope to authorized organizations.
 *
 * Request body includes organization linkage, rule_code, title, trigger event,
 * rule logic (expression_json), optional description, and enablement status.
 * All submitted data must meet platform and compliance validation (unique code,
 * acceptable rule syntax, organization binding). The response returns the
 * created and persisted rule including all metadata and system-generated fields
 * (timestamps, ID).
 *
 * Security ensures only properly scoped admins or configuration managers can
 * introduce new rules. Errors are returned on validation failures (e.g.,
 * duplicate codes, missing logic, syntax errors). This operation supports
 * internal organizational program growth, patient safety, and compliance
 * documentation needs.
 *
 * @param props.connection
 * @param props.body Complete definition required to create a new CDS rule,
 *   including logic, triggers, and scope.
 * @path /healthcarePlatform/organizationAdmin/decisionSupportRules
 * @accessor api.functional.healthcarePlatform.organizationAdmin.decisionSupportRules.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Complete definition required to create a new CDS rule, including
     * logic, triggers, and scope.
     */
    body: IHealthcarePlatformDecisionSupportRule.ICreate;
  };
  export type Body = IHealthcarePlatformDecisionSupportRule.ICreate;
  export type Response = IHealthcarePlatformDecisionSupportRule;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/decisionSupportRules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/decisionSupportRules";
  export const random = (): IHealthcarePlatformDecisionSupportRule =>
    typia.random<IHealthcarePlatformDecisionSupportRule>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated, filterable list of clinical decision support
 * (CDS) rules in the healthcare platform.
 *
 * Retrieve a filtered and paginated list of clinical decision support rules
 * (CDS) from the 'healthcare_platform_decision_support_rules' table. This
 * endpoint allows privileged clinical administrators and analytics roles to
 * search, filter, and sort CDS rules relevant to their organization or
 * department context.
 *
 * Security requires valid authentication and role-based access. Only users with
 * appropriate administrative, analytics, or compliance permissions may access
 * the full rule catalog. Rule details are visible based on organizational
 * scoping and user assignment, preventing unauthorized cross-tenant access.
 *
 * The API incorporates multi-field searching (title, trigger event, CDS rule
 * status), ordering, and supports queries against is_enabled status as well as
 * temporal filters (created_at/updated_at). It directly supports audit reviews
 * and policy adjustments per clinical best practices, enabling organizations to
 * maintain regulatory fidelity and optimize patient safety programs.
 *
 * @param props.connection
 * @param props.body Filter, search, and pagination criteria for retrieving CDS
 *   rules.
 * @path /healthcarePlatform/organizationAdmin/decisionSupportRules
 * @accessor api.functional.healthcarePlatform.organizationAdmin.decisionSupportRules.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter, search, and pagination criteria for retrieving CDS rules. */
    body: IHealthcarePlatformDecisionSupportRule.IRequest;
  };
  export type Body = IHealthcarePlatformDecisionSupportRule.IRequest;
  export type Response = IPageIHealthcarePlatformDecisionSupportRule;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/decisionSupportRules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/decisionSupportRules";
  export const random = (): IPageIHealthcarePlatformDecisionSupportRule =>
    typia.random<IPageIHealthcarePlatformDecisionSupportRule>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch complete details for a specific CDS rule by rule ID in the platform.
 *
 * Retrieve all details for a specific clinical decision support rule from
 * 'healthcare_platform_decision_support_rules' by rule ID. This endpoint is
 * essential for administrative, analytics, or compliance roles to view rule
 * metadata, logic (expression_json), trigger event, lifecycle metadata, enabled
 * status, and audit history.
 *
 * Authorization checks ensure that only users with appropriate administrative
 * or analytic privileges and proper organization/department scoping can access
 * this rule detail. The rule ID must be a valid UUID; errors are returned for
 * invalid IDs or lack of permissions.
 *
 * Expected behaviors include full rule details in a compliance-ready structure,
 * error and not-found handling, and compatibility with audit and workflow
 * configuration tools. This is used in conjunction with the rule search/list
 * endpoint to permit full lifecycle management of CDS rule entities in the
 * production system.
 *
 * @param props.connection
 * @param props.ruleId Unique identifier (UUID) of the CDS rule to fetch.
 * @path /healthcarePlatform/organizationAdmin/decisionSupportRules/:ruleId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.decisionSupportRules.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the CDS rule to fetch. */
    ruleId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformDecisionSupportRule;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/decisionSupportRules/:ruleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/decisionSupportRules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): IHealthcarePlatformDecisionSupportRule =>
    typia.random<IHealthcarePlatformDecisionSupportRule>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("ruleId")(() => typia.assert(props.ruleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing clinical decision support rule (CDS) by rule ID.
 *
 * Update a clinical decision support rule in
 * 'healthcare_platform_decision_support_rules' by rule ID, modifying fields
 * such as title, trigger event, rule logic (expression_json), description,
 * activation status, or organizational linkage. Path parameter ruleId must be a
 * valid UUID and reference an existing rule; request body supplies new or
 * changed attributes.
 *
 * Operation is limited to users with administrative privileges and
 * organizational or system scope according to the RBAC matrix. Full validation
 * is enforced on all changes (e.g., business logic, code uniqueness if
 * modified, expression syntax/structure). The response returns the complete,
 * updated rule object including system metadata (updated_at).
 *
 * Behavior includes detailed error messages for not found, permission denied,
 * or validation failures. Audit logging is enforced for compliance and system
 * configuration lifecycle tracking. Typically used to maintain up-to-date
 * clinical policies and respond to advances in clinical practice or compliance
 * requirements.
 *
 * @param props.connection
 * @param props.ruleId Unique identifier (UUID) of the CDS rule to update.
 * @param props.body Fields required to update an existing CDS rule (any
 *   modifiable attribute).
 * @path /healthcarePlatform/organizationAdmin/decisionSupportRules/:ruleId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.decisionSupportRules.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the CDS rule to update. */
    ruleId: string & tags.Format<"uuid">;

    /**
     * Fields required to update an existing CDS rule (any modifiable
     * attribute).
     */
    body: IHealthcarePlatformDecisionSupportRule.IUpdate;
  };
  export type Body = IHealthcarePlatformDecisionSupportRule.IUpdate;
  export type Response = IHealthcarePlatformDecisionSupportRule;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/decisionSupportRules/:ruleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/decisionSupportRules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): IHealthcarePlatformDecisionSupportRule =>
    typia.random<IHealthcarePlatformDecisionSupportRule>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("ruleId")(() => typia.assert(props.ruleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a clinical decision support rule by ruleId from the
 * healthcare_platform_decision_support_rules table.
 *
 * Delete a specific clinical decision support (CDS) rule from the system by
 * ruleId. This operation functions as a hard delete, permanently removing the
 * CDS rule from the healthcare_platform_decision_support_rules table. The rule
 * may represent business logic that triggers patient safety alerts (e.g., drug
 * interactions, lab notifications), and its removal should be performed with
 * extreme caution and proper authorization.
 *
 * Access to this endpoint must be restricted to system administrators or
 * organization administrators to ensure regulatory compliance and prevent
 * unintended service disruptions. When a rule is deleted, all future CDS
 * processing related to this rule will cease, and dashboards or analytics
 * referencing it may be affected. Downstream data, such as previously generated
 * clinical alerts, remains available for compliance audits. Comprehensive audit
 * logs are recorded for every deletion, preserving action time, actor identity,
 * justification, and affected rule details.
 *
 * Validation includes confirming existence of the specified ruleId, ensuring
 * the user has legitimate access, and capturing attempts to delete non-existent
 * or already-deleted rules. Any errors (invalid ID, permissions, system
 * failures) are reported with appropriate messages and audit notes.
 *
 * @param props.connection
 * @param props.ruleId Unique identifier (UUID) of the decision support rule to
 *   delete.
 * @path /healthcarePlatform/organizationAdmin/decisionSupportRules/:ruleId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.decisionSupportRules.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the decision support rule to delete. */
    ruleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/organizationAdmin/decisionSupportRules/:ruleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/decisionSupportRules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("ruleId")(() => typia.assert(props.ruleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
