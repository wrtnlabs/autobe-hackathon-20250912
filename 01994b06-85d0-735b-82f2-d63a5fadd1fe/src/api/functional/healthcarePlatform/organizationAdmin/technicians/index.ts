import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformTechnician } from "../../../../structures/IHealthcarePlatformTechnician";
import { IPageIHealthcarePlatformTechnician } from "../../../../structures/IPageIHealthcarePlatformTechnician";

/**
 * Create a new technician record in healthcare_platform_technicians.
 *
 * Onboard a new technician by submitting the required data fields—business
 * email (must be unique), full legal name, professional license number (also
 * unique), and other optional details such as specialty and phone. Data is
 * validated against schema requirements and business rules (such as license
 * uniqueness and format) before insertion.
 *
 * New technician creation actions are restricted to HR personnel, department
 * heads, or organization administrators with appropriate permissions. All new
 * records are tracked in audit logs with the creating user, timestamp, and all
 * input data for future review and compliance checks.
 *
 * If creation fails due to duplication or validation issues, an appropriate
 * error with remediation details is returned. Related endpoints include
 * updating existing technicians, deactivating staff records, and searching the
 * technician directory for recently added users.
 *
 * @param props.connection
 * @param props.body Technician staff creation data.
 * @path /healthcarePlatform/organizationAdmin/technicians
 * @accessor api.functional.healthcarePlatform.organizationAdmin.technicians.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Technician staff creation data. */
    body: IHealthcarePlatformTechnician.ICreate;
  };
  export type Body = IHealthcarePlatformTechnician.ICreate;
  export type Response = IHealthcarePlatformTechnician;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/technicians",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/organizationAdmin/technicians";
  export const random = (): IHealthcarePlatformTechnician =>
    typia.random<IHealthcarePlatformTechnician>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search, filter, and paginate the list of technicians in
 * healthcare_platform_technicians.
 *
 * Use this endpoint to search for and list all technician records in the
 * system, applying advanced filtering by fields such as full name, license
 * number, specialty, creation date, current status, or other business
 * attributes present in the underlying schema. Sorting and pagination allow
 * organization administrators to efficiently manage large rosters of technical
 * clinical staff.
 *
 * Security is enforced via role-based access control, allowing only authorized
 * administrative users to access the full technician directory. Output does not
 * include any sensitive personal data unless explicitly permitted by
 * organizational or regulatory policy. Access logs should be maintained for all
 * invocation of this endpoint as it may contain personally identifiable and
 * credential information.
 *
 * Input is validated according to the request DTO, and all results returned are
 * derived exclusively from the healthcare_platform_technicians table, joined
 * with related roles or assignments if needed for presentation purposes. This
 * operation is typically used by organization administrators, department heads,
 * or HR/compliance staff.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination request for technician staff
 *   records.
 * @path /healthcarePlatform/organizationAdmin/technicians
 * @accessor api.functional.healthcarePlatform.organizationAdmin.technicians.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, and pagination request for technician staff records. */
    body: IHealthcarePlatformTechnician.IRequest;
  };
  export type Body = IHealthcarePlatformTechnician.IRequest;
  export type Response = IPageIHealthcarePlatformTechnician.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/technicians",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/organizationAdmin/technicians";
  export const random = (): IPageIHealthcarePlatformTechnician.ISummary =>
    typia.random<IPageIHealthcarePlatformTechnician.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a technician record in healthcare_platform_technicians by ID.
 *
 * Retrieve the full profile of a specific technician by UUID. This operation
 * queries the healthcare_platform_technicians entity, returning all defined
 * fields such as full name, license number, specialty, contact info, creation
 * and update chronology, and current status as specified in the schema.
 *
 * This endpoint is restricted to administrative or HR-level users as it can
 * expose sensitive or regulated credential and contact data. All access
 * attempts are logged for compliance and audit purposes.
 *
 * Related endpoints include listing technicians, creating or updating staff
 * records, and managing staff role assignments. Errors are returned if the
 * technicianId does not exist or if the user lacks the necessary privileges.
 *
 * @param props.connection
 * @param props.technicianId Unique identifier of the technician to retrieve
 *   (UUID format).
 * @path /healthcarePlatform/organizationAdmin/technicians/:technicianId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.technicians.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the technician to retrieve (UUID format). */
    technicianId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformTechnician;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/technicians/:technicianId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/technicians/${encodeURIComponent(props.technicianId ?? "null")}`;
  export const random = (): IHealthcarePlatformTechnician =>
    typia.random<IHealthcarePlatformTechnician>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("technicianId")(() => typia.assert(props.technicianId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a technician's profile in the healthcare_platform_technicians table.
 *
 * Update the information of an existing technician within the
 * healthcarePlatform. This operation is essential when any of the technician's
 * attributes—such as contact details, specialty, or credential data—need to be
 * revised for accuracy, regulatory compliance, or organizational changes.
 *
 * Security safeguards ensure that only users with adequate privileges (e.g.,
 * systemAdmin, organizationAdmin) can modify technician records. All updates
 * are logged for audit and compliance. Technicians' data supports workforce
 * management, scheduling, and technical workflow assignment throughout the
 * system.
 *
 * Modification of key properties like license_number or specialty may trigger
 * regulatory verification and must comply with unique and current standards as
 * described in the schema. Data updates here may affect downstream
 * scheduling/resource assignments and compliance audits. Error handling
 * includes validation of field formats and detection of conflicts (e.g.,
 * duplicate emails or license numbers).
 *
 * Related endpoints may provide technician listing and detail retrieval for
 * broader admin workflows. This operation is fundamental to ongoing staff
 * record maintenance and auditability.
 *
 * @param props.connection
 * @param props.technicianId Unique identifier of the technician to be updated.
 * @param props.body Fields and updated property values for the technician
 *   record.
 * @path /healthcarePlatform/organizationAdmin/technicians/:technicianId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.technicians.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the technician to be updated. */
    technicianId: string & tags.Format<"uuid">;

    /** Fields and updated property values for the technician record. */
    body: IHealthcarePlatformTechnician.IUpdate;
  };
  export type Body = IHealthcarePlatformTechnician.IUpdate;
  export type Response = IHealthcarePlatformTechnician;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/technicians/:technicianId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/technicians/${encodeURIComponent(props.technicianId ?? "null")}`;
  export const random = (): IHealthcarePlatformTechnician =>
    typia.random<IHealthcarePlatformTechnician>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("technicianId")(() => typia.assert(props.technicianId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a technician from the healthcare_platform_technicians
 * table.
 *
 * Erase a technician from the healthcarePlatform system by targeting the unique
 * technicianId. This operation either marks the record as deleted by setting
 * deleted_at (for audit trail and compliance preservation) or removes the
 * record if no soft-delete is implemented.
 *
 * Technician deletions are restricted to high-privilege users. All actions are
 * recorded in compliance logs for traceability. Deletion may impact scheduling,
 * workflow assignment, and overall organizational staffing configuration.
 * Proper error handling ensures attempts to erase non-existent or
 * already-deleted technicians are flagged for review.
 *
 * This action is generally irreversible and must abide by business policies
 * regarding historical data retention. Attempting to remove active or
 * referenced technicians may result in constraint errors or blocked requests.
 * Related endpoints include technician creation, information update, and detail
 * retrieval.
 *
 * @param props.connection
 * @param props.technicianId Unique identifier for the technician to be removed.
 * @path /healthcarePlatform/organizationAdmin/technicians/:technicianId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.technicians.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the technician to be removed. */
    technicianId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/organizationAdmin/technicians/:technicianId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/technicians/${encodeURIComponent(props.technicianId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("technicianId")(() => typia.assert(props.technicianId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
