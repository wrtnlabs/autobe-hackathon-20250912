import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformInsuranceClaim } from "../../../../structures/IHealthcarePlatformInsuranceClaim";
import { IPageIHealthcarePlatformInsuranceClaim } from "../../../../structures/IPageIHealthcarePlatformInsuranceClaim";
export * as insuranceClaimStatuses from "./insuranceClaimStatuses/index";

/**
 * Create a new insurance claim record for a specified policy/invoice in
 * healthcare_platform_insurance_claims.
 *
 * Initiate a new insurance claim record, linked to a specific insurance policy
 * and invoice, to support submission for insurance reimbursement or settlement.
 * Users provide all necessary identifying and claim value data, including
 * policy and invoice references, claimed totals, service/encounter dates, and
 * any supplementary payer information.
 *
 * The operation validates business rules, such as required policy and invoice
 * relationships, duplicate claim prevention, amount integrity, and regulatory
 * completeness (e.g., ICD-10, CPT linkages as required by jurisdiction). Once
 * created, the claim is tracked through its life cycle by status, with all
 * actions audited for compliance. This operation is limited to authorized
 * billing and financial staff with permission to initiate new claims. Error
 * scenarios encompass pre-existing open claims for the invoice, mismatched
 * policy/patient, missing required fields, or breach of regulatory/billing
 * rules.
 *
 * This creation endpoint should be paired with claim update/status, detail
 * retrieval, and bulk search endpoints for full workflow implementation.
 *
 * @param props.connection
 * @param props.body Creation details for the new insurance claim, including
 *   policy/invoice link, amounts, service date(s), and payer details.
 * @path /healthcarePlatform/organizationAdmin/insuranceClaims
 * @accessor api.functional.healthcarePlatform.organizationAdmin.insuranceClaims.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Creation details for the new insurance claim, including
     * policy/invoice link, amounts, service date(s), and payer details.
     */
    body: IHealthcarePlatformInsuranceClaim.ICreate;
  };
  export type Body = IHealthcarePlatformInsuranceClaim.ICreate;
  export type Response = IHealthcarePlatformInsuranceClaim;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/insuranceClaims",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/insuranceClaims";
  export const random = (): IHealthcarePlatformInsuranceClaim =>
    typia.random<IHealthcarePlatformInsuranceClaim>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated, filtered list of insurance claim records
 * from healthcare_platform_insurance_claims.
 *
 * Retrieve a filtered and paginated list of insurance claim records from the
 * system for authorized financial and billing users. This operation supports
 * advanced search by claim status, insurance policy, invoice number, service
 * date range, payer response status, and organization scope, allowing for
 * precise financial reconciliation and compliance review.
 *
 * Complex filtering and sorting enable users to segment results by claim life
 * cycle—such as active, pending, denied, paid, or appealed claims. Pagination
 * settings support large result sets, suitable for dashboard views and report
 * exports.
 *
 * Security controls ensure that users see only claims in their permitted
 * organizational or departmental scope, with PHI redacted as required. Error
 * handling includes search validation, empty result handling, and permission
 * enforcement. This search complements detail and summary retrieval endpoints,
 * as well as invoice and payment search APIs.
 *
 * @param props.connection
 * @param props.body Search criteria, filters, and pagination settings for
 *   querying insurance claims.
 * @path /healthcarePlatform/organizationAdmin/insuranceClaims
 * @accessor api.functional.healthcarePlatform.organizationAdmin.insuranceClaims.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filters, and pagination settings for querying
     * insurance claims.
     */
    body: IHealthcarePlatformInsuranceClaim.IRequest;
  };
  export type Body = IHealthcarePlatformInsuranceClaim.IRequest;
  export type Response = IPageIHealthcarePlatformInsuranceClaim.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/insuranceClaims",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/insuranceClaims";
  export const random = (): IPageIHealthcarePlatformInsuranceClaim.ISummary =>
    typia.random<IPageIHealthcarePlatformInsuranceClaim.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch full details of an insurance claim record by claim ID from
 * healthcare_platform_insurance_claims.
 *
 * Fetch full details on a specified insurance claim record, including claim
 * status, associated invoice, insurance policy, claimed amounts, payer
 * responses, and life cycle audit data. The returned information supports
 * billing and compliance workflows, such as claim adjudication, status reviews,
 * denial appeals, and regulatory audits.
 *
 * The API enforces role-based access control, restricting visibility to claims
 * within the user's authorized organizational or departmental scope. Data
 * fields may include claim number, policy and invoice references, service
 * dates, submission status, response codes, payment information, and audit
 * trail fields for compliance. This endpoint is intended for use by
 * organization administrative and billing staff requiring case-by-case
 * analysis. Handling includes not found, permission denied, and PHI masking
 * error scenarios. This endpoint should be used in conjunction with search and
 * summary endpoints for claim management workflows.
 *
 * @param props.connection
 * @param props.insuranceClaimId UUID identifying the insurance claim record to
 *   retrieve.
 * @path /healthcarePlatform/organizationAdmin/insuranceClaims/:insuranceClaimId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.insuranceClaims.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID identifying the insurance claim record to retrieve. */
    insuranceClaimId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformInsuranceClaim;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/insuranceClaims/:insuranceClaimId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/insuranceClaims/${encodeURIComponent(props.insuranceClaimId ?? "null")}`;
  export const random = (): IHealthcarePlatformInsuranceClaim =>
    typia.random<IHealthcarePlatformInsuranceClaim>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("insuranceClaimId")(() =>
        typia.assert(props.insuranceClaimId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing insurance claim record in the
 * healthcare_platform_insurance_claims table.
 *
 * The purpose of this operation is to allow authorized billing or admin roles
 * to update an existing insurance claim, as represented by the
 * healthcare_platform_insurance_claims Prisma table, which holds insurance
 * claim submission records. The request must include the claim identifier
 * (insuranceClaimId) and an object of mutable claim fields. Immutable
 * properties, like claim_number and linkages to invoice/policy, cannot be
 * changed by this operation. Strict validation applies, only permitting updates
 * that reflect permitted transitions (e.g., changing submission status,
 * updating payer responses, modifying claim payment amounts).
 *
 * All updates are logged with full audit trails, including the identity of the
 * user making the change, the previous state, and the updated state. Fields
 * required for regulatory compliance, like last_payer_response_code and
 * submission_status, must not be left blank. Logic must check for business
 * transitions, e.g., only permitted status changes (submitted →
 * accepted/denied/paid) are allowed, and payment updates should match invoice
 * reconciliations.
 *
 * Any modification may trigger additional side effects: recalculating billing
 * status, updating analytics, or triggering compliance workflows if claim
 * status changes to denied or paid. Attempts to update deleted or archived
 * claims must be rejected with an error. Related APIs include the PATCH
 * /insuranceClaims endpoint for claim search and the GET
 * /insuranceClaims/{insuranceClaimId} endpoint for claim detail retrieval.
 *
 * @param props.connection
 * @param props.insuranceClaimId Unique identifier of the insurance claim to
 *   update.
 * @param props.body Data fields to update within the insurance claim. Only
 *   non-immutable fields may be supplied. Follows
 *   IHealthcarePlatformInsuranceClaim.IUpdate structure.
 * @path /healthcarePlatform/organizationAdmin/insuranceClaims/:insuranceClaimId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.insuranceClaims.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the insurance claim to update. */
    insuranceClaimId: string & tags.Format<"uuid">;

    /**
     * Data fields to update within the insurance claim. Only non-immutable
     * fields may be supplied. Follows
     * IHealthcarePlatformInsuranceClaim.IUpdate structure.
     */
    body: IHealthcarePlatformInsuranceClaim.IUpdate;
  };
  export type Body = IHealthcarePlatformInsuranceClaim.IUpdate;
  export type Response = IHealthcarePlatformInsuranceClaim;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/insuranceClaims/:insuranceClaimId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/insuranceClaims/${encodeURIComponent(props.insuranceClaimId ?? "null")}`;
  export const random = (): IHealthcarePlatformInsuranceClaim =>
    typia.random<IHealthcarePlatformInsuranceClaim>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("insuranceClaimId")(() =>
        typia.assert(props.insuranceClaimId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (mark deleted) an insurance claim by insuranceClaimId, with full
 * audit compliance.
 *
 * Use this operation to delete (soft-delete) an insurance claim entity from the
 * healthcare_platform_insurance_claims table by providing the insuranceClaimId
 * path parameter. This sets the deleted_at timestamp in the record, ensuring
 * auditability and retention for compliance purposes.
 *
 * Deletion is only permitted if the claim is not in a paid or finalized status,
 * following business logic that prohibits deleting claims after settlement.
 * Attempts to delete such claims must result in a proper error with a
 * description of the business rule conflict. All deletes are logged for
 * regulatory and audit purposes. The operation may affect related billing or
 * financial audit workflows downstream, so it must only be allowed when it
 * won't jeopardize compliance or cause reconciliation issues.
 *
 * This operation is tightly controlled by security and compliance rules.
 * Related endpoints include GET /insuranceClaims/{insuranceClaimId} for
 * retrieval, and PATCH /insuranceClaims for searching claims history (including
 * soft-deleted claims when permitted).
 *
 * @param props.connection
 * @param props.insuranceClaimId Unique identifier of the insurance claim to
 *   delete.
 * @path /healthcarePlatform/organizationAdmin/insuranceClaims/:insuranceClaimId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.insuranceClaims.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the insurance claim to delete. */
    insuranceClaimId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/organizationAdmin/insuranceClaims/:insuranceClaimId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/insuranceClaims/${encodeURIComponent(props.insuranceClaimId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("insuranceClaimId")(() =>
        typia.assert(props.insuranceClaimId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
