import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformPatient } from "../../../../structures/IHealthcarePlatformPatient";
import { IPageIHealthcarePlatformPatient } from "../../../../structures/IPageIHealthcarePlatformPatient";

/**
 * Register a new patient user profile in healthcare_platform_patients.
 *
 * Register a new patient user profile in the platform, capturing required
 * demographic and identity information as defined in the
 * healthcare_platform_patients table. Required fields include email, full name,
 * and date of birth, with phone as optional. The POST operation validates input
 * for uniqueness (especially email), regulatory standards, and readiness for
 * audit trail logging. It integrates with downstream patient workflows,
 * including appointments, billing, and consent management, as well as security
 * and notification preferences.
 *
 * Role-based access ensures that both staff (such as receptionists and
 * organization admins) and patients (via self-service registration) can create
 * accounts as permitted by business policy. Error handling covers duplicate
 * email, invalid input, and compliance failures, with all creations subject to
 * audit and legal traceability. The response returns the created patient
 * profile and links it to the organization's patient record domain for further
 * operations and workflow integration.
 *
 * @param props.connection
 * @param props.body Patient registration/provisioning information according to
 *   healthcare_platform_patients schema.
 * @path /healthcarePlatform/organizationAdmin/patients
 * @accessor api.functional.healthcarePlatform.organizationAdmin.patients.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Patient registration/provisioning information according to
     * healthcare_platform_patients schema.
     */
    body: IHealthcarePlatformPatient.ICreate;
  };
  export type Body = IHealthcarePlatformPatient.ICreate;
  export type Response = IHealthcarePlatformPatient;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/patients",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/organizationAdmin/patients";
  export const random = (): IHealthcarePlatformPatient =>
    typia.random<IHealthcarePlatformPatient>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list patient accounts with filters and pagination in
 * healthcare_platform_patients.
 *
 * Retrieves a filtered and paginated list of patients within the
 * healthcarePlatform. Supports advanced search criteria and ordering for audit,
 * administration, and record location workflows.
 *
 * The API receives search conditions, sort order, and pagination input in the
 * request body (IHealthcarePlatformPatient.IRequest) and returns a result page
 * (IPageIHealthcarePlatformPatient.ISummary). Major filters include full_name
 * (partial match), date_of_birth, email, registration dates, and status. Only
 * authorized viewers (e.g., organizationAdmin or systemAdmin) may view detailed
 * results; access is privacy-checked for each row.
 *
 * The healthcare_platform_patients model enforces unique email and includes
 * fields required for compliance/audit. Data returned respects privacy flags
 * and consent as required by law/policy. Results are suitable for list UIs,
 * admin dashboards, and reporting workflows. Related endpoints exist for
 * individual record access and update.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination criteria for patients
 * @path /healthcarePlatform/organizationAdmin/patients
 * @accessor api.functional.healthcarePlatform.organizationAdmin.patients.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, and pagination criteria for patients */
    body: IHealthcarePlatformPatient.IRequest;
  };
  export type Body = IHealthcarePlatformPatient.IRequest;
  export type Response = IPageIHealthcarePlatformPatient.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/patients",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/organizationAdmin/patients";
  export const random = (): IPageIHealthcarePlatformPatient.ISummary =>
    typia.random<IPageIHealthcarePlatformPatient.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific patient profile by patientId from
 * healthcare_platform_patients.
 *
 * Retrieve a single patient user profile by specifying the unique patientId.
 * This operation is used to display or process detailed patient information as
 * stored in the healthcare_platform_patients table, including core attributes
 * (email, full_name, date_of_birth, phone, created_at, updated_at, and
 * deleted_at fields). Only active (not soft-deleted) records are returned, and
 * the operation enforces strict tenant data isolation—users can only access
 * patients within their organization context.
 *
 * Security and audit rules require that only roles with appropriate permission,
 * such as medicalDoctor, nurse, organizationAdmin, receptionist, and the
 * patient themselves, can access the profile, with all access events logged for
 * compliance and traceability. Attempts to view patient profiles outside scope
 * or organization boundaries are denied and audited per policy.
 *
 * This GET endpoint is intended for use alongside related API endpoints that
 * reference patients, such as listing their appointments or billing status. It
 * handles errors for not found, unauthorized, or deleted records and surfaces
 * audit trail entries as required for regulatory compliance.
 *
 * @param props.connection
 * @param props.patientId Unique identifier of the target patient user.
 * @path /healthcarePlatform/organizationAdmin/patients/:patientId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.patients.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target patient user. */
    patientId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformPatient;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/patients/:patientId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/patients/${encodeURIComponent(props.patientId ?? "null")}`;
  export const random = (): IHealthcarePlatformPatient =>
    typia.random<IHealthcarePlatformPatient>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientId")(() => typia.assert(props.patientId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing patient user profile in healthcare_platform_patients.
 *
 * Update the patient user profile for an existing patient in the system by
 * specifying their patientId and providing the updated fields. The operation is
 * anchored on the healthcare_platform_patients table and governs changes to
 * core profile information, including email, full_name, date_of_birth, and
 * phone. Update attempts are controlled by role-based access and input
 * validation (including uniqueness for email), and only permitted for
 * authorized users or the patient themselves as dictated by the organization’s
 * compliance and audit policies.
 *
 * The endpoint logs all changes for security, audit trail, and reportability
 * purposes. It supports integrations with dependent records such as patient
 * appointments and billing, ensuring changes propagate according to business
 * requirements. Error scenarios for invalid patientId, data conflicts, or
 * unauthorized modification requests are handled with appropriate responses,
 * ensuring compliance at every update event.
 *
 * @param props.connection
 * @param props.patientId Unique identifier of the patient to update.
 * @param props.body Fields to update for the patient profile as per
 *   healthcare_platform_patients schema.
 * @path /healthcarePlatform/organizationAdmin/patients/:patientId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.patients.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the patient to update. */
    patientId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the patient profile as per
     * healthcare_platform_patients schema.
     */
    body: IHealthcarePlatformPatient.IUpdate;
  };
  export type Body = IHealthcarePlatformPatient.IUpdate;
  export type Response = IHealthcarePlatformPatient;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/patients/:patientId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/patients/${encodeURIComponent(props.patientId ?? "null")}`;
  export const random = (): IHealthcarePlatformPatient =>
    typia.random<IHealthcarePlatformPatient>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientId")(() => typia.assert(props.patientId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a patient user profile by patientId (hard delete) from
 * healthcare_platform_patients.
 *
 * Permanently remove an existing patient user profile by their patientId in the
 * healthcare_platform_patients table. Normally, patient records are
 * soft-deleted (marked via deleted_at), retaining the data for compliance and
 * audit, but this DELETE endpoint is for cases requiring irreversible erasure
 * after full compliance review. Only superuser roles, such as
 * organizationAdmin, may use this operation, and all deletions are tracked in
 * audit logs for regulatory reporting and traceability.
 *
 * This operation is dangerous and should be guarded by compliance-check
 * workflows, including retention time validation and double-confirmation under
 * organizational escalation policy. It does not affect downstream linked
 * records, which may still be subject to regulatory hold or retention, but will
 * block access to the main patient profile from end-user and staff interfaces.
 * All failures, including unauthorized attempts, audit triggers, and invalid
 * patientId errors, are handled per organizational and compliance standards.
 *
 * @param props.connection
 * @param props.patientId Unique identifier of the patient to delete.
 * @path /healthcarePlatform/organizationAdmin/patients/:patientId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.patients.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the patient to delete. */
    patientId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/organizationAdmin/patients/:patientId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/patients/${encodeURIComponent(props.patientId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientId")(() => typia.assert(props.patientId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
