import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformPolicyVersion } from "../../../../structures/IHealthcarePlatformPolicyVersion";
import { IPageIHealthcarePlatformPolicyVersion } from "../../../../structures/IPageIHealthcarePlatformPolicyVersion";

/**
 * Create a new policy version entry in healthcare_platform_policy_versions for
 * compliance and legal management.
 *
 * Create a new policy version entity. The operation takes full policy version
 * details such as type, version, organization linkage, effective and expire
 * dates, document title, document URI, and (optionally) cryptographic hash for
 * audit. Requests are validated for uniqueness within org/policy scope,
 * timestamp logic (expiry after effectivity), and required fields. Upon
 * successful creation, the new policy version is available for referencing in
 * compliance consents, agreements, and system legal workflows.
 *
 * This API is restricted to compliance officers and system/organization
 * administrators, and all operations are audit-logged. Linked document URIs
 * must be accessible by compliance policy, and policy type/version/organization
 * combinations must be unique as enforced in the Prisma schema. Validation
 * errors return actionable feedback for business and compliance correction.
 * Usage and error events are recorded for regulatory oversight.
 *
 * @param props.connection
 * @param props.body Policy version details for addition—including policy type,
 *   version, title, effective/expire dates, URI, and (optionally) hash.
 * @path /healthcarePlatform/organizationAdmin/policyVersions
 * @accessor api.functional.healthcarePlatform.organizationAdmin.policyVersions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Policy version details for addition—including policy type, version,
     * title, effective/expire dates, URI, and (optionally) hash.
     */
    body: IHealthcarePlatformPolicyVersion.ICreate;
  };
  export type Body = IHealthcarePlatformPolicyVersion.ICreate;
  export type Response = IHealthcarePlatformPolicyVersion;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/policyVersions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/policyVersions";
  export const random = (): IHealthcarePlatformPolicyVersion =>
    typia.random<IHealthcarePlatformPolicyVersion>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate healthcare policy version records from the compliance
 * catalog (healthcare_platform_policy_versions).
 *
 * Retrieve a filtered and paginated list of policy versions. This endpoint
 * serves compliance, administrative, and audit use cases, empowering users to
 * discover which legal or operational policy versions are active for an
 * organization or department, and supports full-text search on titles and
 * semantic versioning. Sensitive to system-wide, organization- and
 * department-level scoping, this API confirms role permissions per
 * organizational boundaries.
 *
 * All fields from healthcare_platform_policy_versions are exposed for search
 * and display according to the user's role and allowed tenant. Policy versions
 * may be filtered by type, version label, effective or expiration dates, or
 * status (expired, active). If the requesting user is not authorized for a
 * particular organization, the API silently omits restricted data. This search
 * operation supports standard pagination and sorting on date or title fields.
 *
 * Validation ensures query parameters are structurally valid according to
 * schema. System audit logs will record query usage for compliance reporting.
 * Related API operations include: create, update, or retrieve policy version
 * detail. Error responses reflect standard compliance/permission boundaries.
 *
 * @param props.connection
 * @param props.body Paginated search, filter, and sort parameters for policy
 *   version listing.
 * @path /healthcarePlatform/organizationAdmin/policyVersions
 * @accessor api.functional.healthcarePlatform.organizationAdmin.policyVersions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Paginated search, filter, and sort parameters for policy version
     * listing.
     */
    body: IHealthcarePlatformPolicyVersion.IRequest;
  };
  export type Body = IHealthcarePlatformPolicyVersion.IRequest;
  export type Response = IPageIHealthcarePlatformPolicyVersion.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/policyVersions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/policyVersions";
  export const random = (): IPageIHealthcarePlatformPolicyVersion.ISummary =>
    typia.random<IPageIHealthcarePlatformPolicyVersion.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch detailed information about a specific healthcare policy version entity
 * from healthcare_platform_policy_versions.
 *
 * Retrieve full details for a policy version by its unique identifier. This
 * includes fields such as policy type, version label, effective and expiration
 * dates, full document URI, hash for audit, and metadata. The data model is
 * mapped directly to the Prisma model healthcare_platform_policy_versions,
 * ensuring audit-grade traceability.
 *
 * Access is granted only to users with appropriate compliance or administrative
 * roles for the organization that owns the policy version. This API is used for
 * legal review, patient consent enforcement, and supporting evidence during
 * regulatory audits. Usage is always logged for compliance tracking.
 *
 * Request validation ensures the version ID format matches UUID standards.
 * Policy version records with restricted access are not displayed to
 * unauthorized users, and the system complies fully with tenant isolation
 * principles.
 *
 * @param props.connection
 * @param props.policyVersionId Unique identifier (UUID) of the target policy
 *   version to retrieve.
 * @path /healthcarePlatform/organizationAdmin/policyVersions/:policyVersionId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.policyVersions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the target policy version to retrieve. */
    policyVersionId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformPolicyVersion;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/policyVersions/:policyVersionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/policyVersions/${encodeURIComponent(props.policyVersionId ?? "null")}`;
  export const random = (): IHealthcarePlatformPolicyVersion =>
    typia.random<IHealthcarePlatformPolicyVersion>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyVersionId")(() =>
        typia.assert(props.policyVersionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a policy version entry in healthcare_platform_policy_versions,
 * allowing legal/compliance metadata correction and auditability.
 *
 * Update an existing policy version entity by its unique identifier. This
 * operation covers fields such as title, expiration date, document URI, hash,
 * or description, while preserving versioning and regulatory integrity.
 * Validation checks for conflicting versions, window logic (no expiry before
 * effective), and ensures organization/tenant boundaries. Only authorized roles
 * may invoke this endpoint; unauthorized attempts are blocked and logged for
 * compliance.
 *
 * Upon successful update, the policy version record reflects the new metadata,
 * and downstream consent agreements or legal references remain linked to the
 * same immutable version row. All changes are audit-logged. Policy version
 * update is a critical compliance function for ensuring policy documents remain
 * current, accessible, and regulation-ready.
 *
 * @param props.connection
 * @param props.policyVersionId Unique identifier (UUID) of the policy version
 *   entity to update.
 * @param props.body Partial or full update payload for policy version fields:
 *   title, effective window, document URI/hash, and organizational context.
 * @path /healthcarePlatform/organizationAdmin/policyVersions/:policyVersionId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.policyVersions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the policy version entity to update. */
    policyVersionId: string & tags.Format<"uuid">;

    /**
     * Partial or full update payload for policy version fields: title,
     * effective window, document URI/hash, and organizational context.
     */
    body: IHealthcarePlatformPolicyVersion.IUpdate;
  };
  export type Body = IHealthcarePlatformPolicyVersion.IUpdate;
  export type Response = IHealthcarePlatformPolicyVersion;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/policyVersions/:policyVersionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/policyVersions/${encodeURIComponent(props.policyVersionId ?? "null")}`;
  export const random = (): IHealthcarePlatformPolicyVersion =>
    typia.random<IHealthcarePlatformPolicyVersion>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyVersionId")(() =>
        typia.assert(props.policyVersionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a specific policy version by policyVersionId from the
 * healthcare_platform_policy_versions table.
 *
 * This API operation provides the ability to permanently remove a policy
 * version entry from the healthcare_platform_policy_versions table. Policy
 * versions track specific legal, regulatory, or business policy documents by
 * organization, and are referenced by patient or staff consents and compliance
 * agreements.
 *
 * When invoked, the operation expects a valid policyVersionId formatted as a
 * UUID to be provided in the route path. Upon execution, the API will target
 * and remove the specified policy version directly from the database.
 *
 * Security considerations mandate that only system or organization
 * administrators with explicit compliance permission may access this endpoint
 * due to the sensitive nature of compliance documentation. Any attempt to erase
 * a policy version that is currently referenced by active consents or
 * agreements may violate auditability or regulatory requirements; implementers
 * should verify referential integrity prior to deletion. The operation
 * implements a hard delete, as the schema does not include a soft-delete field
 * for the policy_versions model.
 *
 * This endpoint is not suitable for retire/archive behavior, which may be
 * implemented in future versions through a deleted_at or similar field, but
 * currently results in full removal of the record. All audit trails and access
 * logs should accurately record the actor, time, and policy details involved in
 * the deletion for compliance purposes.
 *
 * @param props.connection
 * @param props.policyVersionId Unique identifier of the policy version to
 *   delete (UUID format).
 * @path /healthcarePlatform/organizationAdmin/policyVersions/:policyVersionId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.policyVersions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the policy version to delete (UUID format). */
    policyVersionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/organizationAdmin/policyVersions/:policyVersionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/policyVersions/${encodeURIComponent(props.policyVersionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyVersionId")(() =>
        typia.assert(props.policyVersionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
