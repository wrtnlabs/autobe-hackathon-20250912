import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformUserAuthentication } from "../../../../structures/IHealthcarePlatformUserAuthentication";
import { IPageIHealthcarePlatformUserAuthentication } from "../../../../structures/IPageIHealthcarePlatformUserAuthentication";

/**
 * Create a new user authentication credential record
 * (healthcare_platform_user_authentications).
 *
 * Create a new user authentication record for a user, supporting a wide range
 * of authentication providers including local, SSO, and federated mechanisms.
 * The request accepts all required fields as defined in the
 * healthcare_platform_user_authentications schema: user_id, user_type (to
 * reference actor table), provider (login mechanism), provider_key, and any
 * optional password_hash or configuration required by the selected provider.
 * For local credentials, password strength and format are validated according
 * to platform security policy.
 *
 * **For security, password hashes and credential secrets are strictly
 * write-only and NEVER returned or exposed in any API response.**
 *
 * Access to this endpoint is strictly limited to privileged roles (system
 * administrators, organization administrators), and all actions are logged for
 * identity traceability and regulatory compliance. The operation returns the
 * complete newly-created authentication record for further processing (such as
 * issuing a login session or associating with user profile), or error
 * information if policy checks fail or data is invalid.
 *
 * @param props.connection
 * @param props.body Data required to create a new user authentication record,
 *   including user, provider, and credential information.
 * @path /healthcarePlatform/organizationAdmin/userAuthentications
 * @accessor api.functional.healthcarePlatform.organizationAdmin.userAuthentications.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Data required to create a new user authentication record, including
     * user, provider, and credential information.
     */
    body: IHealthcarePlatformUserAuthentication.ICreate;
  };
  export type Body = IHealthcarePlatformUserAuthentication.ICreate;
  export type Response = IHealthcarePlatformUserAuthentication;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/userAuthentications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/userAuthentications";
  export const random = (): IHealthcarePlatformUserAuthentication =>
    typia.random<IHealthcarePlatformUserAuthentication>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of user authentication records
 * (healthcare_platform_user_authentications).
 *
 * Retrieve a paginated and filtered set of user authentication records from the
 * system, supporting use cases such as security audits, credential inventory
 * management, or compliance reviews in the healthcarePlatform. This endpoint
 * enables searching by user_type, authentication provider, provider_key,
 * organizational context, last_authenticated_at timestamps, and credential
 * status, with the option to use multiple combined filters and sorting.
 *
 * All records returned reflect current and historical user authentication
 * configurations used for sign-in (including SSO, AD, OAuth2, and local login),
 * enabling system and organization administrators to view or audit the
 * credential lifecycle. The endpoint is optimized for use cases such as
 * periodic access review, investigation of sign-in anomalies, and
 * compliance/reporting dashboards. Response data includes paginated summary
 * objects suitable for UI display, with relevant metadata such as pagination,
 * record count, and navigation context.
 *
 * **For security, credential secret fields such as password hashes are never
 * returned in responses.**
 *
 * Access to this endpoint is restricted to roles with platform-level or
 * organization-level authentication management privileges (e.g., 'systemAdmin',
 * 'organizationAdmin'), and the response is filtered based on the caller's
 * organization scopes.
 *
 * @param props.connection
 * @param props.body Search filters and pagination parameters for user
 *   authentication record retrieval.
 * @path /healthcarePlatform/organizationAdmin/userAuthentications
 * @accessor api.functional.healthcarePlatform.organizationAdmin.userAuthentications.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search filters and pagination parameters for user authentication
     * record retrieval.
     */
    body: IHealthcarePlatformUserAuthentication.IRequest;
  };
  export type Body = IHealthcarePlatformUserAuthentication.IRequest;
  export type Response = IPageIHealthcarePlatformUserAuthentication.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/userAuthentications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/userAuthentications";
  export const random =
    (): IPageIHealthcarePlatformUserAuthentication.ISummary =>
      typia.random<IPageIHealthcarePlatformUserAuthentication.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full details for a user authentication record
 * (healthcare_platform_user_authentications) by ID.
 *
 * Get detailed information for a specific user authentication record,
 * identified by the userAuthenticationId path parameter, as defined in the
 * healthcare_platform_user_authentications database schema. The operation
 * returns all stored attributes for the record, including user_type,
 * authentication provider, provider_key, last authentication timestamps, and
 * associated meta-information.
 *
 * **For security, password hashes and any credential secrets are never included
 * in the response.**
 *
 * This endpoint is intended for privileged roles such as system administrators
 * and organization administrators, and is generally invoked for diagnosing
 * authentication issues, reviewing SSO or authentication configuration for a
 * particular user, or investigating audit-related incidents. Access is strictly
 * limited to authorized personnel, and the operation logs all requests for
 * compliance and forensic purposes.
 *
 * A correct userAuthenticationId (UUID) must be provided in the path, with
 * access checks ensuring the caller has organization/platform scope for the
 * requested record. The operation also returns error information in the case of
 * missing or unauthorized access attempts.
 *
 * @param props.connection
 * @param props.userAuthenticationId Unique identifier for the user
 *   authentication record to retrieve.
 * @path /healthcarePlatform/organizationAdmin/userAuthentications/:userAuthenticationId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.userAuthentications.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the user authentication record to retrieve. */
    userAuthenticationId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformUserAuthentication;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/userAuthentications/:userAuthenticationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/userAuthentications/${encodeURIComponent(props.userAuthenticationId ?? "null")}`;
  export const random = (): IHealthcarePlatformUserAuthentication =>
    typia.random<IHealthcarePlatformUserAuthentication>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userAuthenticationId")(() =>
        typia.assert(props.userAuthenticationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update authentication credential record for a user
 * (healthcare_platform_user_authentications) by ID.
 *
 * Modify the fields of an existing user authentication record by its unique ID
 * (userAuthenticationId), according to the
 * healthcare_platform_user_authentications database schema. This operation
 * supports updates such as password rotation (for local credentials),
 * SSO/federated configuration changes, status changes (enabled/disabled), or
 * provider/provider_key changes as per platform policy. Fields included in the
 * request body are validated against organizational security requirements, and
 * sensitive data such as passwords are securely handled and must NEVER be
 * returned in any API response.
 *
 * All update actions are fully logged for compliance, supporting use cases such
 * as account remediation, deprovisioning, or credential reset workflows for
 * internal security or audit. The operation returns the fully-updated
 * authentication record on success, or includes error context in the case of
 * invalid, unauthorized, or policy-violating updates.
 *
 * **Credential secrets are always write-only—never returned or exposed in any
 * way.**
 *
 * Access is restricted to system administrators or organization administrators,
 * who are responsible for complying with platform/corporate security
 * requirements.
 *
 * @param props.connection
 * @param props.userAuthenticationId Unique identifier for the user
 *   authentication record to update.
 * @param props.body Fields to update for the user authentication record, based
 *   on the provider and organizational policy.
 * @path /healthcarePlatform/organizationAdmin/userAuthentications/:userAuthenticationId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.userAuthentications.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the user authentication record to update. */
    userAuthenticationId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the user authentication record, based on the
     * provider and organizational policy.
     */
    body: IHealthcarePlatformUserAuthentication.IUpdate;
  };
  export type Body = IHealthcarePlatformUserAuthentication.IUpdate;
  export type Response = IHealthcarePlatformUserAuthentication;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/userAuthentications/:userAuthenticationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/userAuthentications/${encodeURIComponent(props.userAuthenticationId ?? "null")}`;
  export const random = (): IHealthcarePlatformUserAuthentication =>
    typia.random<IHealthcarePlatformUserAuthentication>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userAuthenticationId")(() =>
        typia.assert(props.userAuthenticationId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
