import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformAppointment } from "../../../../structures/IHealthcarePlatformAppointment";
import { IPageIHealthcarePlatformAppointment } from "../../../../structures/IPageIHealthcarePlatformAppointment";
export * as reminders from "./reminders/index";
export * as waitlists from "./waitlists/index";

/**
 * Create a new appointment in healthcare_platform_appointments table.
 *
 * Creates a new appointment event within the healthcare platform, linking the
 * provided organization, provider, patient, status, type, and time fields. This
 * operation checks for resource and schedule availability, enforces access
 * control based on the user's role, and integrates with the multi-tenant
 * structure for isolation. Validation rules require that booking does not
 * conflict with existing appointments for both provider and patient, and that
 * the status code, organization, and provider are valid.
 *
 * On success, the operation returns a complete appointment record as defined in
 * the Prisma schema, including references to related entities. Potential errors
 * include invalid entity references, scheduling conflicts, insufficient
 * permissions, or missing required fields. The created appointment is
 * immediately available for further management (e.g., updating, reminder
 * scheduling) by authorized roles (receptionists, admins, providers).
 *
 * These APIs are integrated with business logic to ensure compliance,
 * auditability, and operational safety in healthcare scheduling.
 *
 * @param props.connection
 * @param props.body Details required to create a new appointment, including
 *   organization, provider, patient, status, type, time, and optional
 *   metadata.
 * @path /healthcarePlatform/medicalDoctor/appointments
 * @accessor api.functional.healthcarePlatform.medicalDoctor.appointments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Details required to create a new appointment, including organization,
     * provider, patient, status, type, time, and optional metadata.
     */
    body: IHealthcarePlatformAppointment.ICreate;
  };
  export type Body = IHealthcarePlatformAppointment.ICreate;
  export type Response = IHealthcarePlatformAppointment;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/medicalDoctor/appointments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/medicalDoctor/appointments";
  export const random = (): IHealthcarePlatformAppointment =>
    typia.random<IHealthcarePlatformAppointment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate appointments across providers, patients, and departments
 * (healthcare_platform_appointments).
 *
 * Search, paginate, and filter scheduled appointments in the system. The
 * healthcare_platform_appointments schema enables robust querying by provider,
 * patient, organization, department, date range, appointment type, resource,
 * and more. Filtering logic enforces role-based data access boundaries—doctors,
 * nurses can see appointments relevant to their patients or department,
 * receptionists can view organizational schedules, and patients can query their
 * own slots only.
 *
 * The request body allows for compound filters, sorting (by start_time, status,
 * provider, etc.), and pagination (page number, page size, result window).
 * Business logic ensures that only users with proper assignment and role may
 * query appointments. Attempting to view or search schedules outside one's
 * organizational or patient scope is denied with a clear error. Privacy and
 * data minimization constraints are observed throughout.
 *
 * Audit logging records filter usage and all access events for compliance. The
 * response includes paginated appointment summaries (without PHI) suitable for
 * calendar views or dashboard widgets. Full appointment details require
 * additional API calls where permitted. This operation is suitable for
 * integration with both staff-oriented and patient self-service scheduling
 * interfaces.
 *
 * @param props.connection
 * @param props.body Search, filtering, and pagination parameters for
 *   appointments.
 * @path /healthcarePlatform/medicalDoctor/appointments
 * @accessor api.functional.healthcarePlatform.medicalDoctor.appointments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filtering, and pagination parameters for appointments. */
    body: IHealthcarePlatformAppointment.IRequest;
  };
  export type Body = IHealthcarePlatformAppointment.IRequest;
  export type Response = IPageIHealthcarePlatformAppointment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/medicalDoctor/appointments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/medicalDoctor/appointments";
  export const random = (): IPageIHealthcarePlatformAppointment.ISummary =>
    typia.random<IPageIHealthcarePlatformAppointment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch detailed information for a specific appointment by ID
 * (healthcare_platform_appointments).
 *
 * Retrieve full detail for a single appointment event. The
 * healthcare_platform_appointments table captures all scheduling
 * details—organization, department, provider, patient, room/equipment, status,
 * time window, and description. User access is strictly controlled: only
 * assigned provider, patient, or authorized staff roles may fetch appointment
 * data.
 *
 * The path parameter appointmentId uniquely identifies the appointment to
 * retrieve. The system enforces RBAC/organizational boundaries, ensuring
 * patients only see their own appointment details, providers see theirs, and
 * admins/receptionists have wider access. Business logic may redact or minimize
 * PHI in patient-facing responses.
 *
 * Audit logs are created for each access to appointment details in accordance
 * with regulatory requirements. Related operations include PATCH /appointments
 * for searching, and PUT/DELETE for update/deletion. This operation returns the
 * appointment record in detail if authorized, or an error if not permitted.
 *
 * @param props.connection
 * @param props.appointmentId Unique identifier of the appointment event.
 * @path /healthcarePlatform/medicalDoctor/appointments/:appointmentId
 * @accessor api.functional.healthcarePlatform.medicalDoctor.appointments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the appointment event. */
    appointmentId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformAppointment;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/medicalDoctor/appointments/:appointmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/medicalDoctor/appointments/${encodeURIComponent(props.appointmentId ?? "null")}`;
  export const random = (): IHealthcarePlatformAppointment =>
    typia.random<IHealthcarePlatformAppointment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appointmentId")(() => typia.assert(props.appointmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing appointment by ID in healthcare_platform_appointments
 * table.
 *
 * Modifies the details of an existing appointment in the healthcare platform,
 * allowing changes such as time, status, provider, or supporting fields. The
 * operation enforces business rules including: no time slot overlap, ensuring
 * status transitions are allowed for the given state, and confirming the user
 * is permitted to update the appointment (ownership or role-based
 * restriction).
 *
 * If the update involves changing critical properties like provider or time,
 * the system checks for conflicts and may trigger downstream updates (e.g.,
 * room/equipment reallocation, reminders, or telemedicine session updates).
 * Audit logs are generated for clinical, billing, and operational compliance.
 * Error handling includes conflict, not found, or permission errors.
 *
 * All changes are immediately reflected in the appointment record, and the
 * updated appointment is returned on success.
 *
 * @param props.connection
 * @param props.appointmentId Unique identifier of the appointment to update
 * @param props.body Fields and values to update for the appointment. Can
 *   include time, status, provider, description, room, equipment, etc.
 * @path /healthcarePlatform/medicalDoctor/appointments/:appointmentId
 * @accessor api.functional.healthcarePlatform.medicalDoctor.appointments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the appointment to update */
    appointmentId: string & tags.Format<"uuid">;

    /**
     * Fields and values to update for the appointment. Can include time,
     * status, provider, description, room, equipment, etc.
     */
    body: IHealthcarePlatformAppointment.IUpdate;
  };
  export type Body = IHealthcarePlatformAppointment.IUpdate;
  export type Response = IHealthcarePlatformAppointment;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/medicalDoctor/appointments/:appointmentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/medicalDoctor/appointments/${encodeURIComponent(props.appointmentId ?? "null")}`;
  export const random = (): IHealthcarePlatformAppointment =>
    typia.random<IHealthcarePlatformAppointment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appointmentId")(() => typia.assert(props.appointmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (soft) an appointment by ID in healthcare_platform_appointments table.
 *
 * Deletes (soft delete via deleted_at field) an appointment by unique
 * identifier. The method enforces access control so only authorized roles
 * within the appointment's organization/department may mark it deleted.
 * Business logic checks include: existence, reference integrity, and protection
 * for appointments involved in billing or legal workflows.
 *
 * Upon success, the appointment is removed from active schedules and workflows
 * but is retained for audit and compliance. Attempts to erase an appointment
 * outside the user’s permitted scope or on protected records (e.g., closed
 * billing, locked by compliance) return appropriate errors. All delete actions
 * are logged in the audit subsystem.
 *
 * @param props.connection
 * @param props.appointmentId Unique identifier of the appointment to delete
 * @path /healthcarePlatform/medicalDoctor/appointments/:appointmentId
 * @accessor api.functional.healthcarePlatform.medicalDoctor.appointments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the appointment to delete */
    appointmentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/medicalDoctor/appointments/:appointmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/medicalDoctor/appointments/${encodeURIComponent(props.appointmentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appointmentId")(() => typia.assert(props.appointmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
