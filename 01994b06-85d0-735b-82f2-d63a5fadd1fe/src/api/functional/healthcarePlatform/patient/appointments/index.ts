import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformAppointment } from "../../../../structures/IHealthcarePlatformAppointment";
import { IPageIHealthcarePlatformAppointment } from "../../../../structures/IPageIHealthcarePlatformAppointment";
export * as reminders from "./reminders/index";
export * as waitlists from "./waitlists/index";

/**
 * Search and paginate appointments across providers, patients, and departments
 * (healthcare_platform_appointments).
 *
 * Search, paginate, and filter scheduled appointments in the system. The
 * healthcare_platform_appointments schema enables robust querying by provider,
 * patient, organization, department, date range, appointment type, resource,
 * and more. Filtering logic enforces role-based data access boundaries—doctors,
 * nurses can see appointments relevant to their patients or department,
 * receptionists can view organizational schedules, and patients can query their
 * own slots only.
 *
 * The request body allows for compound filters, sorting (by start_time, status,
 * provider, etc.), and pagination (page number, page size, result window).
 * Business logic ensures that only users with proper assignment and role may
 * query appointments. Attempting to view or search schedules outside one's
 * organizational or patient scope is denied with a clear error. Privacy and
 * data minimization constraints are observed throughout.
 *
 * Audit logging records filter usage and all access events for compliance. The
 * response includes paginated appointment summaries (without PHI) suitable for
 * calendar views or dashboard widgets. Full appointment details require
 * additional API calls where permitted. This operation is suitable for
 * integration with both staff-oriented and patient self-service scheduling
 * interfaces.
 *
 * @param props.connection
 * @param props.body Search, filtering, and pagination parameters for
 *   appointments.
 * @path /healthcarePlatform/patient/appointments
 * @accessor api.functional.healthcarePlatform.patient.appointments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filtering, and pagination parameters for appointments. */
    body: IHealthcarePlatformAppointment.IRequest;
  };
  export type Body = IHealthcarePlatformAppointment.IRequest;
  export type Response = IPageIHealthcarePlatformAppointment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/patient/appointments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/patient/appointments";
  export const random = (): IPageIHealthcarePlatformAppointment.ISummary =>
    typia.random<IPageIHealthcarePlatformAppointment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch detailed information for a specific appointment by ID
 * (healthcare_platform_appointments).
 *
 * Retrieve full detail for a single appointment event. The
 * healthcare_platform_appointments table captures all scheduling
 * details—organization, department, provider, patient, room/equipment, status,
 * time window, and description. User access is strictly controlled: only
 * assigned provider, patient, or authorized staff roles may fetch appointment
 * data.
 *
 * The path parameter appointmentId uniquely identifies the appointment to
 * retrieve. The system enforces RBAC/organizational boundaries, ensuring
 * patients only see their own appointment details, providers see theirs, and
 * admins/receptionists have wider access. Business logic may redact or minimize
 * PHI in patient-facing responses.
 *
 * Audit logs are created for each access to appointment details in accordance
 * with regulatory requirements. Related operations include PATCH /appointments
 * for searching, and PUT/DELETE for update/deletion. This operation returns the
 * appointment record in detail if authorized, or an error if not permitted.
 *
 * @param props.connection
 * @param props.appointmentId Unique identifier of the appointment event.
 * @path /healthcarePlatform/patient/appointments/:appointmentId
 * @accessor api.functional.healthcarePlatform.patient.appointments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the appointment event. */
    appointmentId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformAppointment;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/patient/appointments/:appointmentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/patient/appointments/${encodeURIComponent(props.appointmentId ?? "null")}`;
  export const random = (): IHealthcarePlatformAppointment =>
    typia.random<IHealthcarePlatformAppointment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appointmentId")(() => typia.assert(props.appointmentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
