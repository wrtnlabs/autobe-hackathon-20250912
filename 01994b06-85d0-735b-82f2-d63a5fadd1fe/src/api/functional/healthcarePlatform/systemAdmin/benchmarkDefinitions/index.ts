import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformBenchmarkDefinition } from "../../../../structures/IHealthcarePlatformBenchmarkDefinition";
import { IPageIHealthcarePlatformBenchmarkDefinition } from "../../../../structures/IPageIHealthcarePlatformBenchmarkDefinition";

/**
 * Create a new analytics benchmark definition
 * (healthcare_platform_benchmark_definitions table).
 *
 * Create a benchmark definition record, supporting analytics, reporting, and
 * outcomes comparison for healthcare organizations. The endpoint is used mainly
 * by systemAdmins and orgAdmins to define or update targets for outcome
 * metrics, KPIs, or other analytic normalization needs.
 *
 * Security considerations: Only systemAdmins and organizationAdmins with active
 * status can use this operation; bench marks may affect quality reporting and
 * should be version controlled. The endpoint validates uniqueness by
 * organization and benchmark_code.
 *
 * The database model mandates required fields such as organization_id (optional
 * for global), benchmark_code (unique within org), value, unit, label,
 * effective_start_at, and supports optional description and effective_end_at.
 * Proper type and validation are enforced per the schema.
 *
 * Errors: Duplicate codes, invalid or missing organization links, invalid
 * dates, or missing mandatory fields will cause errors. Related endpoints are
 * available for updating and deleting benchmarks.
 *
 * @param props.connection
 * @param props.body Benchmark creation payload with required organization,
 *   code, value, unit, and effective start/end dates.
 * @path /healthcarePlatform/systemAdmin/benchmarkDefinitions
 * @accessor api.functional.healthcarePlatform.systemAdmin.benchmarkDefinitions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Benchmark creation payload with required organization, code, value,
     * unit, and effective start/end dates.
     */
    body: IHealthcarePlatformBenchmarkDefinition.ICreate;
  };
  export type Body = IHealthcarePlatformBenchmarkDefinition.ICreate;
  export type Response = IHealthcarePlatformBenchmarkDefinition;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/systemAdmin/benchmarkDefinitions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/systemAdmin/benchmarkDefinitions";
  export const random = (): IHealthcarePlatformBenchmarkDefinition =>
    typia.random<IHealthcarePlatformBenchmarkDefinition>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search available benchmark definitions for healthcare KPI/analytics
 * reporting.
 *
 * Search and retrieve a filtered and paginated list of benchmark definitions
 * for clinical/operational analytics from the
 * healthcare_platform_benchmark_definitions table. Benchmarks define target
 * values, thresholds, and comparators for organizational or department-level
 * KPIsâ€”for example, national average readmission rates, infection benchmarks,
 * etc. Supported request filter parameters include organization_id, code,
 * label, value range, unit, effective start/end, and logical status. The PATCH
 * method is used to accommodate complex and extensible filtering logic, plus
 * scalable pagination and sorting.
 *
 * This endpoint enforces that the requesting user has analytics dashboard,
 * system admin, or organization admin rights for any organization whose
 * benchmarks they query. Access to global or cross-organization benchmarks is
 * restricted, unless specifically permitted. Returned data includes summaries
 * optimized for dashboard and comparative reporting. Results may be large, so
 * clients must honor pagination metadata and consider cache usage for invariant
 * benchmarks.
 *
 * Related APIs: detail GET (for full record), create/put (for adding or
 * updating), and delete (for stewardship or deprecation workflows). All access
 * and search filters are logged for compliance and audit purposes.
 *
 * @param props.connection
 * @param props.body Filter and pagination criteria for benchmark search
 *   (IHealthcarePlatformBenchmarkDefinition.IRequest).
 * @path /healthcarePlatform/systemAdmin/benchmarkDefinitions
 * @accessor api.functional.healthcarePlatform.systemAdmin.benchmarkDefinitions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter and pagination criteria for benchmark search
     * (IHealthcarePlatformBenchmarkDefinition.IRequest).
     */
    body: IHealthcarePlatformBenchmarkDefinition.IRequest;
  };
  export type Body = IHealthcarePlatformBenchmarkDefinition.IRequest;
  export type Response = IPageIHealthcarePlatformBenchmarkDefinition.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/systemAdmin/benchmarkDefinitions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/systemAdmin/benchmarkDefinitions";
  export const random =
    (): IPageIHealthcarePlatformBenchmarkDefinition.ISummary =>
      typia.random<IPageIHealthcarePlatformBenchmarkDefinition.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get full detail of a benchmark definition
 * (IHealthcarePlatformBenchmarkDefinition) by benchmarkId.
 *
 * Retrieve the full detail of a single benchmark definition for healthcare
 * analytics by supplying its unique benchmarkId (UUID). Benchmarks represent
 * static or evolving reference points for assessment of key performance
 * indicators (KPIs), such as clinical or operational targets. The Prisma schema
 * for healthcare_platform_benchmark_definitions provides all structured and
 * descriptive columns: benchmark_code, label, description, value, unit,
 * effective dates, organization ownership, etc. This endpoint enforces that
 * only users with analytics, reporting, or high-level organization/system admin
 * rights may access organization-specific or global benchmarks. Common use
 * cases include populating dashboards with reference targets, running
 * comparative audits, or presenting compliance context within analytics
 * applications. All access is logged for audit purposes, and errors are
 * generated if an invalid or unauthorized benchmarkId is supplied. Related
 * endpoints include PATCH /benchmarkDefinitions for filtered lists and PUT/POST
 * for stewardship workflows.
 *
 * @param props.connection
 * @param props.benchmarkId The unique identifier (UUID) for the benchmark
 *   definition record to retrieve.
 * @path /healthcarePlatform/systemAdmin/benchmarkDefinitions/:benchmarkId
 * @accessor api.functional.healthcarePlatform.systemAdmin.benchmarkDefinitions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * The unique identifier (UUID) for the benchmark definition record to
     * retrieve.
     */
    benchmarkId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformBenchmarkDefinition;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/systemAdmin/benchmarkDefinitions/:benchmarkId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/benchmarkDefinitions/${encodeURIComponent(props.benchmarkId ?? "null")}`;
  export const random = (): IHealthcarePlatformBenchmarkDefinition =>
    typia.random<IHealthcarePlatformBenchmarkDefinition>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("benchmarkId")(() => typia.assert(props.benchmarkId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing benchmark definition
 * (healthcare_platform_benchmark_definitions table).
 *
 * Update an existing benchmark definition record to change its metadata or
 * business value. Only systemAdmin and organizationAdmin with adequate
 * privileges may execute this operation; operation enforces full validation and
 * audit compliance.
 *
 * The operation requires the benchmarkId as path parameter, referencing the
 * primary key. Update fields include label, benchmark_code, value, unit,
 * effective_start_at, effective_end_at, and description. The logic enforces
 * uniqueness, valid data ranges, and may perform partial updates while tracking
 * the updated_at timestamp.
 *
 * If the benchmark is organization-scoped, the caller must be in the same
 * organization. Errors arise if benchmarkId is missing/not found, data fails
 * constraints, or the user lacks permission. Audited for compliance. Related
 * endpoints: benchmark create and delete.
 *
 * @param props.connection
 * @param props.benchmarkId The unique identifier of the benchmark definition to
 *   update.
 * @param props.body Payload to update benchmark definition fields.
 * @path /healthcarePlatform/systemAdmin/benchmarkDefinitions/:benchmarkId
 * @accessor api.functional.healthcarePlatform.systemAdmin.benchmarkDefinitions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier of the benchmark definition to update. */
    benchmarkId: string & tags.Format<"uuid">;

    /** Payload to update benchmark definition fields. */
    body: IHealthcarePlatformBenchmarkDefinition.IUpdate;
  };
  export type Body = IHealthcarePlatformBenchmarkDefinition.IUpdate;
  export type Response = IHealthcarePlatformBenchmarkDefinition;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/systemAdmin/benchmarkDefinitions/:benchmarkId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/systemAdmin/benchmarkDefinitions/${encodeURIComponent(props.benchmarkId ?? "null")}`;
  export const random = (): IHealthcarePlatformBenchmarkDefinition =>
    typia.random<IHealthcarePlatformBenchmarkDefinition>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("benchmarkId")(() => typia.assert(props.benchmarkId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an analytics benchmark definition entry
 * (healthcare_platform_benchmark_definitions table).
 *
 * Delete a benchmark definition record by unique ID. This operation is
 * restricted to systemAdmins and organizationAdmins, with validation to ensure
 * the benchmark is in the correct organizational context.
 *
 * If model supports soft delete (as per deleted_at), the record is marked
 * deleted but retained for compliance audit; otherwise, the removal is hard
 * delete. Operation enforces referential integrity and prevents removal if the
 * benchmark is used by active KPIs.
 *
 * Security: Only privileged roles (systemAdmin, organizationAdmin) can delete,
 * and all deletions are logged. Related operations: create and update for
 * benchmarks.
 *
 * @param props.connection
 * @param props.benchmarkId The unique identifier of the benchmark definition to
 *   delete.
 * @path /healthcarePlatform/systemAdmin/benchmarkDefinitions/:benchmarkId
 * @accessor api.functional.healthcarePlatform.systemAdmin.benchmarkDefinitions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the benchmark definition to delete. */
    benchmarkId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/systemAdmin/benchmarkDefinitions/:benchmarkId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/benchmarkDefinitions/${encodeURIComponent(props.benchmarkId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("benchmarkId")(() => typia.assert(props.benchmarkId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
