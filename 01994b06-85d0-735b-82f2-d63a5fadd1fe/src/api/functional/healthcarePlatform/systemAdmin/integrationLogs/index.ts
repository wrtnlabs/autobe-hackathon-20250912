import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformIntegrationLog } from "../../../../structures/IHealthcarePlatformIntegrationLog";
import { IPageIHealthcarePlatformIntegrationLog } from "../../../../structures/IPageIHealthcarePlatformIntegrationLog";

/**
 * Search and retrieve filtered/paginated integration logs for monitoring and
 * audit.
 *
 * Retrieve a filtered and paginated list of integration logs that record all
 * integration-related status, success, error, or event messages for this
 * healthcare platform. This API supports complex search, sorting, and filtering
 * across all log attributes, including integration_type (such as 'emr', 'lab',
 * 'pharmacy', 'insurance', 'device'), event_status, event_code, organization,
 * and flexible date/time ranges.
 *
 * Advanced auditing and troubleshooting are supported: administrators and
 * technical teams can quickly locate integration failures, performance issues,
 * or external system outages, supporting rapid forensic analysis and
 * operational troubleshooting. The Prisma schema ensures every log entry is
 * uniquely linked to the relevant organization and includes severity,
 * timestamp, and context information for regulatory and support compliance.
 *
 * Security and access are tightly controlled. This endpoint is restricted to
 * platform/system administrators and organization administrators with
 * integration monitoring responsibility. All access and query actions are
 * themselves logged to an audit trail. Results can be exported for offline
 * compliance review.
 *
 * This API should be combined with detailed event and incident views, which
 * show full information for each log entry (e.g., via GET
 * /integrationLogs/{integrationLogId}) for root-cause analysis and
 * cross-referencing related events.
 *
 * @param props.connection
 * @param props.body Search and pagination criteria for integration log
 *   filtering (type, status, organization, date range, etc.)
 * @path /healthcarePlatform/systemAdmin/integrationLogs
 * @accessor api.functional.healthcarePlatform.systemAdmin.integrationLogs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and pagination criteria for integration log filtering (type,
     * status, organization, date range, etc.)
     */
    body: IHealthcarePlatformIntegrationLog.IRequest;
  };
  export type Body = IHealthcarePlatformIntegrationLog.IRequest;
  export type Response = IPageIHealthcarePlatformIntegrationLog.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/systemAdmin/integrationLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/systemAdmin/integrationLogs";
  export const random = (): IPageIHealthcarePlatformIntegrationLog.ISummary =>
    typia.random<IPageIHealthcarePlatformIntegrationLog.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve full detail for a specific integration log event by ID.
 *
 * Retrieve a single, fully detailed integration log event using its unique log
 * ID (integrationLogId). The detail includes type of integration, status,
 * related error messages, payload links, context data, timestamps, severity
 * indicators, and any attached troubleshooting or remediation notes.
 *
 * This endpoint is used by system and organization administrators to review the
 * root cause and full context of technical events, system-monitoring incidents,
 * integration failures, and audit-log triggers. The Prisma IntegrationLog model
 * ensures traceable linkage to organizations and event context, which is
 * required for regulatory audits when incidents or external system failures are
 * investigated.
 *
 * Strict security and audit controls apply: access is limited to technical and
 * admin staff with incident investigation responsibility. All read access
 * actions are themselves logged in the platform's audit trail. The details
 * revealed can support service restoration, external partner escalation, and
 * compliance reporting.
 *
 * @param props.connection
 * @param props.integrationLogId Unique identifier of the integration log record
 *   to retrieve.
 * @path /healthcarePlatform/systemAdmin/integrationLogs/:integrationLogId
 * @accessor api.functional.healthcarePlatform.systemAdmin.integrationLogs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the integration log record to retrieve. */
    integrationLogId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformIntegrationLog;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/systemAdmin/integrationLogs/:integrationLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/integrationLogs/${encodeURIComponent(props.integrationLogId ?? "null")}`;
  export const random = (): IHealthcarePlatformIntegrationLog =>
    typia.random<IHealthcarePlatformIntegrationLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("integrationLogId")(() =>
        typia.assert(props.integrationLogId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
