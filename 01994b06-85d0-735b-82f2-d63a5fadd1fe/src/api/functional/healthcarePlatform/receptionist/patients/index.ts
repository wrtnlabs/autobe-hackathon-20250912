import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformPatient } from "../../../../structures/IHealthcarePlatformPatient";

/**
 * Retrieve a specific patient profile by patientId from
 * healthcare_platform_patients.
 *
 * Retrieve a single patient user profile by specifying the unique patientId.
 * This operation is used to display or process detailed patient information as
 * stored in the healthcare_platform_patients table, including core attributes
 * (email, full_name, date_of_birth, phone, created_at, updated_at, and
 * deleted_at fields). Only active (not soft-deleted) records are returned, and
 * the operation enforces strict tenant data isolation—users can only access
 * patients within their organization context.
 *
 * Security and audit rules require that only roles with appropriate permission,
 * such as medicalDoctor, nurse, organizationAdmin, receptionist, and the
 * patient themselves, can access the profile, with all access events logged for
 * compliance and traceability. Attempts to view patient profiles outside scope
 * or organization boundaries are denied and audited per policy.
 *
 * This GET endpoint is intended for use alongside related API endpoints that
 * reference patients, such as listing their appointments or billing status. It
 * handles errors for not found, unauthorized, or deleted records and surfaces
 * audit trail entries as required for regulatory compliance.
 *
 * @param props.connection
 * @param props.patientId Unique identifier of the target patient user.
 * @path /healthcarePlatform/receptionist/patients/:patientId
 * @accessor api.functional.healthcarePlatform.receptionist.patients.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target patient user. */
    patientId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformPatient;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/receptionist/patients/:patientId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/receptionist/patients/${encodeURIComponent(props.patientId ?? "null")}`;
  export const random = (): IHealthcarePlatformPatient =>
    typia.random<IHealthcarePlatformPatient>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientId")(() => typia.assert(props.patientId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing patient user profile in healthcare_platform_patients.
 *
 * Update the patient user profile for an existing patient in the system by
 * specifying their patientId and providing the updated fields. The operation is
 * anchored on the healthcare_platform_patients table and governs changes to
 * core profile information, including email, full_name, date_of_birth, and
 * phone. Update attempts are controlled by role-based access and input
 * validation (including uniqueness for email), and only permitted for
 * authorized users or the patient themselves as dictated by the organization’s
 * compliance and audit policies.
 *
 * The endpoint logs all changes for security, audit trail, and reportability
 * purposes. It supports integrations with dependent records such as patient
 * appointments and billing, ensuring changes propagate according to business
 * requirements. Error scenarios for invalid patientId, data conflicts, or
 * unauthorized modification requests are handled with appropriate responses,
 * ensuring compliance at every update event.
 *
 * @param props.connection
 * @param props.patientId Unique identifier of the patient to update.
 * @param props.body Fields to update for the patient profile as per
 *   healthcare_platform_patients schema.
 * @path /healthcarePlatform/receptionist/patients/:patientId
 * @accessor api.functional.healthcarePlatform.receptionist.patients.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the patient to update. */
    patientId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the patient profile as per
     * healthcare_platform_patients schema.
     */
    body: IHealthcarePlatformPatient.IUpdate;
  };
  export type Body = IHealthcarePlatformPatient.IUpdate;
  export type Response = IHealthcarePlatformPatient;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/receptionist/patients/:patientId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/receptionist/patients/${encodeURIComponent(props.patientId ?? "null")}`;
  export const random = (): IHealthcarePlatformPatient =>
    typia.random<IHealthcarePlatformPatient>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientId")(() => typia.assert(props.patientId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Register a new patient user profile in healthcare_platform_patients.
 *
 * Register a new patient user profile in the platform, capturing required
 * demographic and identity information as defined in the
 * healthcare_platform_patients table. Required fields include email, full name,
 * and date of birth, with phone as optional. The POST operation validates input
 * for uniqueness (especially email), regulatory standards, and readiness for
 * audit trail logging. It integrates with downstream patient workflows,
 * including appointments, billing, and consent management, as well as security
 * and notification preferences.
 *
 * Role-based access ensures that both staff (such as receptionists and
 * organization admins) and patients (via self-service registration) can create
 * accounts as permitted by business policy. Error handling covers duplicate
 * email, invalid input, and compliance failures, with all creations subject to
 * audit and legal traceability. The response returns the created patient
 * profile and links it to the organization's patient record domain for further
 * operations and workflow integration.
 *
 * @param props.connection
 * @param props.body Patient registration/provisioning information according to
 *   healthcare_platform_patients schema.
 * @path /healthcarePlatform/receptionist/patients
 * @accessor api.functional.healthcarePlatform.receptionist.patients.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Patient registration/provisioning information according to
     * healthcare_platform_patients schema.
     */
    body: IHealthcarePlatformPatient.ICreate;
  };
  export type Body = IHealthcarePlatformPatient.ICreate;
  export type Response = IHealthcarePlatformPatient;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/receptionist/patients",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/receptionist/patients";
  export const random = (): IHealthcarePlatformPatient =>
    typia.random<IHealthcarePlatformPatient>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
