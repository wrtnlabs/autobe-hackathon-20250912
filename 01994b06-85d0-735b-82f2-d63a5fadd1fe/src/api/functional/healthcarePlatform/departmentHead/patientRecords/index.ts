import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformPatientRecord } from "../../../../structures/IHealthcarePlatformPatientRecord";
import { IPageIHealthcarePlatformPatientRecord } from "../../../../structures/IPageIHealthcarePlatformPatientRecord";
export * as encounters from "./encounters/index";
export * as recordAmendments from "./recordAmendments/index";

/**
 * Search and paginate patient records with advanced filters
 * (healthcare_platform_patient_records).
 *
 * This operation retrieves a paginated, filtered list of patient records housed
 * within the healthcarePlatform system. It is designed for use by authorized
 * roles such as clinicians, administrative staff, and compliance officers who
 * require efficient access to longitudinal patient data across organizational
 * and departmental boundaries.
 *
 * The endpoint supports advanced search criteria, including but not limited to
 * partial name matches, date-of-birth ranges, demographic fields (handled as
 * JSON), status queries (active, inactive, deceased, transferred), and optional
 * filtering by department or organization. Sorting and pagination parameters
 * are implemented to support scalable, real-time data entry and clinical review
 * workflows.
 *
 * All search requests are logged with user and organization context for
 * compliance and auditability, ensuring that access to PHI aligns with
 * organizational policies. Privacy flags and consent controls are enforced, and
 * unauthorized users are denied access with appropriate error messaging. Any
 * inclusion of soft-deleted or archived records requires explicit compliance
 * override, and these cases are fully auditable.
 *
 * Related operations include detailed patient record retrieval (GET
 * /patientRecords/{id}), patient creation, and clinical encounter listing.
 * Error handling includes detailed feedback on failed queries, invalid filters,
 * or permission denials, following the organization's regulatory requirements.
 *
 * @param props.connection
 * @param props.body Search criteria, filter, and pagination controls for
 *   advanced patient record queries.
 * @path /healthcarePlatform/departmentHead/patientRecords
 * @accessor api.functional.healthcarePlatform.departmentHead.patientRecords.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filter, and pagination controls for advanced patient
     * record queries.
     */
    body: IHealthcarePlatformPatientRecord.IRequest;
  };
  export type Body = IHealthcarePlatformPatientRecord.IRequest;
  export type Response = IPageIHealthcarePlatformPatientRecord.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/departmentHead/patientRecords",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/departmentHead/patientRecords";
  export const random = (): IPageIHealthcarePlatformPatientRecord.ISummary =>
    typia.random<IPageIHealthcarePlatformPatientRecord.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific patient record by ID from
 * healthcare_platform_patient_records database table.
 *
 * This endpoint allows retrieval of a detailed patient record profile by
 * patientRecordId, as defined in the 'healthcare_platform_patient_records'
 * table. The operation returns all main columns: organization and department
 * assignment, patient user reference, external patient number if set, legal
 * full name, date of birth, gender, record status, extensible demographics
 * JSON, timestamps for creation and update, and the current soft delete
 * status.
 *
 * Access to this operation must be tightly controlled and audited due to the
 * presence of protected health information (PHI). Only authenticated and
 * authorized roles, such as clinical staff (doctor, nurse), department heads,
 * and admins, can invoke this endpoint with all access logged for HIPAA
 * compliance.
 *
 * Business logic includes: 1) Ensuring that only users within the same
 * organization or with explicit delegated rights can access the record; 2)
 * Checking the 'deleted_at' soft delete flagâ€”records with this set are excluded
 * unless under audit special circumstances; 3) Supporting regulatory workflows,
 * audit requirements, and patient self-access consent rules as described in
 * business specifications. Errors are handled by returning not found for
 * non-existent or ineligible records, and special messaging when access is
 * denied due to consent or assignment boundaries.
 *
 * @param props.connection
 * @param props.patientRecordId Unique identifier of the patient record to
 *   retrieve.
 * @path /healthcarePlatform/departmentHead/patientRecords/:patientRecordId
 * @accessor api.functional.healthcarePlatform.departmentHead.patientRecords.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the patient record to retrieve. */
    patientRecordId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformPatientRecord;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/departmentHead/patientRecords/:patientRecordId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/departmentHead/patientRecords/${encodeURIComponent(props.patientRecordId ?? "null")}`;
  export const random = (): IHealthcarePlatformPatientRecord =>
    typia.random<IHealthcarePlatformPatientRecord>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientRecordId")(() =>
        typia.assert(props.patientRecordId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing patient record identified by patientRecordId in the main
 * patient records schema.
 *
 * This endpoint enables authorized users to update the properties of a given
 * patient record entry identified by patientRecordId. Allowed modification
 * fields, as defined in the patient records Prisma schema, include legal name,
 * demographics JSON, department, gender, status, and other non-immutable fields
 * (excluding organization and primary user references, which are not generally
 * modifiable post-creation).
 *
 * Update attempts are tightly controlled: only clinical staff with proper
 * permissions, organization admins, or department heads may update records. The
 * operation validates input, checks for conflicting soft delete status
 * (deleted_at), and ensures consistency with regulatory requirements. All
 * modifications are recorded in the audit trail, and significant changes may
 * trigger versioning and amendment flows for compliance, depending on
 * organizational policy and legal requirements.
 *
 * Business logic must also check for legal holds, privacy flags, and explicit
 * patient consent requirements before applying updates. Rejected changes due to
 * regulatory or consent restrictions are handled with descriptive errors, and
 * client logic may prompt for required approvals.
 *
 * @param props.connection
 * @param props.patientRecordId Unique identifier for the patient record to
 *   update.
 * @param props.body Fields required to update a patient record, respecting
 *   business validation rules and data isolation.
 * @path /healthcarePlatform/departmentHead/patientRecords/:patientRecordId
 * @accessor api.functional.healthcarePlatform.departmentHead.patientRecords.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the patient record to update. */
    patientRecordId: string & tags.Format<"uuid">;

    /**
     * Fields required to update a patient record, respecting business
     * validation rules and data isolation.
     */
    body: IHealthcarePlatformPatientRecord.IUpdate;
  };
  export type Body = IHealthcarePlatformPatientRecord.IUpdate;
  export type Response = IHealthcarePlatformPatientRecord;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/departmentHead/patientRecords/:patientRecordId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/departmentHead/patientRecords/${encodeURIComponent(props.patientRecordId ?? "null")}`;
  export const random = (): IHealthcarePlatformPatientRecord =>
    typia.random<IHealthcarePlatformPatientRecord>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientRecordId")(() =>
        typia.assert(props.patientRecordId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
