import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformOrganizationAdmin } from "../../../structures/IHealthcarePlatformOrganizationAdmin";

/**
 * Register a new healthcare platform organization administrator. Entry in
 * 'healthcare_platform_organizationadmins', onboarding and JWT issuance. .
 *
 * This API operation allows for the creation and onboarding of new healthcare
 * platform organization administrator accounts based on the
 * 'healthcare_platform_organizationadmins' table. It supports account
 * self-registration or admin-assisted onboarding by accepting required fields
 * such as email, full_name, and optional phone number. All email addresses must
 * be unique and are verified in real-time against the database, which blocks
 * duplicate organizations or re-use of prior admin accounts (soft-deleted
 * status is checked).
 *
 * Upon account creation, this operation sets up MFA or SSO workflows as
 * required by tenant policy, and generates secure credentials for the
 * administrator. All registration attempts are audited in the
 * 'healthcare_platform_audit_logs' table for compliance, including remote IP,
 * user agent, and the organization context based on input mapping or downstream
 * configuration.
 *
 * The organizationAdmin's assignment to an organization is handled by
 * downstream workflows (see assignment APIs), but the administrator record
 * itself is provisioned and authorized here. If organization-specific
 * configuration (timezone, language) exists, the system will use it for
 * notifications and display settings.
 *
 * Security: Open to external users for onboarding but implements brute-force
 * and duplicate-prevention controls as mandated by audit rules. Triggers
 * welcome notification and logs full onboarding event. Strict audit and MFA
 * handling ensure compliance with HIPAA and SOC 2.
 *
 * Related Operations: Organization administrator login, session refresh,
 * account recovery, and downstream assignment endpoints must all reference the
 * output of this operation. Token issuance follows JWT standards, and
 * onboarding-related errors are tracked for compliance review.
 *
 * Operating on: 'healthcare_platform_organizationadmins' table and creating
 * related audit records.
 *
 * @param props.connection
 * @param props.body Payload to register as an organization administrator
 *   (email, full_name, optional phone).
 * @setHeader token.access Authorization
 *
 * @path /auth/organizationAdmin/join
 * @accessor api.functional.auth.organizationAdmin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Payload to register as an organization administrator (email,
     * full_name, optional phone).
     */
    body: IHealthcarePlatformOrganizationAdmin.IJoin;
  };
  export type Body = IHealthcarePlatformOrganizationAdmin.IJoin;
  export type Response = IHealthcarePlatformOrganizationAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/organizationAdmin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/organizationAdmin/join";
  export const random = (): IHealthcarePlatformOrganizationAdmin.IAuthorized =>
    typia.random<IHealthcarePlatformOrganizationAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate organization administrator and issue access tokens. Entry and
 * validation for
 * 'healthcare_platform_organizationadmins','healthcare_platform_user_authentications'.
 *
 * This API operation authenticates an existing organization administrator by
 * accepting an email and password. It references the
 * 'healthcare_platform_organizationadmins' and
 * 'healthcare_platform_user_authentications' tables to find the admin user,
 * check their password (password_hash), and confirm account is active (not
 * soft-deleted).
 *
 * On successful authentication, this endpoint issues JWT access and refresh
 * tokens. The session and login events are tracked via
 * 'healthcare_platform_auth_sessions' and audited for compliance. Account
 * lockout and brute-force prevention are enforced based on failed attempts;
 * events are logged in the audit log table. MFA or SSO workflows are executed
 * if required by organizational policy and configuration.
 *
 * Security: Open to external login, but implements strong validation and audit
 * logging for all authentication attempts. Blocked and suspended accounts
 * trigger compliance and admin notifications.
 *
 * Related: Organization administrator registration, token/session refresh,
 * account recovery. All subsequent role-based admin actions rely on valid
 * tokens issued here. MFA and SSO extensions depend on business and
 * organization policy settings.
 *
 * Database tables: 'healthcare_platform_organizationadmins',
 * 'healthcare_platform_user_authentications',
 * 'healthcare_platform_auth_sessions', and 'healthcare_platform_audit_logs'.
 *
 * @param props.connection
 * @param props.body Credentials for organization admin login (email, password).
 * @setHeader token.access Authorization
 *
 * @path /auth/organizationAdmin/login
 * @accessor api.functional.auth.organizationAdmin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Credentials for organization admin login (email, password). */
    body: IHealthcarePlatformOrganizationAdmin.ILogin;
  };
  export type Body = IHealthcarePlatformOrganizationAdmin.ILogin;
  export type Response = IHealthcarePlatformOrganizationAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/organizationAdmin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/organizationAdmin/login";
  export const random = (): IHealthcarePlatformOrganizationAdmin.IAuthorized =>
    typia.random<IHealthcarePlatformOrganizationAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT access and refresh tokens for organization admin session.
 * Controls session timeout and compliance constraints.
 *
 * This operation refreshes authentication tokens (JWT/refresh) for an existing
 * organization administrator session. It requires a valid, unexpired refresh
 * token as implemented by the 'healthcare_platform_auth_sessions' table and
 * verifies that the associated 'healthcare_platform_organizationadmins' record
 * remains active and non-deleted.
 *
 * The refresh process checks session validity (not expired, not revoked, not
 * soft-deleted), updates audit logs with remote device/IP, and enforces logout
 * on policy violation or account change. Full audit details are stored in the
 * 'healthcare_platform_audit_logs' table as required by HIPAA and SOC 2.
 *
 * Security: Restricted to clients with a valid refresh token. Token/session
 * rotation, forced expiration, and compliance lockout are triggered on
 * violations or account updates.
 *
 * Related: Organization admin login, onboarding, and admin session revocation.
 * All subsequent admin API calls depend on refreshed tokens. Errors and session
 * status changes are captured in audit streams for regulatory reporting.
 *
 * Database reference: 'healthcare_platform_auth_sessions',
 * 'healthcare_platform_organizationadmins', 'healthcare_platform_audit_logs'.
 *
 * @param props.connection
 * @param props.body Payload containing the refresh token for session renewal.
 * @setHeader token.access Authorization
 *
 * @path /auth/organizationAdmin/refresh
 * @accessor api.functional.auth.organizationAdmin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Payload containing the refresh token for session renewal. */
    body: IHealthcarePlatformOrganizationAdmin.IRefresh;
  };
  export type Body = IHealthcarePlatformOrganizationAdmin.IRefresh;
  export type Response = IHealthcarePlatformOrganizationAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/organizationAdmin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/organizationAdmin/refresh";
  export const random = (): IHealthcarePlatformOrganizationAdmin.IAuthorized =>
    typia.random<IHealthcarePlatformOrganizationAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
