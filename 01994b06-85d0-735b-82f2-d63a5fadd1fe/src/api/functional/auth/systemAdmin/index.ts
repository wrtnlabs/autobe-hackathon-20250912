import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformSystemAdmin } from "../../../structures/IHealthcarePlatformSystemAdmin";

/**
 * Register a system administrator user (healthcare_platform_systemadmins table)
 * and provision authentication credentials.
 *
 * This operation supports the registration (join) flow for superuser
 * administrators on the healthcarePlatform using the
 * healthcare_platform_systemadmins table. When a new superuser registers, the
 * operation creates a healthcare_platform_systemadmins record with the required
 * profile fields, links to a healthcare_platform_user_authentications record,
 * and provisions an initial JWT session with centralized audit logging in
 * healthcare_platform_audit_logs. Strict audit controls, unique email
 * enforcement, and password best practices apply. The operation never exposes
 * password hashes or internal authentication properties and is only available
 * for platform-level onboarding. Only organizations listed as permissible for
 * admin registration are supported, and registration attempts are fully traced
 * for compliance. Related operations: /auth/systemAdmin/login,
 * /auth/systemAdmin/refresh (for session and credential management). Resource:
 * healthcare_platform_systemadmins table.
 *
 * @param props.connection
 * @param props.body Superuser admin registration data (including email,
 *   full_name, phone, password or SSO info) for platform onboarding. Use
 *   typeName: IHealthcarePlatformSystemAdmin.IJoin for credential and profile
 *   details.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/join
 * @accessor api.functional.auth.systemAdmin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Superuser admin registration data (including email, full_name, phone,
     * password or SSO info) for platform onboarding. Use typeName:
     * IHealthcarePlatformSystemAdmin.IJoin for credential and profile
     * details.
     */
    body: IHealthcarePlatformSystemAdmin.IJoin;
  };
  export type Body = IHealthcarePlatformSystemAdmin.IJoin;
  export type Response = IHealthcarePlatformSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/join";
  export const random = (): IHealthcarePlatformSystemAdmin.IAuthorized =>
    typia.random<IHealthcarePlatformSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Login for system administrators (authenticate against
 * healthcare_platform_systemadmins and manage JWT session).
 *
 * Authenticate (login) a platform system administrator via local credentials or
 * federated SSO (fields present in healthcare_platform_user_authentications).
 * The operation verifies credentials, issues JWT tokens, provisions a new
 * session using healthcare_platform_auth_sessions, and triggers audit-compliant
 * logging in healthcare_platform_audit_logs and security_incidents. On
 * authentication failure, the event is logged with context and may trigger rate
 * limiting or lockdown based on security policy. Never exposes password hashes;
 * only operates on active, non-deleted healthcare_platform_systemadmins.
 * Related operations include /auth/systemAdmin/join (registration) and
 * /auth/systemAdmin/refresh (token/session renewal). Only system-level
 * administrator accounts are supported in this operation.
 *
 * @param props.connection
 * @param props.body Login credentials (email/password or SSO provider/key) for
 *   platform system administrator. Use typeName:
 *   IHealthcarePlatformSystemAdmin.ILogin.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/login
 * @accessor api.functional.auth.systemAdmin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Login credentials (email/password or SSO provider/key) for platform
     * system administrator. Use typeName:
     * IHealthcarePlatformSystemAdmin.ILogin.
     */
    body: IHealthcarePlatformSystemAdmin.ILogin;
  };
  export type Body = IHealthcarePlatformSystemAdmin.ILogin;
  export type Response = IHealthcarePlatformSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/login";
  export const random = (): IHealthcarePlatformSystemAdmin.IAuthorized =>
    typia.random<IHealthcarePlatformSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh system administrator session/token
 * (healthcare_platform_auth_sessions).
 *
 * Refresh an active JWT access/refresh token session for system administrator
 * using healthcare_platform_auth_sessions. The operation validates the provided
 * refresh token against recorded session, issues new access/refresh tokens for
 * continued session, and logs event in healthcare_platform_audit_logs. Session
 * revocation, security monitoring, and failed/expired refresh attempts are
 * managed per incident logging and system security policy. Never exposes
 * password hash or secret session details. Only active, non-revoked sessions
 * linked to healthcare_platform_systemadmins are valid for this operation.
 *
 * @param props.connection
 * @param props.body Refresh token operation for platform system administrator
 *   account. Provide valid refresh token matching
 *   healthcare_platform_auth_sessions. Use typeName:
 *   IHealthcarePlatformSystemAdmin.IRefresh.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/refresh
 * @accessor api.functional.auth.systemAdmin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token operation for platform system administrator account.
     * Provide valid refresh token matching
     * healthcare_platform_auth_sessions. Use typeName:
     * IHealthcarePlatformSystemAdmin.IRefresh.
     */
    body: IHealthcarePlatformSystemAdmin.IRefresh;
  };
  export type Body = IHealthcarePlatformSystemAdmin.IRefresh;
  export type Response = IHealthcarePlatformSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/refresh";
  export const random = (): IHealthcarePlatformSystemAdmin.IAuthorized =>
    typia.random<IHealthcarePlatformSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
