import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IStoryfieldAiEnvSetting } from "../../../../structures/IStoryfieldAiEnvSetting";
import { IPageIStoryfieldAiEnvSetting } from "../../../../structures/IPageIStoryfieldAiEnvSetting";

/**
 * Create a new environment setting record (storyfield_ai_env_settings).
 *
 * This operation creates a new entry in the storyfield_ai_env_settings table,
 * representing a configuration setting for a specific runtime environment
 * (development, staging, production, or local). The request requires specifying
 * the environment, key, value, the identity of the admin making the change, and
 * the business reason for the new or changed value.
 *
 * Environment settings are critical for operational correctness, as they govern
 * external API keys, feature toggles, and infrastructure URLs. Proper use of
 * this endpoint supports secure, audited deployments and enables rapid
 * restoration/rollback for incident response.
 *
 * Only authorized systemAdmin roles may call this operation. Audit fields,
 * including who created the setting and their change justification, are
 * mandatory. The response provides the complete resulting environment setting
 * object, confirming correct persistence and registration in the configuration
 * audit log.
 *
 * Note: Sensitive data in env_value should follow masking policies in the
 * system's response payloads, and not all values are suitable for disclosure to
 * UI clients.
 *
 * @param props.connection
 * @param props.body The full details for the new environment setting to create,
 *   including environment name, key, value, administrating user, and reason for
 *   the change.
 * @path /storyfieldAi/systemAdmin/envSettings
 * @accessor api.functional.storyfieldAi.systemAdmin.envSettings.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * The full details for the new environment setting to create, including
     * environment name, key, value, administrating user, and reason for the
     * change.
     */
    body: IStoryfieldAiEnvSetting.ICreate;
  };
  export type Body = IStoryfieldAiEnvSetting.ICreate;
  export type Response = IStoryfieldAiEnvSetting;

  export const METADATA = {
    method: "POST",
    path: "/storyfieldAi/systemAdmin/envSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/storyfieldAi/systemAdmin/envSettings";
  export const random = (): IStoryfieldAiEnvSetting =>
    typia.random<IStoryfieldAiEnvSetting>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve environment settings with filtering and pagination
 * (storyfield_ai_env_settings table).
 *
 * This API endpoint retrieves a filtered and paginated list of environment
 * settings from the 'storyfield_ai_env_settings' table. Environment settings
 * store key=value pairs representing sensitive or operational configuration
 * items, change control information, and change audit traceability by
 * environment context.
 *
 * System administrators use this endpoint to manage configuration drift, detect
 * unauthorized changes, and perform audit reviews. Supported filters include
 * environment name, key name, and changed_by, and results are paginated for
 * efficient list navigation. Business rules require that only systemAdmin users
 * may access or enumerate environment settings, to avoid accidental exposure of
 * sensitive material.
 *
 * Input includes filter criteria, sort order, and pagination parameters (e.g.,
 * page, page size, sort field/direction). The response returns a paginated
 * dataset of environment setting records, with all relevant audit fields and
 * masking of sensitive values as required for compliance.
 *
 * Errors are returned for invalid pagination parameters, insufficient
 * privileges, or system errors. This operation is typically paired with
 * administrative creation or update endpoints for full lifecycle environment
 * and configuration management.
 *
 * @param props.connection
 * @param props.body Request criteria for searching/filtering environment
 *   settings including pagination.
 * @path /storyfieldAi/systemAdmin/envSettings
 * @accessor api.functional.storyfieldAi.systemAdmin.envSettings.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Request criteria for searching/filtering environment settings
     * including pagination.
     */
    body: IStoryfieldAiEnvSetting.IRequest;
  };
  export type Body = IStoryfieldAiEnvSetting.IRequest;
  export type Response = IPageIStoryfieldAiEnvSetting;

  export const METADATA = {
    method: "PATCH",
    path: "/storyfieldAi/systemAdmin/envSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/storyfieldAi/systemAdmin/envSettings";
  export const random = (): IPageIStoryfieldAiEnvSetting =>
    typia.random<IPageIStoryfieldAiEnvSetting>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific environment setting by its unique ID
 * (storyfield_ai_env_settings).
 *
 * This operation allows retrieval of a single environment setting by specifying
 * its unique identifier. It queries the storyfield_ai_env_settings table, which
 * holds per-environment configuration key-value pairs and change metadata.
 *
 * This endpoint is intended for use by system administrators when reviewing or
 * troubleshooting deployments, auditing configuration changes, and diagnosing
 * operational issues. The permission is strictâ€”only authorized systemAdmin
 * actors can query these records due to the sensitivity of environment
 * configuration data.
 *
 * Returned information includes environment key, value (masked if sensitive),
 * the target environment (e.g., production, staging), the user/admin who last
 * changed the value, the reason for the change, and timestamps for creation and
 * updates. This level of access helps ensure traceability of system
 * configuration changes and supports incident investigations or rollbacks when
 * needed.
 *
 * Careful access control must be enforced, and audit logs should record access
 * to this endpoint for compliance purposes.
 *
 * @param props.connection
 * @param props.envSettingId Unique identifier of the environment setting to
 *   retrieve.
 * @path /storyfieldAi/systemAdmin/envSettings/:envSettingId
 * @accessor api.functional.storyfieldAi.systemAdmin.envSettings.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the environment setting to retrieve. */
    envSettingId: string & tags.Format<"uuid">;
  };
  export type Response = IStoryfieldAiEnvSetting;

  export const METADATA = {
    method: "GET",
    path: "/storyfieldAi/systemAdmin/envSettings/:envSettingId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/envSettings/${encodeURIComponent(props.envSettingId ?? "null")}`;
  export const random = (): IStoryfieldAiEnvSetting =>
    typia.random<IStoryfieldAiEnvSetting>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("envSettingId")(() => typia.assert(props.envSettingId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing environment setting by its unique ID
 * (storyfield_ai_env_settings).
 *
 * This operation modifies a specific environment setting record given its
 * unique envSettingId, allowing system administrators to change configuration
 * keys or values, or to adjust environment assignments (e.g., switching a
 * feature toggle from 'off' to 'on' for production).
 *
 * Each update requires complete payload details including the new key, value,
 * which administrator is making the change, and a supporting business reason
 * for the modification. This supports policy and regulatory compliance by
 * ensuring an immutable audit trail of all config/value changes, who performed
 * them, and why.
 *
 * The endpoint strictly limits access to systemAdmin role, reflecting the high
 * business risk of improper environment configuration management. Responses
 * include the fully updated env setting object for confirmation. All update
 * actions should also be logged for potential security or incident review.
 *
 * @param props.connection
 * @param props.envSettingId Unique identifier of the environment setting to
 *   update.
 * @param props.body Full update payload for the target environment setting,
 *   including changed key, value, administrator, and audit fields.
 * @path /storyfieldAi/systemAdmin/envSettings/:envSettingId
 * @accessor api.functional.storyfieldAi.systemAdmin.envSettings.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the environment setting to update. */
    envSettingId: string & tags.Format<"uuid">;

    /**
     * Full update payload for the target environment setting, including
     * changed key, value, administrator, and audit fields.
     */
    body: IStoryfieldAiEnvSetting.IUpdate;
  };
  export type Body = IStoryfieldAiEnvSetting.IUpdate;
  export type Response = IStoryfieldAiEnvSetting;

  export const METADATA = {
    method: "PUT",
    path: "/storyfieldAi/systemAdmin/envSettings/:envSettingId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/storyfieldAi/systemAdmin/envSettings/${encodeURIComponent(props.envSettingId ?? "null")}`;
  export const random = (): IStoryfieldAiEnvSetting =>
    typia.random<IStoryfieldAiEnvSetting>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("envSettingId")(() => typia.assert(props.envSettingId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently remove a specific environment setting by unique ID
 * (storyfield_ai_env_settings).
 *
 * This operation irreversibly deletes an environment setting from the
 * configuration registry using its unique envSettingId. Removal is intended
 * only for settings that are no longer required, are unsafe to retain (such as
 * expired API keys), or were added in error. Unlike soft deletes, this
 * operation physically removes the record, making restoration impossible once
 * completed.
 *
 * Strict access is enforced: only users with systemAdmin role may invoke this
 * endpoint, and every execution must be auditable. Deletion of critical
 * environment variables should be accompanied by additional policy review to
 * prevent accidental or malicious service impact.
 *
 * Audit logs must record the administrator, time, and contextual justification
 * for each action, ensuring support for post-incident analysis and compliance
 * reviews. This operation does not return a response body on success.
 *
 * @param props.connection
 * @param props.envSettingId Unique identifier of the environment setting to
 *   permanently remove.
 * @path /storyfieldAi/systemAdmin/envSettings/:envSettingId
 * @accessor api.functional.storyfieldAi.systemAdmin.envSettings.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the environment setting to permanently remove. */
    envSettingId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/storyfieldAi/systemAdmin/envSettings/:envSettingId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/envSettings/${encodeURIComponent(props.envSettingId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("envSettingId")(() => typia.assert(props.envSettingId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
