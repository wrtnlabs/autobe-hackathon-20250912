import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IStoryfieldAiExternalApiFailure } from "../../../../structures/IStoryfieldAiExternalApiFailure";
import { IPageIStoryfieldAiExternalApiFailure } from "../../../../structures/IPageIStoryfieldAiExternalApiFailure";

/**
 * Search and retrieve paginated list of external API failure records for admin
 * review (storyfield_ai_external_api_failures table).
 *
 * This operation allows system administrators to perform advanced filtering and
 * retrieval of all integration failure and external API error records. These
 * records provide insight into system reliability, business process health, and
 * root-cause error attribution for events such as third-party failures, quota
 * overruns, network timeouts, or misconfigurations.
 *
 * Access to this endpoint is restricted to systemAdmin users given the
 * sensitive nature of error logs and the potential inclusion of PII or
 * technical details valuable for security monitoring. The response delivers a
 * summary view for each record, with options to expand details for incident
 * triage or forensics.
 *
 * Business logic includes robust filteringâ€”by API type, error code, endpoint,
 * status, affected user, or date range, and supports ordering by newest, error
 * severity, or frequency. This endpoint forms the basis for error dashboards,
 * incident response workflows, and SLA audits. The underlying Prisma table's
 * unique constraints and indices (api_type, created_at, error_code, message)
 * ensure highly efficient query handling. Related endpoints provide detail
 * retrieval and contextual integration log review.
 *
 * @param props.connection
 * @param props.body List/search criteria for external API failure event
 *   filtering and pagination.
 * @path /storyfieldAi/systemAdmin/externalApiFailures
 * @accessor api.functional.storyfieldAi.systemAdmin.externalApiFailures.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * List/search criteria for external API failure event filtering and
     * pagination.
     */
    body: IStoryfieldAiExternalApiFailure.IRequest;
  };
  export type Body = IStoryfieldAiExternalApiFailure.IRequest;
  export type Response = IPageIStoryfieldAiExternalApiFailure.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/storyfieldAi/systemAdmin/externalApiFailures",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/storyfieldAi/systemAdmin/externalApiFailures";
  export const random = (): IPageIStoryfieldAiExternalApiFailure.ISummary =>
    typia.random<IPageIStoryfieldAiExternalApiFailure.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detail of a specific external API failure event from
 * storyfield_ai_external_api_failures.
 *
 * This endpoint returns all available metadata and error context for a given
 * API failure or integration error event, as tracked in the
 * storyfield_ai_external_api_failures table. Records include the API type
 * (e.g., openai, tts), endpoint, HTTP method, error_code, error_message,
 * request_payload, response_payload, retry_count, timestamps, and foreign keys
 * relating the event to a user or story where available.
 *
 * Only users with systemAdmin privileges may access this method, given the
 * inclusion of sensitive operational and potentially personal data. Typical use
 * cases include postmortem investigation, troubleshooting, compliance analysis,
 * and incident remediation workflows.
 *
 * Validation ensures that the provided externalApiFailureId matches an existing
 * failure event. Attempts to access a non-existent, deleted, or restricted
 * event will result in a clear authorization or not-found error. Other related
 * endpoints should be referenced to cross-analyze API failures in context of
 * user sessions and integration system logs.
 *
 * @param props.connection
 * @param props.externalApiFailureId Unique identifier (UUID) for the external
 *   API failure event to retrieve
 * @path /storyfieldAi/systemAdmin/externalApiFailures/:externalApiFailureId
 * @accessor api.functional.storyfieldAi.systemAdmin.externalApiFailures.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier (UUID) for the external API failure event to
     * retrieve
     */
    externalApiFailureId: string & tags.Format<"uuid">;
  };
  export type Response = IStoryfieldAiExternalApiFailure;

  export const METADATA = {
    method: "GET",
    path: "/storyfieldAi/systemAdmin/externalApiFailures/:externalApiFailureId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/externalApiFailures/${encodeURIComponent(props.externalApiFailureId ?? "null")}`;
  export const random = (): IStoryfieldAiExternalApiFailure =>
    typia.random<IStoryfieldAiExternalApiFailure>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("externalApiFailureId")(() =>
        typia.assert(props.externalApiFailureId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
