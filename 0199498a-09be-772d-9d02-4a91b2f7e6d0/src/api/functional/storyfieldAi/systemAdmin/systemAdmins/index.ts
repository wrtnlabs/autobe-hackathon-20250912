import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IStoryfieldAiSystemAdmin } from "../../../../structures/IStoryfieldAiSystemAdmin";
import { IPageIStoryfieldAiSystemAdmin } from "../../../../structures/IPageIStoryfieldAiSystemAdmin";

/**
 * Search, filter, and paginate system administrator accounts
 * (storyfield_ai_systemadmins table).
 *
 * Use this operation to retrieve a list of registered StoryField AI system
 * administrator accounts with advanced filtering and pagination capabilities.
 * Typical use cases include system admin listing for monitoring, audit, and
 * emergency access management purposes.
 *
 * The endpoint supports rich query options, including searching by email
 * address, actor type, account creation/update dates, and last login timestamp.
 * Pagination and sorting options are provided for efficient navigation of
 * potentially large admin lists. Input validation ensures only authorized
 * actions and parameters are permitted.
 *
 * This endpoint operates on the storyfield_ai_systemadmins entity as defined in
 * the database schema. Role-based authorization ensures that only users with
 * system admin privileges can access the data, thus protecting sensitive
 * operational information. Results include only active and non-soft-deleted
 * admin accounts by default, unless filtering specifies otherwise.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for system
 *   administrator account retrieval.
 * @path /storyfieldAi/systemAdmin/systemAdmins
 * @accessor api.functional.storyfieldAi.systemAdmin.systemAdmins.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, and pagination parameters for system administrator
     * account retrieval.
     */
    body: IStoryfieldAiSystemAdmin.IRequest;
  };
  export type Body = IStoryfieldAiSystemAdmin.IRequest;
  export type Response = IPageIStoryfieldAiSystemAdmin.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/storyfieldAi/systemAdmin/systemAdmins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/storyfieldAi/systemAdmin/systemAdmins";
  export const random = (): IPageIStoryfieldAiSystemAdmin.ISummary =>
    typia.random<IPageIStoryfieldAiSystemAdmin.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch detailed info for a single system administrator
 * (storyfield_ai_systemadmins table) by ID.
 *
 * This operation fetches the full profile and metadata for a specific
 * StoryField AI system administrator account, identified by its systemAdminId
 * parameter (UUID, primary key).
 *
 * Detailed information includes external_admin_id, admin email, role
 * descriptor, audit timestamps (created_at, updated_at, last_login_at),
 * privilege notes, and soft deletion status. This function is essential for
 * auditing, privilege escalation, emergency lockout, or compliance review.
 *
 * The operation enforces strict systemAdmin role authorization. System admin
 * account details are confidential and only accessible to users with elevated
 * system-level privileges. If the account is soft deleted, this is indicated in
 * the response.
 *
 * Related operations include admin list/search (PATCH /systemAdmins), admin
 * account modification (PUT), and admin account removal (DELETE).
 *
 * @param props.connection
 * @param props.systemAdminId Unique identifier for the target system
 *   administrator. Must be a valid UUID string.
 * @path /storyfieldAi/systemAdmin/systemAdmins/:systemAdminId
 * @accessor api.functional.storyfieldAi.systemAdmin.systemAdmins.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier for the target system administrator. Must be a
     * valid UUID string.
     */
    systemAdminId: string & tags.Format<"uuid">;
  };
  export type Response = IStoryfieldAiSystemAdmin;

  export const METADATA = {
    method: "GET",
    path: "/storyfieldAi/systemAdmin/systemAdmins/:systemAdminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/systemAdmins/${encodeURIComponent(props.systemAdminId ?? "null")}`;
  export const random = (): IStoryfieldAiSystemAdmin =>
    typia.random<IStoryfieldAiSystemAdmin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemAdminId")(() => typia.assert(props.systemAdminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update profile or admin notes of a system administrator
 * (storyfield_ai_systemadmins table).
 *
 * Use this operation to update core properties of a StoryField AI system
 * administrator account, identified by the systemAdminId path parameter
 * (UUID).
 *
 * Allowed updates may include admin email, privilege/role descriptor
 * (actor_type), administrative notes, and status toggling (where applicable).
 * Timestamp fields are updated automatically. Strict input validation is
 * enforced according to the database schema. Changes are permanently recorded
 * in audit trails for compliance and forensic review.
 *
 * System-level role authorization is required to modify any administrator
 * account. This operation is typically combined with the GET (detail) and PATCH
 * (list/search) endpoints for lifecycle management of admin users.
 *
 * @param props.connection
 * @param props.systemAdminId Unique identifier of the administrator to update.
 *   Must be a valid UUID string.
 * @param props.body Update fields for the targeted system administrator, such
 *   as email, role, privilege notes.
 * @path /storyfieldAi/systemAdmin/systemAdmins/:systemAdminId
 * @accessor api.functional.storyfieldAi.systemAdmin.systemAdmins.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the administrator to update. Must be a valid
     * UUID string.
     */
    systemAdminId: string & tags.Format<"uuid">;

    /**
     * Update fields for the targeted system administrator, such as email,
     * role, privilege notes.
     */
    body: IStoryfieldAiSystemAdmin.IUpdate;
  };
  export type Body = IStoryfieldAiSystemAdmin.IUpdate;
  export type Response = IStoryfieldAiSystemAdmin;

  export const METADATA = {
    method: "PUT",
    path: "/storyfieldAi/systemAdmin/systemAdmins/:systemAdminId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/storyfieldAi/systemAdmin/systemAdmins/${encodeURIComponent(props.systemAdminId ?? "null")}`;
  export const random = (): IStoryfieldAiSystemAdmin =>
    typia.random<IStoryfieldAiSystemAdmin>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemAdminId")(() => typia.assert(props.systemAdminId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete (deactivate) a system administrator account
 * (storyfield_ai_systemadmins table).
 *
 * This operation marks the specified admin account as deleted by updating the
 * deleted_at field (soft delete) in the storyfield_ai_systemadmins table. The
 * account then becomes inaccessible for login or management actions, although
 * data is retained for audit and compliance.
 *
 * The operation is restricted to users with systemAdmin privileges. No hard
 * deletion is performed, preserving business history and traceability. Attempts
 * to delete a non-existent or already-deleted account return appropriate error
 * messaging.
 *
 * This endpoint is often used together with admin user search, detail, and
 * update operations to support the full lifecycle management of system
 * administrators.
 *
 * @param props.connection
 * @param props.systemAdminId UUID of the system administrator account to
 *   soft-delete.
 * @path /storyfieldAi/systemAdmin/systemAdmins/:systemAdminId
 * @accessor api.functional.storyfieldAi.systemAdmin.systemAdmins.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the system administrator account to soft-delete. */
    systemAdminId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/storyfieldAi/systemAdmin/systemAdmins/:systemAdminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/systemAdmins/${encodeURIComponent(props.systemAdminId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemAdminId")(() => typia.assert(props.systemAdminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
