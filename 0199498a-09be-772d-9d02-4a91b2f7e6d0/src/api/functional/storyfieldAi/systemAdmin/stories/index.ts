import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IStoryfieldAiStory } from "../../../../structures/IStoryfieldAiStory";
import { IPageIStoryfieldAiStory } from "../../../../structures/IPageIStoryfieldAiStory";
export * as pages from "./pages/index";
export * as images from "./images/index";
export * as ttsResults from "./ttsResults/index";

/**
 * Retrieve a paginated and filtered index of AI-generated stories
 * (storyfield_ai_stories table).
 *
 * Fetch a paginated, filterable list of AI-generated fairy tales belonging to
 * authenticated users. This endpoint allows flexible filtering and searching by
 * story title (partial matches), language, owner user ID, creation time range,
 * and soft deletion status. The result set can be sorted by creation or update
 * timestamps.
 *
 * Authentication is required; only authenticated users can retrieve their own
 * stories, while system admins may access all with appropriate search
 * parameters. Pagination supports page size and offset parameters. This
 * endpoint references the storyfield_ai_stories Prisma schema, capturing all
 * user stories, their metadata, and compliance fields including created_at,
 * updated_at, and deleted_at.
 *
 * Sensitive fields such as deleted_at are included in admin results for
 * moderation and GDPR compliance, while regular users only see non-deleted
 * stories they own. Common errors include invalid filters, excessive page
 * sizes, and unauthorized access attempts. Related endpoints are available for
 * retrieving story details, updating, and deleting records.
 *
 * @param props.connection
 * @param props.body Story search, filter, and pagination parameters for index
 *   listings.
 * @path /storyfieldAi/systemAdmin/stories
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Story search, filter, and pagination parameters for index listings. */
    body: IStoryfieldAiStory.IRequest;
  };
  export type Body = IStoryfieldAiStory.IRequest;
  export type Response = IPageIStoryfieldAiStory;

  export const METADATA = {
    method: "PATCH",
    path: "/storyfieldAi/systemAdmin/stories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/storyfieldAi/systemAdmin/stories";
  export const random = (): IPageIStoryfieldAiStory =>
    typia.random<IPageIStoryfieldAiStory>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detail information for a specific story by its ID (storyfield_ai_stories
 * table).
 *
 * Retrieve the full detail view for a single AI-generated story, including
 * title, plot, language, and audit fields. The endpoint uses the story ID as a
 * path parameter, referencing the storyfield_ai_stories table in the Prisma
 * schema. Only the story owner or a system admin may access the story;
 * unauthorized users are denied access.
 *
 * This operation does not directly include child resources like pages or
 * images; use related endpoints to fetch those. Security checks enforce story
 * ownership for authenticated users and full access for system admins for
 * moderation, copyright review, or compliance. Soft-deleted (deleted_at set)
 * stories are only accessible to system admins for audit or recovery
 * operations, not to normal users.
 *
 * Validation covers invalid UUIDs, unauthorized access, and not found errors.
 * This endpoint is tightly coupled to the storyfield_ai_stories table by story
 * ID.
 *
 * @param props.connection
 * @param props.storyId Unique identifier (UUID) for the target story record.
 * @path /storyfieldAi/systemAdmin/stories/:storyId
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) for the target story record. */
    storyId: string & tags.Format<"uuid">;
  };
  export type Response = IStoryfieldAiStory;

  export const METADATA = {
    method: "GET",
    path: "/storyfieldAi/systemAdmin/stories/:storyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}`;
  export const random = (): IStoryfieldAiStory =>
    typia.random<IStoryfieldAiStory>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing story's metadata by ID (storyfield_ai_stories table).
 *
 * Modify the details of an existing AI-generated story by specifying its unique
 * storyId in the path. This endpoint allows updates to fields such as story
 * title, main plot, and language option. It directly uses the
 * storyfield_ai_stories Prisma schema table and enforces ownership rules; only
 * the record owner or a system admin can perform updates.
 *
 * Soft-deleted stories (deleted_at is set) may not be modified and will return
 * an error if update is attempted. The operation is strictly for metadata
 * modification; secondary entities such as pages, images, or TTS results are
 * unaffected by this endpoint. The updated_at audit field is set to the current
 * timestamp on every change.
 *
 * Typical error cases include unauthorized access, not found, invalid input, or
 * business rule violations such as duplicate titles per owner. The endpoint is
 * central to story lifecycle management.
 *
 * @param props.connection
 * @param props.storyId Unique identifier (UUID) of the story to update.
 * @param props.body Update payload including fields to modify in the story
 *   record (e.g., title, main_plot, language).
 * @path /storyfieldAi/systemAdmin/stories/:storyId
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the story to update. */
    storyId: string & tags.Format<"uuid">;

    /**
     * Update payload including fields to modify in the story record (e.g.,
     * title, main_plot, language).
     */
    body: IStoryfieldAiStory.IUpdate;
  };
  export type Body = IStoryfieldAiStory.IUpdate;
  export type Response = IStoryfieldAiStory;

  export const METADATA = {
    method: "PUT",
    path: "/storyfieldAi/systemAdmin/stories/:storyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}`;
  export const random = (): IStoryfieldAiStory =>
    typia.random<IStoryfieldAiStory>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Erase (delete) an AI-generated story from storyfield_ai_stories (hard
 * delete).
 *
 * This endpoint enables authenticated users or system administrators to
 * permanently erase a story from the StoryField AI platform. When invoked, the
 * operation performs a hard delete action, removing the story record from the
 * database rather than setting a soft delete timestamp. This ensures compliance
 * with user requests for complete content erasure or administrative content
 * management.
 *
 * Access control policies require that a standard authenticated user may delete
 * only their own stories, while a system administrator may delete any story.
 * All delete actions are audited for compliance, and attempts to erase stories
 * not belonging to the requesting user are rejected with an authorization
 * error. This procedure aligns with GDPR and company data deletion policies.
 *
 * Upon successful deletion, all associated pages, images, and TTS results are
 * cascaded and subsequently purged according to foreign key constraints. Error
 * handling logic provides clear messages for attempts to delete non-existent or
 * already-deleted stories.
 *
 * @param props.connection
 * @param props.storyId Unique identifier of the target story to be deleted.
 * @path /storyfieldAi/systemAdmin/stories/:storyId
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target story to be deleted. */
    storyId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/storyfieldAi/systemAdmin/stories/:storyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
