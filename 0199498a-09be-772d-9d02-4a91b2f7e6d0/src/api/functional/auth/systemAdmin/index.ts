import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IStoryfieldAiSystemAdmin } from "../../../structures/IStoryfieldAiSystemAdmin";

/**
 * Register new systemAdmin account in storyfield_ai_systemadmins table with JWT
 * token return.
 *
 * Purpose: This API operation enables secure registration of new system
 * administrators, by inserting a new record into the
 * 'storyfield_ai_systemadmins' table using provided external_admin_id and
 * email—uniquely validated at the database layer. This flow ensures that only
 * authorized operator data is accepted, mapped from an existing Spring/JWT
 * backend entity as 'external_admin_id'.
 *
 * Implementation: Upon receiving the payload, the service verifies uniqueness
 * of both external_admin_id and email (ensuring no duplicate admins), sets the
 * actor_type as 'systemAdmin', and persists audit-friendly timestamps
 * (created_at/updated_at). No password is stored or managed by this endpoint;
 * credential control is externalized to JWT integration with the Spring
 * backend. The endpoint issues a JWT access token and logs session creation
 * within 'storyfield_ai_token_sessions'.
 *
 * Business Role: 'systemAdmin' entries facilitate platform-level oversight,
 * such as advanced monitoring, user management, abuse mitigation, and
 * compliance operations. Their accounts are tracked and managed separately from
 * general authenticated users, as reflected in completely distinct schema and
 * workflow.
 *
 * Security: Registration is a highly privileged pathway: it is strictly
 * isolated from all user-registration endpoints, accessible only to authorized
 * operators in deployment, and subject to robust audit logging. Attempts to
 * re-register or clone existing admin accounts are denied based on unique
 * constraints. When an admin is later deactivated, soft deletion (deleted_at)
 * ensures regulatory and business compliance.
 *
 * Related Operations: To fully manage an admin's lifecycle, pair this
 * registration endpoint with the systemAdmin login and token refresh flows.
 * Registration initiates but does not maintain access; further access must be
 * authenticated using the login route. Error states (duplicate, invalid data,
 * etc.) are handled with detailed, non-sensitive feedback, and all events are
 * audit-logged for traceability.
 *
 * @param props.connection
 * @param props.body Registration payload for new systemAdmin, including
 *   external_admin_id (from JWT/Spring system) and email (business-unique),
 *   forming a new admin actor. No password required since external SSO/JWT
 *   handles credentialing.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/join
 * @accessor api.functional.auth.systemAdmin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration payload for new systemAdmin, including external_admin_id
     * (from JWT/Spring system) and email (business-unique), forming a new
     * admin actor. No password required since external SSO/JWT handles
     * credentialing.
     */
    body: IStoryfieldAiSystemAdmin.IJoin;
  };
  export type Body = IStoryfieldAiSystemAdmin.IJoin;
  export type Response = IStoryfieldAiSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/join";
  export const random = (): IStoryfieldAiSystemAdmin.IAuthorized =>
    typia.random<IStoryfieldAiSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate systemAdmin using external_admin_id and issue JWT access token
 * if active (storyfield_ai_systemadmins).
 *
 * Purpose: Enable systemAdmin login by validating external_admin_id (mapped
 * from JWT/Spring) against the 'storyfield_ai_systemadmins' table, ensuring the
 * account is active and not soft-deleted. The operation is exclusive to
 * administrators.
 *
 * Implementation: On login attempt, service checks for existing admin record
 * (uniqueness required for external_admin_id), verifies that 'deleted_at' is
 * null (active), and updates the last_login_at field upon success. New token
 * session logged in 'storyfield_ai_token_sessions', and the login action is
 * recorded in 'storyfield_ai_auth_audit_logs' for compliance.
 *
 * Business Context: Only systemAdmin actors can access this endpoint, which
 * underpins all further privileged system management, logging, or user control
 * workflows. Distinct from user authentication; only binds to system
 * administrator accounts.
 *
 * Security Considerations: Login endpoint is tightly access-controlled. If an
 * account is deactivated (soft-deleted), login is forbidden. Audit logging
 * enables post-event review. Passwords are never handled here—the operation
 * leverages external SSO/JWT infrastructure.
 *
 * Related: Use with join (admin registration) and refresh (token renewal) flows
 * for complete lifecycle. Login events result in JWT issuance and session
 * tracking for active admin oversight. All validation failures or attempts to
 * login with deactivated accounts result in secure error messages, never
 * exposing sensitive system state or account info.
 *
 * @param props.connection
 * @param props.body Admin authentication payload containing external_admin_id
 *   reference and any SSO/JWT mapping needed. Password not used; authentication
 *   is handled externally.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/login
 * @accessor api.functional.auth.systemAdmin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Admin authentication payload containing external_admin_id reference
     * and any SSO/JWT mapping needed. Password not used; authentication is
     * handled externally.
     */
    body: IStoryfieldAiSystemAdmin.ILogin;
  };
  export type Body = IStoryfieldAiSystemAdmin.ILogin;
  export type Response = IStoryfieldAiSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/login";
  export const random = (): IStoryfieldAiSystemAdmin.IAuthorized =>
    typia.random<IStoryfieldAiSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT access token for systemAdmin using valid active refresh
 * token/session (storyfield_ai_token_sessions).
 *
 * Purpose: Allow systemAdmin to refresh their JWT access token by validating a
 * refresh token/session from 'storyfield_ai_token_sessions', so long as the
 * session is not revoked or soft-deleted. Essential for long-lived privileged
 * sessions and secure admin workflows.
 *
 * Implementation: The endpoint expects a refresh token (mapped to token_hash)
 * and ensures that the underlying session is tied to a systemAdmin, is not
 * soft-deleted (deleted_at is null), has not expired, and is not revoked. If
 * all checks pass, a new JWT (with new expiry) is issued and both refreshed_at
 * and last_activity_at fields are updated in the token_sessions entry. The
 * refresh event is also written to 'storyfield_ai_auth_audit_logs' for audit
 * compliance.
 *
 * Business Integration: Used for secure extension of admin sessions, this
 * operation allows administrators to continue oversight, monitoring, and user
 * control actions without re-authenticating, subject to policy limits (e.g.,
 * max session duration). It is mandatory that only systemAdmin-linked sessions
 * are accepted; end-users cannot refresh admin tokens here.
 *
 * Security: Soft deletion, revocation, and expiry are strictly enforced—any
 * failure at these points results in rejection and a detailed, secure error
 * message. Session state changes are fully audit-logged. Refresh tokens must be
 * stored and submitted securely.
 *
 * Related: SystemAdmin authentication lifecycle consists of join, login, and
 * this refresh endpoint. Re-authentication is required when sessions expire,
 * are revoked, or admin is soft-deleted. This endpoint only handles session
 * extension for privileged admin roles and must not be re-used by general users
 * or other roles.
 *
 * @param props.connection
 * @param props.body Payload containing admin's refresh token reference to
 *   validate and renew privilege session. Only sessions mapped to systemAdmin
 *   entries are allowed.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/refresh
 * @accessor api.functional.auth.systemAdmin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Payload containing admin's refresh token reference to validate and
     * renew privilege session. Only sessions mapped to systemAdmin entries
     * are allowed.
     */
    body: IStoryfieldAiSystemAdmin.IRefresh;
  };
  export type Body = IStoryfieldAiSystemAdmin.IRefresh;
  export type Response = IStoryfieldAiSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/refresh";
  export const random = (): IStoryfieldAiSystemAdmin.IAuthorized =>
    typia.random<IStoryfieldAiSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
