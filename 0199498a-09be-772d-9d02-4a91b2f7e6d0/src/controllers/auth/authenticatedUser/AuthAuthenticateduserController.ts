import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthAuthenticatedUserJoin } from "../../../providers/postauthAuthenticatedUserJoin";
import { postauthAuthenticatedUserLogin } from "../../../providers/postauthAuthenticatedUserLogin";
import { postauthAuthenticatedUserRefresh } from "../../../providers/postauthAuthenticatedUserRefresh";

import { IStoryfieldAiAuthenticatedUser } from "../../../api/structures/IStoryfieldAiAuthenticatedUser";

@Controller("/auth/authenticatedUser")
export class AuthAuthenticateduserController {
  /**
   * Register a new StoryField AI authenticatedUser
   * (storyfield_ai_authenticatedusers) given a verified external_user_id and
   * email.
   *
   * Allows a new user, already authenticated and verified externally via
   * Spring, to register as an authenticatedUser in the StoryField AI platform.
   * This operation creates an entry in the storyfield_ai_authenticatedusers
   * table, recording essential onboarding information including a unique
   * external_user_id mapped to the Spring user, a business-unique email, and a
   * fixed actor_type ('authenticatedUser'). Registration is required for all
   * subsequent story generation, TTS, and personalized result retrieval.
   *
   * Unlike traditional local account systems, registration does not involve
   * password collection or credential assignment. All authentication happens
   * prior, managed solely by the Spring backend. This ensures the system never
   * directly handles user passwords or local account secrets, simplifying
   * compliance and reducing exposure.
   *
   * Role-specific integration is guaranteed by actor_type, which is always set
   * to 'authenticatedUser' for this API and validated by downstream business
   * logic. The registration step strictly binds a verified Spring identity to
   * the StoryField AI business context, creating the foundational link needed
   * for resource ownership, TTS association, and audit trails.
   *
   * Security is preserved by requiring the external_user_id obtained from
   * Spring, ensuring that no unauthenticated or spoofed identities can join.
   * There is no local validation of passwords, nor password reset or change
   * supported at registration--token management is fully delegated.
   *
   * This operation is always the first step of the onboarding workflow for
   * authenticatedUser and is not used for guest or admin actors. Related
   * operations include token login (for access), token refresh, and account
   * soft-deletion managed via deleted_at.
   *
   * @param connection
   * @param body Registration payload including external_user_id, unique email,
   *   with actor_type fixed as 'authenticatedUser'.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: IStoryfieldAiAuthenticatedUser.ICreate,
  ): Promise<IStoryfieldAiAuthenticatedUser.IAuthorized> {
    try {
      return await postauthAuthenticatedUserJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate an existing authenticatedUser
   * (storyfield_ai_authenticatedusers), issuing session tokens linked to
   * external_user_id/email only.
   *
   * Allows an externally verified user (mapped from Spring backend; by
   * external_user_id and unique email) to ‘login’ into the StoryField AI
   * platform, resulting in the issuance of a JWT or similar session token. This
   * login is the only way for an authenticatedUser to retrieve active access
   * tokens and establish business session state. The
   * storyfield_ai_authenticatedusers Table ensures mapping of
   * external_user_id/email for all identity proof; no password or local secret
   * is required or accepted.
   *
   * The business logic never sees user passwords or performs any
   * challenge-response—authentication depends entirely on successful proof with
   * Spring. The result is a session issuance, claims construction, and audit
   * log for compliance. Role integration is via actor_type:
   * 'authenticatedUser', as recorded in the table. Security is ensured by using
   * only the externally-verified external_user_id and email as credential base;
   * login is not available for soft-deleted accounts, as indicated by
   * deleted_at being set.
   *
   * No multi-factor or credential reset is supported locally; token/session
   * lifecycle is managed via token table and downstream audit hooks. Related
   * operations include registration/join, token refresh, and soft delete via
   * deleted_at field, as well as token revocation if an abuse case arises.
   *
   * @param connection
   * @param body Login payload with external_user_id and email, mapped to a
   *   verified Spring user; no password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: IStoryfieldAiAuthenticatedUser.ILogin,
  ): Promise<IStoryfieldAiAuthenticatedUser.IAuthorized> {
    try {
      return await postauthAuthenticatedUserLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh session and access tokens for authenticatedUser
   * (storyfield_ai_token_sessions) given existing, valid session/refresh
   * token.
   *
   * Enables an authenticatedUser with a valid, non-revoked session to refresh
   * their access token, establishing a new session/claims set. This operation
   * is available only to users whose session is active (deleted_at is null) and
   * whose previous session token has not been explicitly revoked or blacklisted
   * (storyfield_ai_token_revocations). Token refresh does not require password
   * or credential challenge—authorization is purely based on the session token
   * provided in the Authorization header.
   *
   * Upon successful refresh, a new token/session is issued, replacing the old
   * one and updating lifecycle audit and last activity/issued timestamps. The
   * session lifecycle and claims are always based on external identity mapping,
   * as established at join/login. Soft-deleted or revoked users cannot refresh;
   * session status is strictly enforced.
   *
   * Business use: This operation is crucial for maintaining continuous,
   * uninterrupted access to core business functionality without requiring users
   * to re-login frequently. Related operations include login/session creation,
   * token revocation, and session audit logging for compliance review.
   *
   * @param connection
   * @param body No explicit input—uses the currently provided session or
   *   refresh token for validation via Authorization header.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: IStoryfieldAiAuthenticatedUser.IRefresh,
  ): Promise<IStoryfieldAiAuthenticatedUser.IAuthorized> {
    try {
      return await postauthAuthenticatedUserRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
