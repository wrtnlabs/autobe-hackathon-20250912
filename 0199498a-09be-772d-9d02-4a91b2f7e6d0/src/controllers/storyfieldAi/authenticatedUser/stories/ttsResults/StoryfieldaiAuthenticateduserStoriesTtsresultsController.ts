import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { poststoryfieldAiAuthenticatedUserStoriesStoryIdTtsResults } from "../../../../../providers/poststoryfieldAiAuthenticatedUserStoriesStoryIdTtsResults";
import { AuthenticateduserAuth } from "../../../../../decorators/AuthenticateduserAuth";
import { AuthenticateduserPayload } from "../../../../../decorators/payload/AuthenticateduserPayload";
import { patchstoryfieldAiAuthenticatedUserStoriesStoryIdTtsResults } from "../../../../../providers/patchstoryfieldAiAuthenticatedUserStoriesStoryIdTtsResults";
import { getstoryfieldAiAuthenticatedUserStoriesStoryIdTtsResultsTtsResultId } from "../../../../../providers/getstoryfieldAiAuthenticatedUserStoriesStoryIdTtsResultsTtsResultId";
import { putstoryfieldAiAuthenticatedUserStoriesStoryIdTtsResultsTtsResultId } from "../../../../../providers/putstoryfieldAiAuthenticatedUserStoriesStoryIdTtsResultsTtsResultId";
import { deletestoryfieldAiAuthenticatedUserStoriesStoryIdTtsResultsTtsResultId } from "../../../../../providers/deletestoryfieldAiAuthenticatedUserStoriesStoryIdTtsResultsTtsResultId";

import { IStoryfieldAiTtsResult } from "../../../../../api/structures/IStoryfieldAiTtsResult";
import { IPageIStoryfieldAiTtsResult } from "../../../../../api/structures/IPageIStoryfieldAiTtsResult";

@Controller("/storyfieldAi/authenticatedUser/stories/:storyId/ttsResults")
export class StoryfieldaiAuthenticateduserStoriesTtsresultsController {
  /**
   * Create a new story TTS result (storyfield_ai_tts_results table).
   *
   * Creates a new TTS (Text-to-Speech) result for a given story. The client
   * specifies the story, text to synthesize, dialect, and may optionally target
   * a specific story page (for per-page narration). The API validates ownership
   * and input fields: only the authenticated owner of the story (or a
   * systemAdmin for administrative scenarios) may invoke this operation.
   * Soft-deleted or non-existent stories cannot have TTS generated.
   *
   * Upon validation, the system generates audio using the specified dialect,
   * uploads it to S3 (via Spring backend), and saves a new tts_results record
   * containing the audio URI, dialect, and metadata. Output validation ensures
   * full traceability and compliance. If errors arise in synthesis or upload,
   * they are reported and fully logged per compliance policy.
   *
   * Authorization strictly enforced; all insertions are auditable. Related
   * operations include updating TTS records for error recovery, retrieval, or
   * administrative review.
   *
   * @param connection
   * @param storyId Target story's unique identifier (UUID)
   * @param body Parameters for TTS synthesis, including source text, dialect
   *   option, and (optional) page ID.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AuthenticateduserAuth()
    authenticatedUser: AuthenticateduserPayload,
    @TypedParam("storyId")
    storyId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IStoryfieldAiTtsResult.ICreate,
  ): Promise<IStoryfieldAiTtsResult> {
    try {
      return await poststoryfieldAiAuthenticatedUserStoriesStoryIdTtsResults({
        authenticatedUser,
        storyId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List and search TTS results for a story (filter/sort/paginate).
   *
   * This API endpoint allows an authenticated user (the owner of a story) or a
   * system administrator to retrieve a paginated, filtered list of TTS
   * (Text-to-Speech) audio generation results associated with a specific story.
   * Filters can include dialect, associated page number, creation date, or
   * other relevant parameters provided by the schema.
   *
   * The operation supports pagination and advanced search features through a
   * structured request body, essential for managing stories with numerous TTS
   * entries, dialect variations, or multi-user scenarios. Only the owner of the
   * story or a system administrator is authorized to access all TTS results for
   * a given story, ensuring security and privacy of generated media.
   *
   * Internally, this operation queries the storyfield_ai_tts_results table with
   * an enforced storyId foreign-key filter. Additional filters and sorting are
   * passed in the request body and mapped to allowable schema fields. The
   * response is a paginated structure of TTS result summary objects, formatted
   * for efficient frontend consumption; errors (such as unauthorized access or
   * invalid storyId) are reported with appropriate status and detailed
   * messages.
   *
   * @param connection
   * @param storyId Unique identifier of the parent story whose TTS results are
   *   being listed.
   * @param body Filtering, sorting, and pagination options for the TTS results
   *   search.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AuthenticateduserAuth()
    authenticatedUser: AuthenticateduserPayload,
    @TypedParam("storyId")
    storyId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IStoryfieldAiTtsResult.IRequest,
  ): Promise<IPageIStoryfieldAiTtsResult.ISummary> {
    try {
      return await patchstoryfieldAiAuthenticatedUserStoriesStoryIdTtsResults({
        authenticatedUser,
        storyId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve a specific story TTS result by ID (storyfield_ai_tts_results
   * table).
   *
   * This operation allows clients to retrieve the full details of a single TTS
   * (Text-to-Speech) result attached to a generated story. The TTS result
   * includes fields such as the S3 URI of the audio file, dialect, original
   * source text, and references to the underlying story and story page (if
   * per-page audio).
   *
   * Users must be authenticated and only allowed to access their own TTS
   * results, unless elevated to a systemAdmin role for compliance or support
   * purposes. If the ttsResult has a deleted_at timestamp, standard users are
   * forbidden from accessing it, but systemAdmin may review for audits.
   * Permission checks are strict, and attempts to access others' data are
   * logged and denied.
   *
   * The underlying storyfield_ai_tts_results table supports links to the
   * broader story via storyfield_ai_story_id and, optionally, a single page via
   * storyfield_ai_story_page_id (supporting both full-story and per-page
   * narration use cases). Soft deletion is enforced by filtering records where
   * deleted_at is null for end-users, with full access only for admin review.
   *
   * Error conditions include attempts to access results not owned by the user,
   * referencing non-existent IDs, or accessing soft-deleted records. Access and
   * error events are fully auditable per compliance policy.
   *
   * @param connection
   * @param storyId Target story's unique identifier (UUID)
   * @param ttsResultId The unique ID of the TTS result to retrieve (UUID)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":ttsResultId")
  public async at(
    @AuthenticateduserAuth()
    authenticatedUser: AuthenticateduserPayload,
    @TypedParam("storyId")
    storyId: string & tags.Format<"uuid">,
    @TypedParam("ttsResultId")
    ttsResultId: string & tags.Format<"uuid">,
  ): Promise<IStoryfieldAiTtsResult> {
    try {
      return await getstoryfieldAiAuthenticatedUserStoriesStoryIdTtsResultsTtsResultId(
        {
          authenticatedUser,
          storyId,
          ttsResultId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing story TTS result (storyfield_ai_tts_results table).
   *
   * Enables modification of a previously generated TTS (Text-to-Speech) result.
   * Possible update scenarios include correcting dialect, updating the page
   * association (if per-page), and regenerating TTS with corrected or new
   * source text. The operation will validate the caller's authorization (story
   * owner or systemAdmin), check record existence, and enforce that the TTS
   * result is not soft-deleted.
   *
   * If TTS audio is to be re-generated, the previous audio URI is replaced
   * following a new S3 upload (coordinated via Spring backend). All update
   * actions are logged. Soft delete means updates are only possible for records
   * with null deleted_at field. Error scenarios include attempts to update
   * others' records, soft-deleted results, or unauthorized modifications. The
   * operation enforces consistency between the TTS result and the story/page
   * association.
   *
   * Usage is limited to authorized, non-deleted TTS result entries. All changes
   * are audit-tracked for forensics and compliance.
   *
   * @param connection
   * @param storyId Target story's unique identifier (UUID)
   * @param ttsResultId ID of the TTS result record to update (UUID)
   * @param body Fields to update, which may include dialect, text, or page
   *   association.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":ttsResultId")
  public async update(
    @AuthenticateduserAuth()
    authenticatedUser: AuthenticateduserPayload,
    @TypedParam("storyId")
    storyId: string & tags.Format<"uuid">,
    @TypedParam("ttsResultId")
    ttsResultId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IStoryfieldAiTtsResult.IUpdate,
  ): Promise<IStoryfieldAiTtsResult> {
    try {
      return await putstoryfieldAiAuthenticatedUserStoriesStoryIdTtsResultsTtsResultId(
        {
          authenticatedUser,
          storyId,
          ttsResultId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft-delete (erase) a story TTS result (storyfield_ai_tts_results table).
   *
   * This API operation performs a soft deletion of a TTS (Text-to-Speech)
   * result generated for a user's story, setting the deleted_at timestamp in
   * the storyfield_ai_tts_results table. Only owners of the parent story or
   * systemAdmin accounts may erase a TTS result; unauthorized access is blocked
   * and fully logged. Deleting the TTS result means it will be excluded from
   * standard list and fetch operations for normal users, but remains in the
   * database for audit and possible legal compliance.
   *
   * Upon deletion, the service may also coordinate with the storage layer (such
   * as S3 via Spring backend) to restrict access or physically remove the audio
   * file, if the business and compliance rules require it. Soft deleted records
   * are only accessible by systemAdmin users for compliance review. Attempts to
   * delete already deleted or non-existent records will return clear,
   * actionable error responses and incident logs are generated.
   *
   * Ensures administrative oversight and consistent treatment of all content
   * removal operations, supporting the compliance and traceability requirements
   * of the platform.
   *
   * @param connection
   * @param storyId Target story's unique identifier (UUID)
   * @param ttsResultId ID of the TTS result to erase (UUID)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":ttsResultId")
  public async erase(
    @AuthenticateduserAuth()
    authenticatedUser: AuthenticateduserPayload,
    @TypedParam("storyId")
    storyId: string & tags.Format<"uuid">,
    @TypedParam("ttsResultId")
    ttsResultId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletestoryfieldAiAuthenticatedUserStoriesStoryIdTtsResultsTtsResultId(
        {
          authenticatedUser,
          storyId,
          ttsResultId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
