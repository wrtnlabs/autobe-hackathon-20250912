import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postoauthServerMemberRefreshTokens } from "../../../../providers/postoauthServerMemberRefreshTokens";
import { MemberAuth } from "../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../decorators/payload/MemberPayload";
import { patchoauthServerMemberRefreshTokens } from "../../../../providers/patchoauthServerMemberRefreshTokens";
import { getoauthServerMemberRefreshTokensId } from "../../../../providers/getoauthServerMemberRefreshTokensId";
import { putoauthServerMemberRefreshTokensId } from "../../../../providers/putoauthServerMemberRefreshTokensId";
import { deleteoauthServerMemberRefreshTokensId } from "../../../../providers/deleteoauthServerMemberRefreshTokensId";

import { IOauthServerRefreshToken } from "../../../../api/structures/IOauthServerRefreshToken";
import { IPageIOauthServerRefreshToken } from "../../../../api/structures/IPageIOauthServerRefreshToken";

@Controller("/oauthServer/member/refreshTokens")
export class OauthserverMemberRefreshtokensController {
  /**
   * Create a new opaque OAuth refresh token.
   *
   * Create a new OAuth refresh token record. This token is opaque and linked to
   * an OAuth client and optionally an authorization code.
   *
   * The request includes token string, scopes, expiry, and related OAuth client
   * information.
   *
   * Access control restricts this operation to authenticated members.
   *
   * Validation ensures token uniqueness and correct expiration formatting.
   *
   * @param connection
   * @param body Creation information of the refresh token
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @MemberAuth()
    member: MemberPayload,
    @TypedBody()
    body: IOauthServerRefreshToken.ICreate,
  ): Promise<IOauthServerRefreshToken> {
    try {
      return await postoauthServerMemberRefreshTokens({
        member,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve a paginated list of opaque OAuth refresh tokens.
   *
   * Retrieve a filtered and paginated list of OAuth server refresh tokens from
   * the oauth_server_refresh_tokens table. This operation allows clients to
   * search for tokens by various fields including token string, associated
   * client, expiration time, and scopes.
   *
   * The operation supports pagination with offset and limit parameters, sorting
   * by created_at or expires_at, and filtering by token status or associated
   * client.
   *
   * Security considerations include restricting access to authenticated members
   * to prevent exposure of sensitive token information. The refresh tokens are
   * opaque strings used for renewing access tokens in OAuth flows.
   *
   * This operation is essential for client and admin monitoring tools to audit
   * and manage token usage and lifecycle. Error handling includes validation
   * for search criteria and pagination bounds.
   *
   * @param connection
   * @param body Search criteria and pagination parameters for listing refresh
   *   tokens
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @MemberAuth()
    member: MemberPayload,
    @TypedBody()
    body: IOauthServerRefreshToken.IRequest,
  ): Promise<IPageIOauthServerRefreshToken.ISummary> {
    try {
      return await patchoauthServerMemberRefreshTokens({
        member,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get detailed information for a specific OAuth refresh token by ID.
   *
   * Retrieve detailed information about a specific OAuth refresh token using
   * its unique identifier from the oauth_server_refresh_tokens table.
   *
   * The response includes token string, scopes granted, expiration, linked
   * OAuth client, and related authorization code data for comprehensive token
   * inspection.
   *
   * Only authenticated members with appropriate roles can access this endpoint
   * for security.
   *
   * Errors include token not found or access denied.
   *
   * @param connection
   * @param id Unique identifier of the target refresh token
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":id")
  public async at(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("id")
    id: string & tags.Format<"uuid">,
  ): Promise<IOauthServerRefreshToken> {
    try {
      return await getoauthServerMemberRefreshTokensId({
        member,
        id,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update existing OAuth refresh token information.
   *
   * Update an existing OAuth refresh token by its unique ID.
   *
   * Supports modification of token string, scopes, expiration, and associated
   * authorization code.
   *
   * Access restricted to authenticated members for security.
   *
   * Errors include token not found or invalid update data.
   *
   * @param connection
   * @param id Unique identifier of the target refresh token
   * @param body Update information of the refresh token
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":id")
  public async update(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("id")
    id: string & tags.Format<"uuid">,
    @TypedBody()
    body: IOauthServerRefreshToken.IUpdate,
  ): Promise<IOauthServerRefreshToken> {
    try {
      return await putoauthServerMemberRefreshTokensId({
        member,
        id,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete an OAuth refresh token by ID.
   *
   * Permanently delete a specific OAuth refresh token by its unique identifier.
   * This refresh token is stored in the oauth_server_refresh_tokens table and
   * is used for renewing access tokens securely.
   *
   * Performing this operation requires appropriate authorization to prevent
   * malicious revocation of tokens by unauthorized users.
   *
   * The operation accepts the refresh token ID as a UUID path parameter. It
   * does not require any request body, and on successful execution, no content
   * is returned.
   *
   * Errors may occur if the token ID does not exist or the caller lacks
   * permissions. Proper authorization and validation must be enforced.
   *
   * Related token management APIs include creation, listing, and validation of
   * refresh tokens.
   *
   * This delete operation removes the record completely from the database, as
   * opposed to soft deletion.
   *
   * @param connection
   * @param id Unique identifier of the OAuth refresh token
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":id")
  public async eraseRefreshToken(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("id")
    id: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteoauthServerMemberRefreshTokensId({
        member,
        id,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
