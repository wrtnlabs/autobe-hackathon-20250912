import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postoauthServerAdminScopes } from "../../../../providers/postoauthServerAdminScopes";
import { AdminAuth } from "../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../decorators/payload/AdminPayload";
import { patchoauthServerAdminScopes } from "../../../../providers/patchoauthServerAdminScopes";
import { getoauthServerAdminScopesId } from "../../../../providers/getoauthServerAdminScopesId";
import { putoauthServerAdminScopesId } from "../../../../providers/putoauthServerAdminScopesId";
import { deleteoauthServerAdminScopesId } from "../../../../providers/deleteoauthServerAdminScopesId";

import { IOauthServerScope } from "../../../../api/structures/IOauthServerScope";
import { IPageIOauthServerScope } from "../../../../api/structures/IPageIOauthServerScope";

@Controller("/oauthServer/admin/scopes")
export class OauthserverAdminScopesController {
  /**
   * Create a new OAuth scope with a unique code and a descriptive explanation
   * of the permissions it grants. This operation allows administrators to
   * extend the set of available OAuth scopes that clients can request during
   * authorization.
   *
   * Security considerations require that only authorized users with admin
   * privileges can create new scopes to ensure controlled expansion of
   * permission settings.
   *
   * The underlying database table is oauth_server_scopes, which enforces
   * uniqueness for the scope code. Validation includes checking for code
   * uniqueness and ensuring the description is informative.
   *
   * This operation is typically used in an administrative interface managing
   * OAuth permissions.
   *
   * Errors are returned if the scope code already exists or if required fields
   * are missing.
   *
   * @param connection
   * @param body Information needed to create an OAuth scope
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: IOauthServerScope.ICreate,
  ): Promise<IOauthServerScope> {
    try {
      return await postoauthServerAdminScopes({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List and search OAuth scopes with pagination.
   *
   * Fetch a filtered, sorted, and paginated list of OAuth 2.0 scopes. This
   * operation allows clients to query the scopes available in the system,
   * supporting criteria such as code filtering, description matching, and
   * pagination.
   *
   * Access is protected and typically limited to admin roles due to the
   * security impact of scope management.
   *
   * Results include essential details like scope code and description optimized
   * for UI representation.
   *
   * The response contains pages of scope summary records.
   *
   * @param connection
   * @param body Filtering and paging parameters for querying scopes
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: IOauthServerScope.IRequest,
  ): Promise<IPageIOauthServerScope.ISummary> {
    try {
      return await patchoauthServerAdminScopes({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get details of a specific OAuth scope by ID.
   *
   * Retrieve detailed information about a specific OAuth 2.0 scope given its
   * unique ID.
   *
   * The data includes scope code, description, and timestamps.
   *
   * Proper authorization is required to access scope details.
   *
   * This operation returns the full scope entry matching the provided ID.
   *
   * @param connection
   * @param id Unique identifier of the scope
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":id")
  public async at(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("id")
    id: string & tags.Format<"uuid">,
  ): Promise<IOauthServerScope> {
    try {
      return await getoauthServerAdminScopesId({
        admin,
        id,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing OAuth scope by ID.
   *
   * Update the code or description of an existing OAuth scope by specifying its
   * unique ID. This operation ensures scopes remain current and accurately
   * describe the permissions they represent.
   *
   * Only users with administrative privileges should perform this action to
   * maintain security and control over OAuth scopes.
   *
   * The underlying database enforces uniqueness of the scope code. The
   * operation supports partial or full updates depending on the provided
   * fields.
   *
   * Errors are handled for non-existent IDs or duplicate scope codes.
   *
   * @param connection
   * @param id Target scope's UUID
   * @param body Updated information for the OAuth scope
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":id")
  public async update(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("id")
    id: string & tags.Format<"uuid">,
    @TypedBody()
    body: IOauthServerScope.IUpdate,
  ): Promise<IOauthServerScope> {
    try {
      return await putoauthServerAdminScopesId({
        admin,
        id,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft delete an OAuth scope by ID.
   *
   * Soft delete the OAuth scope identified by the given ID. This marks the
   * scope as deleted by setting the deleted_at timestamp, effectively
   * deactivating it.
   *
   * Only administrators should be permitted to delete scopes to prevent
   * unauthorized removal of critical authorization elements.
   *
   * The operation ensures that deleted scopes are excluded from active queries
   * but remain in the database for historical reference.
   *
   * Errors return when the specified scope ID does not exist or is already
   * deleted.
   *
   * @param connection
   * @param id Target scope's UUID
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":id")
  public async erase(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("id")
    id: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteoauthServerAdminScopesId({
        admin,
        id,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
