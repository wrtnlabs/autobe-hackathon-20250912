import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IOauthServerGuest } from "../../../structures/IOauthServerGuest";
import { IOauthServerOauthServerGuest } from "../../../structures/IOauthServerOauthServerGuest";

/**
 * Guest user registration creating a temporary unauthenticated session and
 * issuing temporary JWT tokens with no credentials.
 *
 * This operation implements guest user registration creating a new guest
 * account record in the 'oauth_server_guests' table which tracks only creation
 * and update timestamps and supports soft delete via 'deleted_at'. No
 * authentication fields exist as guests do not possess credentials. Tokens
 * issued upon join allow temporary access without login. This endpoint is
 * public as guests are unauthenticated entities. Tokens issued are optimized
 * for ephemeral sessions as guests' access is limited. Related operations
 * include the token refresh endpoint for guests.
 *
 * Clients may use this join API to start a new guest session before proceeding
 * to authenticated workflows or browse limited resources.
 *
 * Soft delete policy applies but guest entries are expected to be temporary.
 *
 * This API operation is essential for temporary, unauthenticated access
 * management in the OAuth server system.
 *
 * @param props.connection
 * @param props.body Payload to create a new guest user account entry in the
 *   'oauth_server_guests' table.
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/join
 * @accessor api.functional.auth.guest.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Payload to create a new guest user account entry in the
     * 'oauth_server_guests' table.
     */
    body: IOauthServerGuest.ICreate;
  };
  export type Body = IOauthServerGuest.ICreate;
  export type Response = IOauthServerOauthServerGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/join";
  export const random = (): IOauthServerOauthServerGuest.IAuthorized =>
    typia.random<IOauthServerOauthServerGuest.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Guest user refreshes temporary tokens to extend ephemeral sessions without
 * login.
 *
 * Token refresh operation for guests who have temporary access tokens issued
 * after registration but no traditional authentication credentials. The
 * 'oauth_server_guests' table contains no password or email fields, confirming
 * ephemeral access. This endpoint renews tokens based on valid refresh token
 * presented, extending guest sessions temporarily.
 *
 * This process helps maintain lightweight guest access without persistent
 * login.
 *
 * Soft delete field 'deleted_at' applies to guest entries.
 *
 * Refresh tokens and access tokens have short TTLs aligned with guest session
 * management.
 *
 * This API complements the 'join' operation for guests to maintain ephemeral
 * authenticated state safely.
 *
 * Security considerations include strict validation of refresh tokens and
 * expiration.
 *
 * @param props.connection
 * @param props.body Refresh token payload to request new tokens for guest user
 *   session.
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/refresh
 * @accessor api.functional.auth.guest.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token payload to request new tokens for guest user session. */
    body: IOauthServerGuest.IRefresh;
  };
  export type Body = IOauthServerGuest.IRefresh;
  export type Response = IOauthServerOauthServerGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/refresh";
  export const random = (): IOauthServerOauthServerGuest.IAuthorized =>
    typia.random<IOauthServerOauthServerGuest.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
