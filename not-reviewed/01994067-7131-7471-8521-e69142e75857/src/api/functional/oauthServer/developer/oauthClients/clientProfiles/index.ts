import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IOauthServerClientProfile } from "../../../../../structures/IOauthServerClientProfile";
import { IPageIOauthServerClientProfile } from "../../../../../structures/IPageIOauthServerClientProfile";

/**
 * Create a new OAuth client profile for a given OAuth client.
 *
 * Create a new OAuth client profile under the specified OAuth client. This
 * endpoint accepts profile metadata including nickname and optional
 * description.
 *
 * Access is restricted to authenticated developers with permission to manage
 * the client. Input validation and uniqueness checks are performed.
 *
 * The profile is stored in the oauth_server_client_profiles table with
 * timestamps and soft delete disabled by default.
 *
 * Upon successful creation, the full profile details are returned.
 *
 * @param props.connection
 * @param props.oauthClientId Unique identifier of the target OAuth client
 * @param props.body Data for creating new OAuth client profile
 * @path /oauthServer/developer/oauthClients/:oauthClientId/clientProfiles
 * @accessor api.functional.oauthServer.developer.oauthClients.clientProfiles.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target OAuth client */
    oauthClientId: string & tags.Format<"uuid">;

    /** Data for creating new OAuth client profile */
    body: IOauthServerClientProfile.ICreate;
  };
  export type Body = IOauthServerClientProfile.ICreate;
  export type Response = IOauthServerClientProfile;

  export const METADATA = {
    method: "POST",
    path: "/oauthServer/developer/oauthClients/:oauthClientId/clientProfiles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/oauthServer/developer/oauthClients/${encodeURIComponent(props.oauthClientId ?? "null")}/clientProfiles`;
  export const random = (): IOauthServerClientProfile =>
    typia.random<IOauthServerClientProfile>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("oauthClientId")(() => typia.assert(props.oauthClientId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List OAuth client profiles for a given OAuth client with pagination and
 * filtering.
 *
 * Retrieve a filtered and paginated list of OAuth client profiles for the
 * specified OAuth client. This operation enables developers to search and
 * manage client profile metadata such as nicknames and descriptions, which are
 * frequently updated independently from the main client record.
 *
 * Security considerations include role-based access, permitting only
 * authenticated developers to access this endpoint. Proper authorization checks
 * ensure that developers can only view profiles belonging to OAuth clients they
 * are authorized to manage.
 *
 * This operation directly queries the oauth_server_client_profiles table,
 * filtering out soft-deleted records and returning results with pagination and
 * ordering options.
 *
 * Expected behavior includes returning profiles with current metadata,
 * supporting client management UIs and API integrations.
 *
 * @param props.connection
 * @param props.oauthClientId Unique identifier of the target OAuth client
 * @param props.body Search criteria and pagination parameters for OAuth client
 *   profiles
 * @path /oauthServer/developer/oauthClients/:oauthClientId/clientProfiles
 * @accessor api.functional.oauthServer.developer.oauthClients.clientProfiles.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the target OAuth client */
    oauthClientId: string & tags.Format<"uuid">;

    /** Search criteria and pagination parameters for OAuth client profiles */
    body: IOauthServerClientProfile.IRequest;
  };
  export type Body = IOauthServerClientProfile.IRequest;
  export type Response = IPageIOauthServerClientProfile;

  export const METADATA = {
    method: "PATCH",
    path: "/oauthServer/developer/oauthClients/:oauthClientId/clientProfiles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/oauthServer/developer/oauthClients/${encodeURIComponent(props.oauthClientId ?? "null")}/clientProfiles`;
  export const random = (): IPageIOauthServerClientProfile =>
    typia.random<IPageIOauthServerClientProfile>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("oauthClientId")(() => typia.assert(props.oauthClientId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed OAuth client profile information by ID.
 *
 * Retrieve detailed information of the specified OAuth client profile by its
 * unique identifier for a given OAuth client. This endpoint supports detailed
 * profile viewing, including nickname and description fields.
 *
 * Security measures restrict access to authenticated developers associated with
 * the OAuth client. Data integrity is maintained by ensuring the profile
 * belongs to the specified client and has not been soft deleted.
 *
 * The operation maps directly to the oauth_server_client_profiles table in the
 * database, excluding soft-deleted profiles from retrieval.
 *
 * Errors are handled gracefully with appropriate HTTP status codes if the
 * profile does not exist or access is unauthorized.
 *
 * @param props.connection
 * @param props.oauthClientId Unique identifier of the target OAuth client
 * @param props.id Unique identifier of the OAuth client profile
 * @path /oauthServer/developer/oauthClients/:oauthClientId/clientProfiles/:id
 * @accessor api.functional.oauthServer.developer.oauthClients.clientProfiles.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target OAuth client */
    oauthClientId: string & tags.Format<"uuid">;

    /** Unique identifier of the OAuth client profile */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IOauthServerClientProfile;

  export const METADATA = {
    method: "GET",
    path: "/oauthServer/developer/oauthClients/:oauthClientId/clientProfiles/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/oauthServer/developer/oauthClients/${encodeURIComponent(props.oauthClientId ?? "null")}/clientProfiles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IOauthServerClientProfile =>
    typia.random<IOauthServerClientProfile>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("oauthClientId")(() => typia.assert(props.oauthClientId));
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing OAuth client profile by ID.
 *
 * Update the specified OAuth client profile for a given OAuth client with new
 * metadata such as nickname and description.
 *
 * Only authenticated developers authorized for the OAuth client can perform
 * this operation. The profile must exist and not be soft-deleted.
 *
 * The update operation modifies the oauth_server_client_profiles table and
 * returns the updated profile data upon successful completion.
 *
 * Errors such as missing profile or unauthorized access are properly handled
 * with relevant HTTP status codes and messages.
 *
 * @param props.connection
 * @param props.oauthClientId Unique identifier of the target OAuth client
 * @param props.id Unique identifier of the OAuth client profile
 * @param props.body Updated data for the OAuth client profile
 * @path /oauthServer/developer/oauthClients/:oauthClientId/clientProfiles/:id
 * @accessor api.functional.oauthServer.developer.oauthClients.clientProfiles.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target OAuth client */
    oauthClientId: string & tags.Format<"uuid">;

    /** Unique identifier of the OAuth client profile */
    id: string & tags.Format<"uuid">;

    /** Updated data for the OAuth client profile */
    body: IOauthServerClientProfile.IUpdate;
  };
  export type Body = IOauthServerClientProfile.IUpdate;
  export type Response = IOauthServerClientProfile;

  export const METADATA = {
    method: "PUT",
    path: "/oauthServer/developer/oauthClients/:oauthClientId/clientProfiles/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/oauthServer/developer/oauthClients/${encodeURIComponent(props.oauthClientId ?? "null")}/clientProfiles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IOauthServerClientProfile =>
    typia.random<IOauthServerClientProfile>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("oauthClientId")(() => typia.assert(props.oauthClientId));
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete one OAuth client profile record by client ID and profile ID.
 *
 * Delete a client profile entry associated with a particular OAuth client.
 *
 * This endpoint permanently deletes the profile record identified by the unique
 * profile ID under the specified OAuth client ID. The
 * oauth_server_client_profiles table stores display nicknames and descriptions
 * that often change and are managed separately from the main OAuth client
 * data.
 *
 * Access control requires developer-level authorization to ensure only
 * authorized users can delete client profile entries.
 *
 * All deletions are hard deletes; once deleted, the profile entry cannot be
 * recovered.
 *
 * This complements client profile retrieval and update operations to provide
 * full client profile management capabilities.
 *
 * @param props.connection
 * @param props.oauthClientId Unique identifier of the target OAuth client
 * @param props.id Unique identifier of the client profile to delete
 * @path /oauthServer/developer/oauthClients/:oauthClientId/clientProfiles/:id
 * @accessor api.functional.oauthServer.developer.oauthClients.clientProfiles.eraseClientProfile
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseClientProfile(
  connection: IConnection,
  props: eraseClientProfile.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseClientProfile.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseClientProfile.METADATA,
          path: eraseClientProfile.path(props),
          status: null,
        },
      );
}
export namespace eraseClientProfile {
  export type Props = {
    /** Unique identifier of the target OAuth client */
    oauthClientId: string & tags.Format<"uuid">;

    /** Unique identifier of the client profile to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/oauthServer/developer/oauthClients/:oauthClientId/clientProfiles/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/oauthServer/developer/oauthClients/${encodeURIComponent(props.oauthClientId ?? "null")}/clientProfiles/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseClientProfile.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseClientProfile.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("oauthClientId")(() => typia.assert(props.oauthClientId));
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
