import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IOauthServerIdToken } from "../../../../structures/IOauthServerIdToken";
import { IPageIOauthServerIdToken } from "../../../../structures/IPageIOauthServerIdToken";

/**
 * Create a new OAuth ID token according to OpenID Connect standards. This token
 * is recorded in the oauth_server_id_tokens table.
 *
 * The request body must contain all required fields for creating the ID token,
 * matching the IOauthServerIdToken.ICreate schema.
 *
 * Upon successful creation, the new ID token entity is returned including token
 * string, timestamps, expiration, and associated client details.
 *
 * This operation requires authorization limited to authenticated members to
 * prevent unauthorized token issuance.
 *
 * Errors due to validation or authorization failures must be handled
 * accordingly.
 *
 * This API uses POST method with JSON request body and returns the created
 * token entity.
 *
 * @param props.connection
 * @param props.body Creation info for the new OAuth ID token
 * @path /oauthServer/member/idTokens
 * @accessor api.functional.oauthServer.member.idTokens.createIdToken
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createIdToken(
  connection: IConnection,
  props: createIdToken.Props,
): Promise<createIdToken.Response> {
  return true === connection.simulate
    ? createIdToken.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createIdToken.METADATA,
          path: createIdToken.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createIdToken {
  export type Props = {
    /** Creation info for the new OAuth ID token */
    body: IOauthServerIdToken.ICreate;
  };
  export type Body = IOauthServerIdToken.ICreate;
  export type Response = IOauthServerIdToken;

  export const METADATA = {
    method: "POST",
    path: "/oauthServer/member/idTokens",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/oauthServer/member/idTokens";
  export const random = (): IOauthServerIdToken =>
    typia.random<IOauthServerIdToken>();
  export const simulate = (
    connection: IConnection,
    props: createIdToken.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createIdToken.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve filtered, paginated list of OAuth ID tokens.
 *
 * Return a filtered, paginated collection of OAuth ID tokens from the system.
 * These ID tokens conform to OpenID Connect standards and are stored in the
 * oauth_server_id_tokens table.
 *
 * The search parameters include filtering by various token attributes such as
 * client ID, expiration dates, and status.
 *
 * This operation requires user authentication and returns summaries of tokens
 * matching the search criteria.
 *
 * Request is sent by PATCH method with JSON body matching
 * IOauthServerIdToken.IRequest. Response includes a page of
 * IOauthServerIdToken.ISummary objects.
 *
 * Errors are handled with appropriate authorization and validation.
 *
 * This operation is typically used in token management interfaces for
 * monitoring and auditing tokens.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for ID token
 *   filtering
 * @path /oauthServer/member/idTokens
 * @accessor api.functional.oauthServer.member.idTokens.indexIdToken
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexIdToken(
  connection: IConnection,
  props: indexIdToken.Props,
): Promise<indexIdToken.Response> {
  return true === connection.simulate
    ? indexIdToken.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexIdToken.METADATA,
          path: indexIdToken.path(),
          status: null,
        },
        props.body,
      );
}
export namespace indexIdToken {
  export type Props = {
    /** Search criteria and pagination parameters for ID token filtering */
    body: IOauthServerIdToken.IRequest;
  };
  export type Body = IOauthServerIdToken.IRequest;
  export type Response = IPageIOauthServerIdToken.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/oauthServer/member/idTokens",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/oauthServer/member/idTokens";
  export const random = (): IPageIOauthServerIdToken.ISummary =>
    typia.random<IPageIOauthServerIdToken.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: indexIdToken.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexIdToken.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve OAuth ID token details by ID.
 *
 * Fetch detailed information of a specific OAuth ID token by its unique ID. The
 * ID token is stored in the oauth_server_id_tokens table representing OpenID
 * Connect ID tokens issued to clients.
 *
 * This query requires the ID as a UUID path parameter and returns all details
 * of the ID token entity.
 *
 * Authorization roles are limited to authenticated members for security.
 *
 * Errors will be returned if the token ID is invalid or access is denied.
 *
 * This GET operation does not require a request body and returns a detailed
 * response.
 *
 * Typical use cases include token audits and token detail retrieval in
 * management systems.
 *
 * @param props.connection
 * @param props.id Unique identifier of the OAuth ID token
 * @path /oauthServer/member/idTokens/:id
 * @accessor api.functional.oauthServer.member.idTokens.atIdToken
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atIdToken(
  connection: IConnection,
  props: atIdToken.Props,
): Promise<atIdToken.Response> {
  return true === connection.simulate
    ? atIdToken.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atIdToken.METADATA,
          path: atIdToken.path(props),
          status: null,
        },
      );
}
export namespace atIdToken {
  export type Props = {
    /** Unique identifier of the OAuth ID token */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IOauthServerIdToken;

  export const METADATA = {
    method: "GET",
    path: "/oauthServer/member/idTokens/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/oauthServer/member/idTokens/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IOauthServerIdToken =>
    typia.random<IOauthServerIdToken>();
  export const simulate = (
    connection: IConnection,
    props: atIdToken.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atIdToken.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
