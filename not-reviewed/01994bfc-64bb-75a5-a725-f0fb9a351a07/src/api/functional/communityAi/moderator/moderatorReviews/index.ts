import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityAiModeratorReview } from "../../../../structures/ICommunityAiModeratorReview";
import { IPageICommunityAiModeratorReview } from "../../../../structures/IPageICommunityAiModeratorReview";

/**
 * Create a new moderator review record allowing moderators to log their
 * decision and comments on flagged content or user reports. This operation
 * accepts a request body with the review details such as linked moderator ID,
 * associated content flag or user report IDs, decision outcome, and any
 * relevant comments.
 *
 * Security policies restrict this action to authenticated moderators and admins
 * only. The submitted data must comply with the Prisma schema constraints,
 * ensuring referenced IDs exist and decisions follow business rules.
 *
 * On success, the operation returns the newly created moderator review,
 * including timestamps and identifiers. Validation errors or relational
 * integrity issues result in error responses.
 *
 * This operation integrates with other moderation endpoints to support
 * comprehensive content governance in the community AI platform.
 *
 * @param props.connection
 * @param props.body Data required to create a moderator review
 * @path /communityAi/moderator/moderatorReviews
 * @accessor api.functional.communityAi.moderator.moderatorReviews.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Data required to create a moderator review */
    body: ICommunityAiModeratorReview.ICreate;
  };
  export type Body = ICommunityAiModeratorReview.ICreate;
  export type Response = ICommunityAiModeratorReview;

  export const METADATA = {
    method: "POST",
    path: "/communityAi/moderator/moderatorReviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityAi/moderator/moderatorReviews";
  export const random = (): ICommunityAiModeratorReview =>
    typia.random<ICommunityAiModeratorReview>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated list of moderator reviews.
 *
 * Fetch a list of moderator reviews with filtering, pagination, and sorting
 * options.
 *
 * Moderators can search and browse reviews based on criteria provided in the
 * request body.
 *
 * The operation returns paginated results with summary information to support
 * efficient moderation workflows.
 *
 * Authorization ensures only authenticated moderators have access to review
 * listings.
 *
 * The request body schema defines possible filtering fields such as decision,
 * date ranges, and user report references.
 *
 * Support for sorting and pagination enhances usability for large datasets.
 *
 * This endpoint is useful for moderation dashboards and system audits.
 *
 * @param props.connection
 * @param props.body Filtering, sorting, and pagination parameters for listing
 *   moderator reviews
 * @path /communityAi/moderator/moderatorReviews
 * @accessor api.functional.communityAi.moderator.moderatorReviews.searchModeratorReviews
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function searchModeratorReviews(
  connection: IConnection,
  props: searchModeratorReviews.Props,
): Promise<searchModeratorReviews.Response> {
  return true === connection.simulate
    ? searchModeratorReviews.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...searchModeratorReviews.METADATA,
          path: searchModeratorReviews.path(),
          status: null,
        },
        props.body,
      );
}
export namespace searchModeratorReviews {
  export type Props = {
    /**
     * Filtering, sorting, and pagination parameters for listing moderator
     * reviews
     */
    body: ICommunityAiModeratorReview.IRequest;
  };
  export type Body = ICommunityAiModeratorReview.IRequest;
  export type Response = IPageICommunityAiModeratorReview;

  export const METADATA = {
    method: "PATCH",
    path: "/communityAi/moderator/moderatorReviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityAi/moderator/moderatorReviews";
  export const random = (): IPageICommunityAiModeratorReview =>
    typia.random<IPageICommunityAiModeratorReview>();
  export const simulate = (
    connection: IConnection,
    props: searchModeratorReviews.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: searchModeratorReviews.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed moderator review by ID.
 *
 * Retrieve a detailed view of a specific moderator review by its unique
 * identifier. The moderator review represents the decision and comments issued
 * by a moderator about content flagged or reported by members. The information
 * returned includes who reviewed it (moderator), the outcome decision (e.g.,
 * approved, rejected), and any additional moderator comments.
 *
 * Security considerations restrict access to authenticated moderator and admin
 * users, ensuring only authorized personnel can view moderation history. The
 * response is based on data from the `community_ai_moderator_reviews` Prisma
 * model, which includes properties like `id`, `community_ai_moderator_id`,
 * `community_ai_content_flag_id`, `community_ai_user_report_id`, `decision`,
 * `comments`, `created_at`, `updated_at`, and `deleted_at`.
 *
 * Clients must provide a valid UUID as the path parameter `moderatorReviewId`.
 * The operation ensures referential integrity by relating the review to the
 * correct moderator, content flags, or user reports based on IDs.
 *
 * Errors due to invalid UUID format or non-existing records are handled by
 * appropriate HTTP response codes. This operation complements create, update,
 * and delete actions for moderator reviews within the moderation workflows.
 *
 * @param props.connection
 * @param props.moderatorReviewId Unique identifier of the moderator review to
 *   retrieve
 * @path /communityAi/moderator/moderatorReviews/:moderatorReviewId
 * @accessor api.functional.communityAi.moderator.moderatorReviews.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the moderator review to retrieve */
    moderatorReviewId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityAiModeratorReview;

  export const METADATA = {
    method: "GET",
    path: "/communityAi/moderator/moderatorReviews/:moderatorReviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/moderator/moderatorReviews/${encodeURIComponent(props.moderatorReviewId ?? "null")}`;
  export const random = (): ICommunityAiModeratorReview =>
    typia.random<ICommunityAiModeratorReview>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderatorReviewId")(() =>
        typia.assert(props.moderatorReviewId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing moderator review by its unique identifier. This allows
 * modification of the review decision, comments, and references to content
 * flags or user reports.
 *
 * Authorization is limited to moderators and admins who have the proper
 * credentials to change reviews. The request requires the valid UUID path
 * parameter `moderatorReviewId` and an update body conforming to the
 * `ICommunityAiModeratorReview.IUpdate` schema. The body may include changes to
 * decision, comments, or linked flag/report IDs.
 *
 * On successful update, the system returns the updated moderator review record
 * including the latest timestamps.
 *
 * This operation supports flexibility in content moderation workflows, enabling
 * reviewers to amend or correct their previous decisions while maintaining data
 * consistency within related entities.
 *
 * @param props.connection
 * @param props.moderatorReviewId Unique identifier of the moderator review to
 *   update
 * @param props.body Updated data for the moderator review
 * @path /communityAi/moderator/moderatorReviews/:moderatorReviewId
 * @accessor api.functional.communityAi.moderator.moderatorReviews.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the moderator review to update */
    moderatorReviewId: string & tags.Format<"uuid">;

    /** Updated data for the moderator review */
    body: ICommunityAiModeratorReview.IUpdate;
  };
  export type Body = ICommunityAiModeratorReview.IUpdate;
  export type Response = ICommunityAiModeratorReview;

  export const METADATA = {
    method: "PUT",
    path: "/communityAi/moderator/moderatorReviews/:moderatorReviewId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityAi/moderator/moderatorReviews/${encodeURIComponent(props.moderatorReviewId ?? "null")}`;
  export const random = (): ICommunityAiModeratorReview =>
    typia.random<ICommunityAiModeratorReview>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderatorReviewId")(() =>
        typia.assert(props.moderatorReviewId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a moderator review by ID (soft delete).
 *
 * Remove a moderator review record from the system by marking it as deleted.
 * This soft deletion retains the record for auditing but hides it from active
 * views.
 *
 * Access is restricted to authorized moderators and admins only to prevent
 * unauthorized data modification.
 *
 * The path parameter `moderatorReviewId` must be a valid UUID of the review to
 * delete. The system sets the `deleted_at` timestamp to indicate deletion.
 *
 * Clients should note that the record is not physically removed but flagged as
 * deleted to comply with auditing and traceability policies.
 *
 * This operation complements the create, read, and update endpoints for full
 * lifecycle management of moderator reviews.
 *
 * @param props.connection
 * @param props.moderatorReviewId Unique identifier of the moderator review to
 *   delete
 * @path /communityAi/moderator/moderatorReviews/:moderatorReviewId
 * @accessor api.functional.communityAi.moderator.moderatorReviews.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the moderator review to delete */
    moderatorReviewId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityAi/moderator/moderatorReviews/:moderatorReviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/moderator/moderatorReviews/${encodeURIComponent(props.moderatorReviewId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("moderatorReviewId")(() =>
        typia.assert(props.moderatorReviewId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
