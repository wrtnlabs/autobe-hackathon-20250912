import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityAiPermission } from "../../../../structures/ICommunityAiPermission";
import { IPageICommunityAiPermission } from "../../../../structures/IPageICommunityAiPermission";

/**
 * Create a new permission for access control.
 *
 * Create a new permission entity defining an access right in the Community AI
 * platform. This API expects a unique permission_name and optional descriptive
 * information about the permission. It returns the created permission record
 * including timestamps. This operation is restricted to authorized roles such
 * as administrators since permission definitions affect system-wide access
 * control.
 *
 * Security: Only users with the 'admin' role should use this endpoint as it
 * influences access rights.
 *
 * This operation interfaces directly with the community_ai_permissions table as
 * defined in the Prisma schema. It strictly requires the permission_name to be
 * unique. Validation errors should be returned if uniqueness is violated or
 * required fields are missing.
 *
 * Related Operations: update permission, delete permission endpoints.
 *
 * Behavior: On success, the new permission is stored and returned. On failure,
 * appropriate HTTP error codes should be used with explanatory messages.
 *
 * @param props.connection
 * @param props.body New permission creation data
 * @path /communityAi/admin/permissions
 * @accessor api.functional.communityAi.admin.permissions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** New permission creation data */
    body: ICommunityAiPermission.ICreate;
  };
  export type Body = ICommunityAiPermission.ICreate;
  export type Response = ICommunityAiPermission;

  export const METADATA = {
    method: "POST",
    path: "/communityAi/admin/permissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityAi/admin/permissions";
  export const random = (): ICommunityAiPermission =>
    typia.random<ICommunityAiPermission>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list permissions with pagination.
 *
 * This operation provides a paginated search of permissions in the system.
 * Users can filter and sort results to find specific permissions based on
 * various criteria such as permission_name and description.
 *
 * Only authorized roles with admin privileges can access this data for security
 * reasons.
 *
 * The response includes a paginated collection of permission summary objects.
 *
 * @param props.connection
 * @param props.body Search filters and pagination parameters for permissions
 * @path /communityAi/admin/permissions
 * @accessor api.functional.communityAi.admin.permissions.searchPermissions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function searchPermissions(
  connection: IConnection,
  props: searchPermissions.Props,
): Promise<searchPermissions.Response> {
  return true === connection.simulate
    ? searchPermissions.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...searchPermissions.METADATA,
          path: searchPermissions.path(),
          status: null,
        },
        props.body,
      );
}
export namespace searchPermissions {
  export type Props = {
    /** Search filters and pagination parameters for permissions */
    body: ICommunityAiPermission.IRequest;
  };
  export type Body = ICommunityAiPermission.IRequest;
  export type Response = IPageICommunityAiPermission.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityAi/admin/permissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityAi/admin/permissions";
  export const random = (): IPageICommunityAiPermission.ISummary =>
    typia.random<IPageICommunityAiPermission.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: searchPermissions.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: searchPermissions.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get permission details by ID.
 *
 * This operation fetches detailed data for a unique permission identified by
 * ID. It is intended for administrative use to audit or manage system
 * permissions.
 *
 * Strict authorization limits access to administrators.
 *
 * If the specified permission ID does not exist, a not found error is returned.
 *
 * The response provides complete permission information according to the
 * schema.
 *
 * @param props.connection
 * @param props.id Unique identifier for the permission to retrieve
 * @path /communityAi/admin/permissions/:id
 * @accessor api.functional.communityAi.admin.permissions.atPermission
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atPermission(
  connection: IConnection,
  props: atPermission.Props,
): Promise<atPermission.Response> {
  return true === connection.simulate
    ? atPermission.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atPermission.METADATA,
          path: atPermission.path(props),
          status: null,
        },
      );
}
export namespace atPermission {
  export type Props = {
    /** Unique identifier for the permission to retrieve */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityAiPermission;

  export const METADATA = {
    method: "GET",
    path: "/communityAi/admin/permissions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/admin/permissions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ICommunityAiPermission =>
    typia.random<ICommunityAiPermission>();
  export const simulate = (
    connection: IConnection,
    props: atPermission.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atPermission.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a permission by ID.
 *
 * Update a permission entity by its ID in the Community AI system. Requires
 * unique permission_name and optional updated description. The operation
 * updates the existing record with new data, maintaining schema constraints and
 * validation.
 *
 * Security considerations: Only accessible to admin users.
 *
 * Errors: Returns HTTP 404 if the ID does not exist and appropriate conflict or
 * validation errors.
 *
 * Relation: Complements create and delete permission operations.
 *
 * Parameters:[{"name":"id","description":"The unique identifier of the
 * permission to update","schema":{"type":"string","format":"uuid"}}]
 *
 * @param props.connection
 * @param props.id The unique identifier of the permission to update
 * @param props.body Permission update data
 * @path /communityAi/admin/permissions/:id
 * @accessor api.functional.communityAi.admin.permissions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier of the permission to update */
    id: string & tags.Format<"uuid">;

    /** Permission update data */
    body: ICommunityAiPermission.IUpdate;
  };
  export type Body = ICommunityAiPermission.IUpdate;
  export type Response = ICommunityAiPermission;

  export const METADATA = {
    method: "PUT",
    path: "/communityAi/admin/permissions/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityAi/admin/permissions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ICommunityAiPermission =>
    typia.random<ICommunityAiPermission>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a permission by ID.
 *
 * Delete a permission by its ID. This operation removes the permission record
 * permanently from the Community AI system database. The delete is a hard
 * delete consistent with the pruning of access rights.
 *
 * Security: Only admins are authorized.
 *
 * Errors: Returns 404 if permission ID does not exist.
 *
 * This operation does not return a response body.
 *
 * @param props.connection
 * @param props.id The unique identifier of the permission to delete
 * @path /communityAi/admin/permissions/:id
 * @accessor api.functional.communityAi.admin.permissions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier of the permission to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityAi/admin/permissions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/admin/permissions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
