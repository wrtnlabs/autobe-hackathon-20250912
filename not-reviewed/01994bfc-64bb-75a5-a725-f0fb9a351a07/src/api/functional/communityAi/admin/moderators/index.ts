import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityAiModerator } from "../../../../structures/ICommunityAiModerator";
import { IPageICommunityAiModerator } from "../../../../structures/IPageICommunityAiModerator";

/**
 * Create a new moderator user record in the system. This operation takes
 * moderator creation data including email, password hash, and display name.
 *
 * It inserts the new moderator into the community_ai_moderators table with
 * associated timestamps.
 *
 * Security requires that only admin users can create new moderator accounts.
 *
 * On success, the newly created moderator's full details are returned excluding
 * sensitive login credentials like password hashes.
 *
 * Clients should validate email uniqueness and format prior to submission and
 * handle error cases such as duplicate email or invalid input gracefully.
 *
 * @param props.connection
 * @param props.body Moderator user creation data
 * @path /communityAi/admin/moderators
 * @accessor api.functional.communityAi.admin.moderators.createModerator
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createModerator(
  connection: IConnection,
  props: createModerator.Props,
): Promise<createModerator.Response> {
  return true === connection.simulate
    ? createModerator.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createModerator.METADATA,
          path: createModerator.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createModerator {
  export type Props = {
    /** Moderator user creation data */
    body: ICommunityAiModerator.ICreate;
  };
  export type Body = ICommunityAiModerator.ICreate;
  export type Response = ICommunityAiModerator;

  export const METADATA = {
    method: "POST",
    path: "/communityAi/admin/moderators",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityAi/admin/moderators";
  export const random = (): ICommunityAiModerator =>
    typia.random<ICommunityAiModerator>();
  export const simulate = (
    connection: IConnection,
    props: createModerator.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createModerator.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search moderators with filters and pagination.
 *
 * Retrieve a filtered and paginated list of moderators enabled in the system.
 * This operation supports advanced search and filtering capabilities on
 * moderator data such as email, display name, creation and update timestamps.
 *
 * The underlying database entity is community_ai_moderators. The search allows
 * clients to combine filters and pagination parameters to find specific
 * moderators or browse the moderator collection.
 *
 * Security requires the caller to have 'admin' role to access this list, given
 * the sensitivity of moderator data.
 *
 * The response returns summarized moderator information sufficient for listing
 * views, excluding full details and sensitive information such as password
 * hashes.
 *
 * @param props.connection
 * @param props.body Search and pagination criteria for moderators
 * @path /communityAi/admin/moderators
 * @accessor api.functional.communityAi.admin.moderators.indexModerators
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexModerators(
  connection: IConnection,
  props: indexModerators.Props,
): Promise<indexModerators.Response> {
  return true === connection.simulate
    ? indexModerators.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexModerators.METADATA,
          path: indexModerators.path(),
          status: null,
        },
        props.body,
      );
}
export namespace indexModerators {
  export type Props = {
    /** Search and pagination criteria for moderators */
    body: ICommunityAiModerator.IRequest;
  };
  export type Body = ICommunityAiModerator.IRequest;
  export type Response = IPageICommunityAiModerator.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityAi/admin/moderators",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityAi/admin/moderators";
  export const random = (): IPageICommunityAiModerator.ISummary =>
    typia.random<IPageICommunityAiModerator.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: indexModerators.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexModerators.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed moderator information by ID.
 *
 * Retrieve detailed information for a moderator user identified by their UUID.
 * This endpoint fetches data from the community_ai_moderators table, providing
 * moderator identity details excluding sensitive fields like password hashes.
 *
 * Access is restricted to administrative users to maintain confidentiality and
 * control over identity data.
 *
 * Clients should handle cases where the moderator ID does not exist, and verify
 * authentication and authorization prior to invoking this endpoint.
 *
 * @param props.connection
 * @param props.id Unique identifier of the moderator user to retrieve
 * @path /communityAi/admin/moderators/:id
 * @accessor api.functional.communityAi.admin.moderators.atModerator
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atModerator(
  connection: IConnection,
  props: atModerator.Props,
): Promise<atModerator.Response> {
  return true === connection.simulate
    ? atModerator.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atModerator.METADATA,
          path: atModerator.path(props),
          status: null,
        },
      );
}
export namespace atModerator {
  export type Props = {
    /** Unique identifier of the moderator user to retrieve */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityAiModerator;

  export const METADATA = {
    method: "GET",
    path: "/communityAi/admin/moderators/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/admin/moderators/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ICommunityAiModerator =>
    typia.random<ICommunityAiModerator>();
  export const simulate = (
    connection: IConnection,
    props: atModerator.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atModerator.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
