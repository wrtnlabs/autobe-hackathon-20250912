import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityAiAuditLogs } from "../../../../structures/ICommunityAiAuditLogs";
import { ICommunityAiAuditLog } from "../../../../structures/ICommunityAiAuditLog";
import { IPageICommunityAiAuditLog } from "../../../../structures/IPageICommunityAiAuditLog";

/**
 * Create a new audit log entry.
 *
 * Creates a new audit log record representing an action performed by a user,
 * admin, moderator, or system component. The operation requires identification
 * of the actor (optional member, admin, or moderator ids), an action type
 * string describing the performed event, and optional detailed description,
 * including IP and user-agent context.
 *
 * Security considerations ensure only authorized services or administrators can
 * create audit logs to maintain integrity. The audit log stores immutable
 * historical data for compliance, forensic, and monitoring purposes.
 *
 * This operation is directly linked to the community_ai_audit_logs table in the
 * Prisma schema, ensuring all mandatory fields are properly handled.
 * Timestamping and relations to users allow traceability and auditability.
 *
 * Validation ensures that provided references (ids) exist and that action types
 * conform to known log types. Errors may result from invalid references or
 * insufficient authorization.
 *
 * Related API operations include update and delete, mainly for administrative
 * reasons although audit logs generally should not be deleted.
 *
 * This endpoint returns the created audit log object for confirmation.
 *
 * @param props.connection
 * @param props.body Data to create a community AI audit log entry
 * @path /communityAi/admin/auditLogs
 * @accessor api.functional.communityAi.admin.auditLogs.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Data to create a community AI audit log entry */
    body: ICommunityAiAuditLogs.ICreate;
  };
  export type Body = ICommunityAiAuditLogs.ICreate;
  export type Response = ICommunityAiAuditLogs;

  export const METADATA = {
    method: "POST",
    path: "/communityAi/admin/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityAi/admin/auditLogs";
  export const random = (): ICommunityAiAuditLogs =>
    typia.random<ICommunityAiAuditLogs>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated list of audit logs.
 *
 * Retrieve a filtered and paginated list of audit logs for system actions and
 * events. This operation accesses the community_ai_audit_logs table in the
 * Prisma schema, which records detailed immutable entries for compliance and
 * forensic needs.
 *
 * Users with administrative roles can utilize this endpoint to monitor
 * system-wide activities including user actions, admin changes, and moderator
 * interventions.
 *
 * The request body supports advanced search and paging parameters.
 *
 * The response returns paginated audit log summaries suitable for display in
 * administrative UIs.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for audit logs
 *   filtering
 * @path /communityAi/admin/auditLogs
 * @accessor api.functional.communityAi.admin.auditLogs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search criteria and pagination parameters for audit logs filtering */
    body: ICommunityAiAuditLog.IRequest;
  };
  export type Body = ICommunityAiAuditLog.IRequest;
  export type Response = IPageICommunityAiAuditLog.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityAi/admin/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityAi/admin/auditLogs";
  export const random = (): IPageICommunityAiAuditLog.ISummary =>
    typia.random<IPageICommunityAiAuditLog.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a detailed audit log by ID.
 *
 * Retrieve detailed information about a specific audit log entry by its unique
 * identifier. The entry is sourced from the community_ai_audit_logs table in
 * the Prisma schema and contains comprehensive metadata including user and
 * admin references, action descriptions, and system context.
 *
 * The path parameter `id` should be a valid UUID corresponding to the target
 * audit log entry.
 *
 * Access to this endpoint is restricted to administrators for security and
 * privacy reasons.
 *
 * @param props.connection
 * @param props.id Unique identifier of the audit log entry
 * @path /communityAi/admin/auditLogs/:id
 * @accessor api.functional.communityAi.admin.auditLogs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the audit log entry */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityAiAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/communityAi/admin/auditLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/admin/auditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ICommunityAiAuditLog =>
    typia.random<ICommunityAiAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing audit log entry.
 *
 * Updates the specified audit log by its ID, allowing changes to
 * user/admin/moderator associations, action type, and descriptive details.
 *
 * This operation modifies immutable audit data only for legitimate maintenance
 * or correction, and should be tightly controlled.
 *
 * Invalid or missing ID leads to errors. The underlying Prisma schema enforces
 * constraints on foreign key relations and timestamp updates.
 *
 * Updates do not affect audit log integrity beyond allowed fields. Related
 * operations include creation and deletion endpoints.
 *
 * Returns the updated audit log object.
 *
 * @param props.connection
 * @param props.id Unique identifier of the target audit log entry
 * @param props.body Updated audit log data
 * @path /communityAi/admin/auditLogs/:id
 * @accessor api.functional.communityAi.admin.auditLogs.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target audit log entry */
    id: string & tags.Format<"uuid">;

    /** Updated audit log data */
    body: ICommunityAiAuditLogs.IUpdate;
  };
  export type Body = ICommunityAiAuditLogs.IUpdate;
  export type Response = ICommunityAiAuditLogs;

  export const METADATA = {
    method: "PUT",
    path: "/communityAi/admin/auditLogs/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityAi/admin/auditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ICommunityAiAuditLogs =>
    typia.random<ICommunityAiAuditLogs>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an audit log entry permanently.
 *
 * Permanently erases the specified audit log entry from the system. This action
 * removes all traces of the audit record from the storage.
 *
 * Because audit logs are critical for compliance, this action should be
 * restricted to highly privileged admins. The operation expects a valid log ID
 * and will error if the entry does not exist.
 *
 * This hard delete permanently removes the data and cannot be undone.
 *
 * Related APIs exist for creating and updating audit logs.
 *
 * No response body is returned upon successful deletion.
 *
 * @param props.connection
 * @param props.id Unique identifier of the target audit log entry
 * @path /communityAi/admin/auditLogs/:id
 * @accessor api.functional.communityAi.admin.auditLogs.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target audit log entry */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityAi/admin/auditLogs/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/admin/auditLogs/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
