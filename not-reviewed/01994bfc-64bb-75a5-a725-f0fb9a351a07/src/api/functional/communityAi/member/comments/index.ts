import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityAiComment } from "../../../../structures/ICommunityAiComment";
import { ICommunityAiComments } from "../../../../structures/ICommunityAiComments";
import { IPageICommunityAiComments } from "../../../../structures/IPageICommunityAiComments";
export * as sentimentAnalyses from "./sentimentAnalyses/index";

/**
 * Create a new comment on an existing post. The comment must include non-empty
 * body text up to 1000 characters and be attributed to a specific member as the
 * author referencing the post ID.
 *
 * This operation modifies the 'community_ai_comments' table. It is restricted
 * to authenticated members with role 'member' in the Identity namespace. Input
 * validation enforces business rules on content.
 *
 * On success, the response includes the created comment record with all
 * details.
 *
 * Errors to handle include empty body, exceeding character limits, or invalid
 * references to post or member IDs.
 *
 * @param props.connection
 * @param props.body New comment data payload
 * @path /communityAi/member/comments
 * @accessor api.functional.communityAi.member.comments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** New comment data payload */
    body: ICommunityAiComment.ICreate;
  };
  export type Body = ICommunityAiComment.ICreate;
  export type Response = ICommunityAiComment;

  export const METADATA = {
    method: "POST",
    path: "/communityAi/member/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityAi/member/comments";
  export const random = (): ICommunityAiComment =>
    typia.random<ICommunityAiComment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list comments with filters.
 *
 * Retrieve a paginated list of comments filtered by search criteria.
 *
 * Supports filters such as author id, post id, text keywords in the comment
 * body, and pagination parameters.
 *
 * Returns a paginated list of comment summary objects.
 *
 * Access restricted to authorized roles including members, moderators, and
 * admins.
 *
 * Errors returned for invalid query parameters or unauthorized access.
 *
 * This complements single comment retrieval and comment modification APIs.
 *
 * @param props.connection
 * @param props.body Search criteria including pagination and filters for
 *   comments
 * @path /communityAi/member/comments
 * @accessor api.functional.communityAi.member.comments.searchComments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function searchComments(
  connection: IConnection,
  props: searchComments.Props,
): Promise<searchComments.Response> {
  return true === connection.simulate
    ? searchComments.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...searchComments.METADATA,
          path: searchComments.path(),
          status: null,
        },
        props.body,
      );
}
export namespace searchComments {
  export type Props = {
    /** Search criteria including pagination and filters for comments */
    body: ICommunityAiComments.IRequest;
  };
  export type Body = ICommunityAiComments.IRequest;
  export type Response = IPageICommunityAiComments.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityAi/member/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityAi/member/comments";
  export const random = (): IPageICommunityAiComments.ISummary =>
    typia.random<IPageICommunityAiComments.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: searchComments.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: searchComments.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information for a comment.
 *
 * Retrieve detailed comment information by commentId.
 *
 * Returns full comment entity including body content, author, creation and
 * update timestamps, and deletion status.
 *
 * Access restricted to authorized roles (members, moderators, admins).
 *
 * Errors returned for non-existent comment or unauthorized access.
 *
 * Complements listing, update, and deletion endpoints.
 *
 * @param props.connection
 * @param props.commentId Unique comment identifier (UUID)
 * @path /communityAi/member/comments/:commentId
 * @accessor api.functional.communityAi.member.comments.atComment
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atComment(
  connection: IConnection,
  props: atComment.Props,
): Promise<atComment.Response> {
  return true === connection.simulate
    ? atComment.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atComment.METADATA,
          path: atComment.path(props),
          status: null,
        },
      );
}
export namespace atComment {
  export type Props = {
    /** Unique comment identifier (UUID) */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityAiComments;

  export const METADATA = {
    method: "GET",
    path: "/communityAi/member/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/member/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): ICommunityAiComments =>
    typia.random<ICommunityAiComments>();
  export const simulate = (
    connection: IConnection,
    props: atComment.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atComment.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a comment by ID.
 *
 * Update the content of an existing comment specified by its commentId. Edits
 * are only allowed if within the permitted one-hour window after creation.
 *
 * This operation affects the 'community_ai_comments' table. It requires
 * authentication as a member.
 *
 * Successful operation returns the updated comment entity.
 *
 * Errors occur if the comment does not exist, the edit timeframe has elapsed,
 * or if the updated content violates business rules such as empty body or
 * character limits.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment to update
 * @param props.body Updated comment data
 * @path /communityAi/member/comments/:commentId
 * @accessor api.functional.communityAi.member.comments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the comment to update */
    commentId: string;

    /** Updated comment data */
    body: ICommunityAiComment.IUpdate;
  };
  export type Body = ICommunityAiComment.IUpdate;
  export type Response = ICommunityAiComment;

  export const METADATA = {
    method: "PUT",
    path: "/communityAi/member/comments/:commentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityAi/member/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): ICommunityAiComment =>
    typia.random<ICommunityAiComment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a comment by ID.
 *
 * Permanently delete a comment by its commentId. This operation removes the
 * comment record from the database with no return content.
 *
 * Only authorized members (role 'member') can perform delete operations.
 *
 * Errors may occur if the comment does not exist or if the user lacks
 * permission.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment to delete
 * @path /communityAi/member/comments/:commentId
 * @accessor api.functional.communityAi.member.comments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the comment to delete */
    commentId: string;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityAi/member/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/member/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
