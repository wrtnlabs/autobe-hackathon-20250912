import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityAiNotificationStatus } from "../../../../../structures/ICommunityAiNotificationStatus";
import { IPageICommunityAiNotificationStatus } from "../../../../../structures/IPageICommunityAiNotificationStatus";

/**
 * Create a new status for a specific notification.
 *
 * Create a new status record for an existing notification by specifying the
 * notification ID in the path.
 *
 * This operation allows clients to track and update the lifecycle state of a
 * notification such as 'pending', 'delivered', or 'failed'.
 *
 * Permission to create notification statuses is granted to authorized
 * authenticated users managing notification workflows.
 *
 * The notificationId path parameter ensures the status is linked to a parent
 * notification in the community_ai_notifications table.
 *
 * The request body contains the status data including required status code and
 * optional descriptive details.
 *
 * The response returns the created notification status entity.
 *
 * No soft delete operations are applicable for statuses, as they are
 * append-only logs.
 *
 * Common errors include invalid notification ID, authorization failures, or
 * missing/invalid status code.
 *
 * Related endpoints include retrieving statuses for notifications and deleting
 * status entries.
 *
 * Authorization roles require one of the system's defined roles (admin,
 * moderator, member) for user context access.
 *
 * @param props.connection
 * @param props.notificationId Target notification's ID
 * @param props.body Details for the new notification status
 * @path /communityAi/member/notifications/:notificationId/statuses
 * @accessor api.functional.communityAi.member.notifications.statuses.createStatus
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createStatus(
  connection: IConnection,
  props: createStatus.Props,
): Promise<createStatus.Response> {
  return true === connection.simulate
    ? createStatus.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createStatus.METADATA,
          path: createStatus.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createStatus {
  export type Props = {
    /** Target notification's ID */
    notificationId: string & tags.Format<"uuid">;

    /** Details for the new notification status */
    body: ICommunityAiNotificationStatus.ICreate;
  };
  export type Body = ICommunityAiNotificationStatus.ICreate;
  export type Response = ICommunityAiNotificationStatus;

  export const METADATA = {
    method: "POST",
    path: "/communityAi/member/notifications/:notificationId/statuses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityAi/member/notifications/${encodeURIComponent(props.notificationId ?? "null")}/statuses`;
  export const random = (): ICommunityAiNotificationStatus =>
    typia.random<ICommunityAiNotificationStatus>();
  export const simulate = (
    connection: IConnection,
    props: createStatus.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createStatus.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List notification statuses for a specific notification.
 *
 * Retrieve paginated list of statuses related to a notification specified by
 * notificationId.
 *
 * This operation fetches historical status entries from
 * community_ai_notification_statuses.
 *
 * Path parameter notificationId is required and must be a valid UUID.
 *
 * Request body contains filtering, sorting and pagination options.
 *
 * Only authorized users with appropriate permissions can view notification
 * statuses.
 *
 * Response includes paginated list with details such as status code,
 * description, and timestamps.
 *
 * @param props.connection
 * @param props.notificationId Unique identifier of the target notification
 * @param props.body Filtering, sorting and pagination parameters for
 *   notification statuses
 * @path /communityAi/member/notifications/:notificationId/statuses
 * @accessor api.functional.communityAi.member.notifications.statuses.indexNotificationStatuses
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexNotificationStatuses(
  connection: IConnection,
  props: indexNotificationStatuses.Props,
): Promise<indexNotificationStatuses.Response> {
  return true === connection.simulate
    ? indexNotificationStatuses.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexNotificationStatuses.METADATA,
          path: indexNotificationStatuses.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace indexNotificationStatuses {
  export type Props = {
    /** Unique identifier of the target notification */
    notificationId: string & tags.Format<"uuid">;

    /**
     * Filtering, sorting and pagination parameters for notification
     * statuses
     */
    body: ICommunityAiNotificationStatus.IRequest;
  };
  export type Body = ICommunityAiNotificationStatus.IRequest;
  export type Response = IPageICommunityAiNotificationStatus;

  export const METADATA = {
    method: "PATCH",
    path: "/communityAi/member/notifications/:notificationId/statuses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityAi/member/notifications/${encodeURIComponent(props.notificationId ?? "null")}/statuses`;
  export const random = (): IPageICommunityAiNotificationStatus =>
    typia.random<IPageICommunityAiNotificationStatus>();
  export const simulate = (
    connection: IConnection,
    props: indexNotificationStatuses.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexNotificationStatuses.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed notification status information.
 *
 * Retrieve detailed information of a specific notification status by
 * notificationStatusId for the given notificationId.
 *
 * Both path parameters must be valid UUIDs.
 *
 * Operation requires user authorization to access notification status
 * information.
 *
 * Response returns the single notification status entity with all properties.
 *
 * @param props.connection
 * @param props.notificationId Unique identifier of the target notification
 * @param props.notificationStatusId Unique identifier of the notification
 *   status
 * @path /communityAi/member/notifications/:notificationId/statuses/:notificationStatusId
 * @accessor api.functional.communityAi.member.notifications.statuses.atNotificationStatus
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atNotificationStatus(
  connection: IConnection,
  props: atNotificationStatus.Props,
): Promise<atNotificationStatus.Response> {
  return true === connection.simulate
    ? atNotificationStatus.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atNotificationStatus.METADATA,
          path: atNotificationStatus.path(props),
          status: null,
        },
      );
}
export namespace atNotificationStatus {
  export type Props = {
    /** Unique identifier of the target notification */
    notificationId: string & tags.Format<"uuid">;

    /** Unique identifier of the notification status */
    notificationStatusId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityAiNotificationStatus;

  export const METADATA = {
    method: "GET",
    path: "/communityAi/member/notifications/:notificationId/statuses/:notificationStatusId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/member/notifications/${encodeURIComponent(props.notificationId ?? "null")}/statuses/${encodeURIComponent(props.notificationStatusId ?? "null")}`;
  export const random = (): ICommunityAiNotificationStatus =>
    typia.random<ICommunityAiNotificationStatus>();
  export const simulate = (
    connection: IConnection,
    props: atNotificationStatus.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atNotificationStatus.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.param("notificationStatusId")(() =>
        typia.assert(props.notificationStatusId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific notification status by ID.
 *
 * Update an existing status record for a specified notification.
 *
 * This allows clients to modify notification lifecycle statuses, such as
 * changing a status from 'pending' to 'delivered'.
 *
 * The notificationId and notificationStatusId path parameters uniquely identify
 * the status record in the community_ai_notification_statuses table.
 *
 * The request body includes updated status information with required status
 * code and optional description.
 *
 * The response returns the updated status record.
 *
 * Authorization ensures that only authenticated users with designated roles can
 * perform updates on their notification statuses.
 *
 * This operation complements status creation and deletion endpoints.
 *
 * Soft delete is not implemented as statuses represent active log entries.
 *
 * Common errors include invalid IDs, authorization failures, and validation
 * errors on input data.
 *
 * @param props.connection
 * @param props.notificationId Target notification's ID
 * @param props.notificationStatusId Target notification status's ID
 * @param props.body Updated information for the notification status
 * @path /communityAi/member/notifications/:notificationId/statuses/:notificationStatusId
 * @accessor api.functional.communityAi.member.notifications.statuses.updateStatus
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateStatus(
  connection: IConnection,
  props: updateStatus.Props,
): Promise<updateStatus.Response> {
  return true === connection.simulate
    ? updateStatus.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateStatus.METADATA,
          path: updateStatus.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateStatus {
  export type Props = {
    /** Target notification's ID */
    notificationId: string & tags.Format<"uuid">;

    /** Target notification status's ID */
    notificationStatusId: string & tags.Format<"uuid">;

    /** Updated information for the notification status */
    body: ICommunityAiNotificationStatus.IUpdate;
  };
  export type Body = ICommunityAiNotificationStatus.IUpdate;
  export type Response = ICommunityAiNotificationStatus;

  export const METADATA = {
    method: "PUT",
    path: "/communityAi/member/notifications/:notificationId/statuses/:notificationStatusId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityAi/member/notifications/${encodeURIComponent(props.notificationId ?? "null")}/statuses/${encodeURIComponent(props.notificationStatusId ?? "null")}`;
  export const random = (): ICommunityAiNotificationStatus =>
    typia.random<ICommunityAiNotificationStatus>();
  export const simulate = (
    connection: IConnection,
    props: updateStatus.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateStatus.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.param("notificationStatusId")(() =>
        typia.assert(props.notificationStatusId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a notification status record.
 *
 * Permanently remove a notification status record linked to a specific
 * notification.
 *
 * Deletion is a hard delete removing the record permanently from the database.
 *
 * The notificationId and notificationStatusId path parameters uniquely identify
 * the status record to remove.
 *
 * This operation requires authorization for admin, moderator, or member users
 * to ensure secure management.
 *
 * No content is returned upon successful deletion.
 *
 * Typical errors involve invalid IDs or permission restrictions.
 *
 * This operation complements the create and update endpoints for notification
 * statuses.
 *
 * Soft delete is not implemented for these records.
 *
 * Ensure that callers understand that deletion is permanent and irreversible.
 *
 * @param props.connection
 * @param props.notificationId Target notification's ID
 * @param props.notificationStatusId Target notification status's ID
 * @path /communityAi/member/notifications/:notificationId/statuses/:notificationStatusId
 * @accessor api.functional.communityAi.member.notifications.statuses.eraseStatus
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseStatus(
  connection: IConnection,
  props: eraseStatus.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseStatus.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseStatus.METADATA,
          path: eraseStatus.path(props),
          status: null,
        },
      );
}
export namespace eraseStatus {
  export type Props = {
    /** Target notification's ID */
    notificationId: string & tags.Format<"uuid">;

    /** Target notification status's ID */
    notificationStatusId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityAi/member/notifications/:notificationId/statuses/:notificationStatusId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityAi/member/notifications/${encodeURIComponent(props.notificationId ?? "null")}/statuses/${encodeURIComponent(props.notificationStatusId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseStatus.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseStatus.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.param("notificationStatusId")(() =>
        typia.assert(props.notificationStatusId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
