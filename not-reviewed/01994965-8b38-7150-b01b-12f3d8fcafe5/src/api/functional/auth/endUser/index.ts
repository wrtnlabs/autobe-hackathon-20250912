import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITelegramFileDownloaderEndUser } from "../../../structures/ITelegramFileDownloaderEndUser";
export * as password from "./password/index";

/**
 * Register a new endUser account in telegram_file_downloader_endusers with
 * initial token issuance.
 *
 * User registration API for end users who download Telegram channel/group files
 * via the web dashboard. Creates an account with unique email and hashed
 * password in telegram_file_downloader_endusers table. Automatically issues
 * initial JWT tokens on successful registration. Requires no prior
 * authentication and uses secure creation with validation for unique email.
 * Ensures new users are prepared for subsequent authenticated requests.
 * Integrates within the authentication flow for member-kind roles and supports
 * token issuance for session management.
 *
 * @param props.connection
 * @param props.body Request body for new endUser registration, including
 *   required email and password
 * @setHeader token.access Authorization
 *
 * @path /auth/endUser/join
 * @accessor api.functional.auth.endUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Request body for new endUser registration, including required email
     * and password
     */
    body: ITelegramFileDownloaderEndUser.ICreate;
  };
  export type Body = ITelegramFileDownloaderEndUser.ICreate;
  export type Response = ITelegramFileDownloaderEndUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/endUser/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/endUser/join";
  export const random = (): ITelegramFileDownloaderEndUser.IAuthorized =>
    typia.random<ITelegramFileDownloaderEndUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate endUser and issue JWT tokens from
 * telegram_file_downloader_endusers.
 *
 * User login API for end users enabling authentication with email and password.
 * Validates credentials against telegram_file_downloader_endusers data and
 * issues JWT tokens for session management. Endpoint allows members to obtain
 * access tokens necessary for subsequent API calls and dashboard interactions.
 * Handles security by validating password hashes without exposing
 * authentication internals.
 *
 * @param props.connection
 * @param props.body Request body containing login credentials for endUser
 * @setHeader token.access Authorization
 *
 * @path /auth/endUser/login
 * @accessor api.functional.auth.endUser.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Request body containing login credentials for endUser */
    body: ITelegramFileDownloaderEndUser.ILogin;
  };
  export type Body = ITelegramFileDownloaderEndUser.ILogin;
  export type Response = ITelegramFileDownloaderEndUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/endUser/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/endUser/login";
  export const random = (): ITelegramFileDownloaderEndUser.IAuthorized =>
    typia.random<ITelegramFileDownloaderEndUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT tokens for authenticated endUser sessions.
 *
 * Token refresh API for end users to renew JWT tokens using a valid refresh
 * token. Supports seamless session continuation and adheres to member-kind
 * authentication flow. Ensures refresh tokens are securely accepted and new
 * tokens issued without requiring login credentials repeatedly.
 *
 * @param props.connection
 * @param props.body Request body containing refresh token for endUser session
 *   renewal
 * @setHeader token.access Authorization
 *
 * @path /auth/endUser/refresh
 * @accessor api.functional.auth.endUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Request body containing refresh token for endUser session renewal */
    body: ITelegramFileDownloaderEndUser.IRefresh;
  };
  export type Body = ITelegramFileDownloaderEndUser.IRefresh;
  export type Response = ITelegramFileDownloaderEndUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/endUser/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/endUser/refresh";
  export const random = (): ITelegramFileDownloaderEndUser.IAuthorized =>
    typia.random<ITelegramFileDownloaderEndUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
