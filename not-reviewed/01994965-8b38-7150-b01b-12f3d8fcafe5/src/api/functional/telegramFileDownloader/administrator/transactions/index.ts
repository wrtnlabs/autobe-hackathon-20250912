import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITelegramFileDownloaderTransactions } from "../../../../structures/ITelegramFileDownloaderTransactions";
import { IPageITelegramFileDownloaderTransactions } from "../../../../structures/IPageITelegramFileDownloaderTransactions";

/**
 * Create a new payment transaction record.
 *
 * Create a new transaction record for a user payment. This operation stores
 * detailed metadata about the transaction including type, status, amount, and
 * timestamps.
 *
 * Only administrators or system components should invoke this endpoint to
 * record transactions accurately.
 *
 * All required fields must be validated before creation. The transaction links
 * to an existing payment and user.
 *
 * The operation returns the created transaction entity with all properties.
 *
 * @param props.connection
 * @param props.body Transaction creation payload containing payment ID, user
 *   ID, type, status, amount, and date
 * @path /telegramFileDownloader/administrator/transactions
 * @accessor api.functional.telegramFileDownloader.administrator.transactions.createTransaction
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createTransaction(
  connection: IConnection,
  props: createTransaction.Props,
): Promise<createTransaction.Response> {
  return true === connection.simulate
    ? createTransaction.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createTransaction.METADATA,
          path: createTransaction.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createTransaction {
  export type Props = {
    /**
     * Transaction creation payload containing payment ID, user ID, type,
     * status, amount, and date
     */
    body: ITelegramFileDownloaderTransactions.ICreate;
  };
  export type Body = ITelegramFileDownloaderTransactions.ICreate;
  export type Response = ITelegramFileDownloaderTransactions;

  export const METADATA = {
    method: "POST",
    path: "/telegramFileDownloader/administrator/transactions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/telegramFileDownloader/administrator/transactions";
  export const random = (): ITelegramFileDownloaderTransactions =>
    typia.random<ITelegramFileDownloaderTransactions>();
  export const simulate = (
    connection: IConnection,
    props: createTransaction.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createTransaction.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search payment transaction records with pagination.
 *
 * Retrieve a filtered and paginated list of payment transactions with support
 * for search parameters, sorting options, and pagination. This operation
 * fetches payment transaction data from telegram_file_downloader_transactions
 * used for billing audits and user transaction histories.
 *
 * The response provides a paginated container with detailed transaction
 * records, allowing administrators to review charge and refund activities.
 *
 * Security constraints restrict access to users with the 'administrator' role.
 *
 * Business rules enforce correct filtering by transaction type and status.
 *
 * Error handling ensures proper validation of search parameters and pagination
 * inputs.
 *
 * This operation does not modify data but provides essential audit information
 * for billing management.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for payment
 *   transactions
 * @path /telegramFileDownloader/administrator/transactions
 * @accessor api.functional.telegramFileDownloader.administrator.transactions.indexTransactions
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexTransactions(
  connection: IConnection,
  props: indexTransactions.Props,
): Promise<indexTransactions.Response> {
  return true === connection.simulate
    ? indexTransactions.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexTransactions.METADATA,
          path: indexTransactions.path(),
          status: null,
        },
        props.body,
      );
}
export namespace indexTransactions {
  export type Props = {
    /** Search, filter, and pagination parameters for payment transactions */
    body: ITelegramFileDownloaderTransactions.IRequest;
  };
  export type Body = ITelegramFileDownloaderTransactions.IRequest;
  export type Response = IPageITelegramFileDownloaderTransactions;

  export const METADATA = {
    method: "PATCH",
    path: "/telegramFileDownloader/administrator/transactions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/telegramFileDownloader/administrator/transactions";
  export const random = (): IPageITelegramFileDownloaderTransactions =>
    typia.random<IPageITelegramFileDownloaderTransactions>();
  export const simulate = (
    connection: IConnection,
    props: indexTransactions.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexTransactions.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve payment transaction details by transaction ID.
 *
 * Retrieve detailed information about a specific payment transaction identified
 * by transaction ID. This includes transaction status, type, authorized
 * amounts, dates, and related payment and user info.
 *
 * Access restricted to administrators due to sensitive financial data.
 *
 * It supports auditing requirements and billing reconciliation.
 *
 * Error handling returns HTTP 404 if the transaction ID is not found.
 *
 * No modification occurs in this operation; it solely returns data.
 *
 * @param props.connection
 * @param props.id Unique identifier of the payment transaction
 * @path /telegramFileDownloader/administrator/transactions/:id
 * @accessor api.functional.telegramFileDownloader.administrator.transactions.atTransaction
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atTransaction(
  connection: IConnection,
  props: atTransaction.Props,
): Promise<atTransaction.Response> {
  return true === connection.simulate
    ? atTransaction.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atTransaction.METADATA,
          path: atTransaction.path(props),
          status: null,
        },
      );
}
export namespace atTransaction {
  export type Props = {
    /** Unique identifier of the payment transaction */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ITelegramFileDownloaderTransactions;

  export const METADATA = {
    method: "GET",
    path: "/telegramFileDownloader/administrator/transactions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/telegramFileDownloader/administrator/transactions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ITelegramFileDownloaderTransactions =>
    typia.random<ITelegramFileDownloaderTransactions>();
  export const simulate = (
    connection: IConnection,
    props: atTransaction.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atTransaction.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing payment transaction record.
 *
 * Update the details of an existing payment transaction record. Only
 * administrators should perform this action.
 *
 * The transaction ID must be specified as a path parameter.
 *
 * Returns the updated transaction entity on success.
 *
 * @param props.connection
 * @param props.id The unique identifier of the transaction to update
 * @param props.body Transaction update payload with updated fields
 * @path /telegramFileDownloader/administrator/transactions/:id
 * @accessor api.functional.telegramFileDownloader.administrator.transactions.updateTransaction
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateTransaction(
  connection: IConnection,
  props: updateTransaction.Props,
): Promise<updateTransaction.Response> {
  return true === connection.simulate
    ? updateTransaction.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateTransaction.METADATA,
          path: updateTransaction.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateTransaction {
  export type Props = {
    /** The unique identifier of the transaction to update */
    id: string & tags.Format<"uuid">;

    /** Transaction update payload with updated fields */
    body: ITelegramFileDownloaderTransactions.IUpdate;
  };
  export type Body = ITelegramFileDownloaderTransactions.IUpdate;
  export type Response = ITelegramFileDownloaderTransactions;

  export const METADATA = {
    method: "PUT",
    path: "/telegramFileDownloader/administrator/transactions/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/telegramFileDownloader/administrator/transactions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ITelegramFileDownloaderTransactions =>
    typia.random<ITelegramFileDownloaderTransactions>();
  export const simulate = (
    connection: IConnection,
    props: updateTransaction.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateTransaction.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a payment transaction record.
 *
 * Permanently delete a payment transaction record by its ID. This operation
 * cannot be undone.
 *
 * Administrators only.
 *
 * No request body or response content.
 *
 * @param props.connection
 * @param props.id Unique identifier of the transaction to delete
 * @path /telegramFileDownloader/administrator/transactions/:id
 * @accessor api.functional.telegramFileDownloader.administrator.transactions.eraseTransaction
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseTransaction(
  connection: IConnection,
  props: eraseTransaction.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseTransaction.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseTransaction.METADATA,
          path: eraseTransaction.path(props),
          status: null,
        },
      );
}
export namespace eraseTransaction {
  export type Props = {
    /** Unique identifier of the transaction to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/telegramFileDownloader/administrator/transactions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/telegramFileDownloader/administrator/transactions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseTransaction.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseTransaction.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
