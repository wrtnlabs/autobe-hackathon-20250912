import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITelegramFileDownloaderJobQueue } from "../../../../structures/ITelegramFileDownloaderJobQueue";
import { IPageITelegramFileDownloaderJobQueue } from "../../../../structures/IPageITelegramFileDownloaderJobQueue";

/**
 * Enqueue a new file download job in job queue.
 *
 * Create a new job queue entry to enqueue a file download job for processing.
 * The request includes job ID, priority, status, optional retry count, and
 * error message.
 *
 * This enables asynchronous processing of file downloads requested by users or
 * developers.
 *
 * Security requires administrator role authorization.
 *
 * Errors on duplicate job IDs or invalid data trigger rejection with
 * informative messages.
 *
 * @param props.connection
 * @param props.body Information required to create a new job queue entry
 * @path /telegramFileDownloader/administrator/jobQueues
 * @accessor api.functional.telegramFileDownloader.administrator.jobQueues.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Information required to create a new job queue entry */
    body: ITelegramFileDownloaderJobQueue.ICreate;
  };
  export type Body = ITelegramFileDownloaderJobQueue.ICreate;
  export type Response = ITelegramFileDownloaderJobQueue;

  export const METADATA = {
    method: "POST",
    path: "/telegramFileDownloader/administrator/jobQueues",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/telegramFileDownloader/administrator/jobQueues";
  export const random = (): ITelegramFileDownloaderJobQueue =>
    typia.random<ITelegramFileDownloaderJobQueue>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated list of job queues.
 *
 * Retrieve a filtered and paginated list of job queues from the
 * telegram_file_downloader_job_queues table. This operation allows system
 * administrators or monitoring services to view current job statuses including
 * pending, processing, failed, or completed jobs. It supports filtering by
 * status and priority, searching by last error messages, and sorting by
 * creation or update timestamps.
 *
 * Security considerations include restricted access to authorized roles only
 * due to sensitivity of operational data. The response includes essential job
 * metadata such as priority levels and retry counts.
 *
 * This operation integrates with the job queue management to enable effective
 * tracking and management of asynchronous file download processing. Typical
 * clients are admin dashboards or automated maintenance scripts.
 *
 * Errors include invalid filter criteria or parameter violations resulting in
 * rejection with appropriate error codes.
 *
 * @param props.connection
 * @param props.body Filtering, sorting, paging criteria for job queues
 *   retrieval
 * @path /telegramFileDownloader/administrator/jobQueues
 * @accessor api.functional.telegramFileDownloader.administrator.jobQueues.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filtering, sorting, paging criteria for job queues retrieval */
    body: ITelegramFileDownloaderJobQueue.IRequest;
  };
  export type Body = ITelegramFileDownloaderJobQueue.IRequest;
  export type Response = IPageITelegramFileDownloaderJobQueue.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/telegramFileDownloader/administrator/jobQueues",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/telegramFileDownloader/administrator/jobQueues";
  export const random = (): IPageITelegramFileDownloaderJobQueue.ISummary =>
    typia.random<IPageITelegramFileDownloaderJobQueue.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed job queue information by ID.
 *
 * Fetch detailed information of a job queue entry by ID from
 * telegram_file_downloader_job_queues table. The detailed view includes status,
 * priority, number of retries, last error message, and timestamps for creation
 * and updates.
 *
 * This helps administrators or background services to examine specific jobs in
 * the download processing queue for troubleshooting or audit purposes.
 *
 * Security is maintained by restricting access to administrator roles.
 *
 * Invalid or non-existent IDs will result in 404 Not Found responses.
 * Appropriate error handling is included for malformed UUIDs.
 *
 * @param props.connection
 * @param props.id Unique identifier of the job queue entry
 * @path /telegramFileDownloader/administrator/jobQueues/:id
 * @accessor api.functional.telegramFileDownloader.administrator.jobQueues.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the job queue entry */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ITelegramFileDownloaderJobQueue;

  export const METADATA = {
    method: "GET",
    path: "/telegramFileDownloader/administrator/jobQueues/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/telegramFileDownloader/administrator/jobQueues/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ITelegramFileDownloaderJobQueue =>
    typia.random<ITelegramFileDownloaderJobQueue>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update job queue entry by ID.
 *
 * Update existing job queue entry by ID. Modifiable fields include status,
 * priority, retries, and last error message.
 *
 * This operation allows administrators or system processes to manage the
 * lifecycle of download jobs in the queue.
 *
 * Security and data integrity are enforced through role-based authorization and
 * parameter validation.
 *
 * Appropriate error handling covers invalid IDs or malformed data submissions.
 *
 * @param props.connection
 * @param props.id Unique identifier of the job queue entry to update
 * @param props.body Fields to update in the job queue entry
 * @path /telegramFileDownloader/administrator/jobQueues/:id
 * @accessor api.functional.telegramFileDownloader.administrator.jobQueues.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the job queue entry to update */
    id: string & tags.Format<"uuid">;

    /** Fields to update in the job queue entry */
    body: ITelegramFileDownloaderJobQueue.IUpdate;
  };
  export type Body = ITelegramFileDownloaderJobQueue.IUpdate;
  export type Response = ITelegramFileDownloaderJobQueue;

  export const METADATA = {
    method: "PUT",
    path: "/telegramFileDownloader/administrator/jobQueues/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/telegramFileDownloader/administrator/jobQueues/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ITelegramFileDownloaderJobQueue =>
    typia.random<ITelegramFileDownloaderJobQueue>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a job queue entry by ID to remove the download job from the queue.
 *
 * This DELETE API operation permanently removes a job queue record from the
 * system. Job queues manage file download tasks for Telegram channel/group
 * downloads. Removing a job queue entry is typically performed by system
 * administrators or automated cleanup processes to discard stale or completed
 * jobs.
 *
 * This operation requires the job queue ID to uniquely identify which record to
 * remove. It does not accept a request body and does not return any content on
 * success. Given the criticality of job queues to download processing, only
 * authorized users with administrative privileges should be allowed to invoke
 * this endpoint.
 *
 * Removing the queue entry will ensure that the download job will no longer be
 * processed or retried by the system. This is a hard delete operation removing
 * the record fully from the database without a soft delete timestamp.
 *
 * Appropriate error handling should return a not found status if the job ID
 * does not exist, and proper authorization checks must be implemented to
 * restrict access.
 *
 * The 'telegram_file_downloader_job_queues' table in the database backs this
 * API, containing details like job ID, status, priority, and retry counts.
 *
 * @param props.connection
 * @param props.id Unique identifier of the job queue entry to delete
 * @path /telegramFileDownloader/administrator/jobQueues/:id
 * @accessor api.functional.telegramFileDownloader.administrator.jobQueues.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the job queue entry to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/telegramFileDownloader/administrator/jobQueues/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/telegramFileDownloader/administrator/jobQueues/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
