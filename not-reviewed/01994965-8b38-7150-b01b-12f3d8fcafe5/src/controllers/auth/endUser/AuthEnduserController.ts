import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthEndUserJoin } from "../../../providers/postauthEndUserJoin";
import { EnduserAuth } from "../../../decorators/EnduserAuth";
import { EnduserPayload } from "../../../decorators/payload/EnduserPayload";
import { postauthEndUserLogin } from "../../../providers/postauthEndUserLogin";
import { postauthEndUserRefresh } from "../../../providers/postauthEndUserRefresh";

import { ITelegramFileDownloaderEndUser } from "../../../api/structures/ITelegramFileDownloaderEndUser";

@Controller("/auth/endUser")
export class AuthEnduserController {
  /**
   * Register a new endUser account in telegram_file_downloader_endusers with
   * initial token issuance.
   *
   * User registration API for end users who download Telegram channel/group
   * files via the web dashboard. Creates an account with unique email and
   * hashed password in telegram_file_downloader_endusers table. Automatically
   * issues initial JWT tokens on successful registration. Requires no prior
   * authentication and uses secure creation with validation for unique email.
   * Ensures new users are prepared for subsequent authenticated requests.
   * Integrates within the authentication flow for member-kind roles and
   * supports token issuance for session management.
   *
   * @param connection
   * @param body Request body for new endUser registration, including required
   *   email and password
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @EnduserAuth()
    endUser: EnduserPayload,
    @TypedBody()
    body: ITelegramFileDownloaderEndUser.ICreate,
  ): Promise<ITelegramFileDownloaderEndUser.IAuthorized> {
    try {
      return await postauthEndUserJoin({
        endUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate endUser and issue JWT tokens from
   * telegram_file_downloader_endusers.
   *
   * User login API for end users enabling authentication with email and
   * password. Validates credentials against telegram_file_downloader_endusers
   * data and issues JWT tokens for session management. Endpoint allows members
   * to obtain access tokens necessary for subsequent API calls and dashboard
   * interactions. Handles security by validating password hashes without
   * exposing authentication internals.
   *
   * @param connection
   * @param body Request body containing login credentials for endUser
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @EnduserAuth()
    endUser: EnduserPayload,
    @TypedBody()
    body: ITelegramFileDownloaderEndUser.ILogin,
  ): Promise<ITelegramFileDownloaderEndUser.IAuthorized> {
    try {
      return await postauthEndUserLogin({
        endUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh JWT tokens for authenticated endUser sessions.
   *
   * Token refresh API for end users to renew JWT tokens using a valid refresh
   * token. Supports seamless session continuation and adheres to member-kind
   * authentication flow. Ensures refresh tokens are securely accepted and new
   * tokens issued without requiring login credentials repeatedly.
   *
   * @param connection
   * @param body Request body containing refresh token for endUser session
   *   renewal
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @EnduserAuth()
    endUser: EnduserPayload,
    @TypedBody()
    body: ITelegramFileDownloaderEndUser.IRefresh,
  ): Promise<ITelegramFileDownloaderEndUser.IAuthorized> {
    try {
      return await postauthEndUserRefresh({
        endUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
