import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentSystemAdmin } from "../../../structures/IAtsRecruitmentSystemAdmin";

/**
 * Register a new system administrator (ats_recruitment_systemadmins table) and
 * issue JWT tokens.
 *
 * This operation enables the registration of a new system administrator for the
 * ATS recruitment platform.
 *
 * It uses the 'ats_recruitment_systemadmins' table where each administrator is
 * uniquely identified by their email. The registration process requires the
 * email, password hash (stored securely), and name. You may optionally define
 * 'super_admin' to grant full environment access. On success, an authorization
 * token set is issued to the new admin.
 *
 * This is the main entry point for platform administrator onboarding, ensuring
 * full auditing and separation of duties per compliance rules. Email uniqueness
 * and password strength validation are mandatory, and registration attempts
 * should result in appropriate audit trail records in the system. The endpoint
 * is public to allow invitation-based or first-time bootstrap of administrator,
 * but the use is subject to additional manual approval steps in the business
 * process.
 *
 * Security is paramount: never store plaintext passwords; only a strong
 * cryptographic hash. The response returns the authorized admin record and JWT
 * token set conforming to strict authentication schema.
 *
 * Related endpoints: admin login (for existing accounts), admin token refresh,
 * and admin deactivation/approval by super admins.
 *
 * @param props.connection
 * @param props.body Administrator registration data
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/join
 * @accessor api.functional.auth.systemAdmin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Administrator registration data */
    body: IAtsRecruitmentSystemAdmin.IJoin;
  };
  export type Body = IAtsRecruitmentSystemAdmin.IJoin;
  export type Response = IAtsRecruitmentSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/join";
  export const random = (): IAtsRecruitmentSystemAdmin.IAuthorized =>
    typia.random<IAtsRecruitmentSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate admin account and return tokens (ats_recruitment_systemadmins).
 *
 * This operation authenticates a system administrator by validating the email
 * and password hash against the 'ats_recruitment_systemadmins' table.
 *
 * It ensures the provided email exists, password_hash matches, and the account
 * is both active (is_active=true) and not soft-deleted (deleted_at=null).
 * Password must be provided as a secure hash; plaintext passwords are never
 * accepted or stored. Failed or successful attempts are logged in the audit
 * system for compliance.
 *
 * On success, issues a full JWT token set for access and refresh, allowing the
 * admin to access privileged parts of the ATS system. Non-existent accounts,
 * disabled users, and deleted records must return appropriate errors. Responses
 * include the admin's core record and tokens in the
 * 'IAtsRecruitmentSystemAdmin.IAuthorized' structure.
 *
 * Security: Always use timing-safe comparisons for hashes. Abuse prevention if
 * login failed multiple times.
 *
 * Related endpoints: admin registration, admin token refresh, admin password
 * reset if recovery is needed.
 *
 * @param props.connection
 * @param props.body Admin login credentials
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/login
 * @accessor api.functional.auth.systemAdmin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Admin login credentials */
    body: IAtsRecruitmentSystemAdmin.ILogin;
  };
  export type Body = IAtsRecruitmentSystemAdmin.ILogin;
  export type Response = IAtsRecruitmentSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/login";
  export const random = (): IAtsRecruitmentSystemAdmin.IAuthorized =>
    typia.random<IAtsRecruitmentSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh admin JWT tokens using a valid refresh token
 * (ats_recruitment_systemadmins).
 *
 * Renews JWT tokens for authenticated ATS system administrators based on a
 * valid, existing refresh token.
 *
 * Refers to the 'ats_recruitment_systemadmins' table and confirms the
 * associated admin account is both enabled and not soft-deleted
 * (is_active=true, deleted_at=null). Refresh tokens are checked for validity,
 * freshness, and revocation in accordance with ATS security policies.
 *
 * On successful verification, generates and returns updated access and refresh
 * tokens, plus the admin profile entity. Facilitates continual secure admin
 * privilege without need for password re-entry. If the refresh token is
 * invalid, expired, or for an inactive/deleted account, returns an error
 * response.
 *
 * Audit and security compliance is strictly enforced on every token refresh.
 * Tokens use standard JWT structure configured for ATS system admin role.
 *
 * Related endpoints: admin login (for new authentication), registration (for
 * onboarding new admins).
 *
 * @param props.connection
 * @param props.body Refresh token submission body
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/refresh
 * @accessor api.functional.auth.systemAdmin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token submission body */
    body: IAtsRecruitmentSystemAdmin.IRefresh;
  };
  export type Body = IAtsRecruitmentSystemAdmin.IRefresh;
  export type Response = IAtsRecruitmentSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/refresh";
  export const random = (): IAtsRecruitmentSystemAdmin.IAuthorized =>
    typia.random<IAtsRecruitmentSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
