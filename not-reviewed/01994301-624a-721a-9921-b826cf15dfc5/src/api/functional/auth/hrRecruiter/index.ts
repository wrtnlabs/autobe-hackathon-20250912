import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentHrRecruiter } from "../../../structures/IAtsRecruitmentHrRecruiter";

/**
 * Register (join) as an HR recruiter using ats_recruitment_hrrecruiters schema.
 *
 * This endpoint registers a new HR recruiter by creating a unique account in
 * the ats_recruitment_hrrecruiters table. It requires the applicant to provide
 * an email (must be unique), a plaintext password (stored as a hash), and other
 * core fields such as name and optionally department, as defined in the schema.
 * The API validates email uniqueness based on the unique constraint in the
 * table. Upon successful registration, the operation creates an active HR
 * recruiter account with is_active set to true, allowing access to recruitment
 * management features. Security considerations include password hashing and
 * account activation status. If an email already exists or a required field is
 * missing, the operation returns an error. This operation is foundationalâ€”other
 * auth flows (login, token refresh) require a prior join, and is thus an
 * entry-point into the ATS system for HR users. Passwords must never be
 * returned in the response or stored in plaintext. On success, returns an
 * IAtsRecruitmentHrRecruiter.IAuthorized DTO which includes the full
 * information required for client-side session management.
 *
 * @param props.connection
 * @param props.body New HR recruiter registration form input.
 * @setHeader token.access Authorization
 *
 * @path /auth/hrRecruiter/join
 * @accessor api.functional.auth.hrRecruiter.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** New HR recruiter registration form input. */
    body: IAtsRecruitmentHrRecruiter.IJoin;
  };
  export type Body = IAtsRecruitmentHrRecruiter.IJoin;
  export type Response = IAtsRecruitmentHrRecruiter.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/hrRecruiter/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/hrRecruiter/join";
  export const random = (): IAtsRecruitmentHrRecruiter.IAuthorized =>
    typia.random<IAtsRecruitmentHrRecruiter.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Login for HR recruiter using ats_recruitment_hrrecruiters table.
 *
 * Allows an HR recruiter to authenticate using their unique email and plaintext
 * password. The email is checked for existence in the
 * ats_recruitment_hrrecruiters table, and passwords are hashed for secure
 * comparison against password_hash. Login is rejected if is_active is false or
 * deleted_at is not null. All events, including both successful and failed
 * login attempts, are logged in ats_recruitment_actor_login_histories, as per
 * security and audit requirements. Repeated failed logins may trigger account
 * lockout (policy enforced using login history and not shown in this API
 * directly). Security ensures passwords are never exposed outside the API
 * boundary. The API issues new JWT tokens containing userId, role, and
 * permissions, enabling the recruiter to carry out their recruitment
 * operations. This operation is part of the core authentication lifecycle for
 * members, and a successful join is mandatory before login. Associated
 * endpoints: join (registration), refresh (token renewal).
 *
 * @param props.connection
 * @param props.body HR recruiter login request (email, password).
 * @setHeader token.access Authorization
 *
 * @path /auth/hrRecruiter/login
 * @accessor api.functional.auth.hrRecruiter.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** HR recruiter login request (email, password). */
    body: IAtsRecruitmentHrRecruiter.ILogin;
  };
  export type Body = IAtsRecruitmentHrRecruiter.ILogin;
  export type Response = IAtsRecruitmentHrRecruiter.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/hrRecruiter/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/hrRecruiter/login";
  export const random = (): IAtsRecruitmentHrRecruiter.IAuthorized =>
    typia.random<IAtsRecruitmentHrRecruiter.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * JWT token refresh for HR recruiter using ats_recruitment_hrrecruiters.
 *
 * Refreshes the JWT access token for an HR recruiter using a valid refresh
 * token. The system consults the ats_recruitment_hrrecruiters table, verifying
 * the user's is_active status and that deleted_at is null. The token is
 * extended or replaced, granting continued access to all privileges held at the
 * time of refresh according to their role. The operation never returns or
 * re-validates credentials. If the account is disabled or deleted, the
 * operation fails. All refresh attempts and results may be logged for audit
 * purposes per compliance best practices. Other APIs in the authentication
 * workflow (join, login) are required for initial registration and gaining
 * refresh token eligibility. On success, returns
 * IAtsRecruitmentHrRecruiter.IAuthorized with updated session info and
 * access/refresh tokens.
 *
 * @param props.connection
 * @param props.body Refresh token operation (requires valid refresh token).
 * @setHeader token.access Authorization
 *
 * @path /auth/hrRecruiter/refresh
 * @accessor api.functional.auth.hrRecruiter.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token operation (requires valid refresh token). */
    body: IAtsRecruitmentHrRecruiter.IRefresh;
  };
  export type Body = IAtsRecruitmentHrRecruiter.IRefresh;
  export type Response = IAtsRecruitmentHrRecruiter.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/hrRecruiter/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/hrRecruiter/refresh";
  export const random = (): IAtsRecruitmentHrRecruiter.IAuthorized =>
    typia.random<IAtsRecruitmentHrRecruiter.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
