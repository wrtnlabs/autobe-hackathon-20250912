import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentResumeAiAnalysis } from "../../../../../structures/IAtsRecruitmentResumeAiAnalysis";
import { IPageIAtsRecruitmentResumeAiAnalysis } from "../../../../../structures/IPageIAtsRecruitmentResumeAiAnalysis";

/**
 * Create new AI/NLP analysis job for a resume
 * (ats_recruitment_resume_ai_analyses).
 *
 * Initiate a new AI analysis for a resume. This endpoint allows the
 * authenticated applicant (resume owner) or a privileged HR recruiter or
 * technical reviewer to request a fresh AI/NLP/skill-extraction job for the
 * provided resume. The data includes analysis_type (e.g., "basic_ocr",
 * "ai_skill_match"), expected input metadata, and source tracking as defined in
 * the ats_recruitment_resume_ai_analyses schema.
 *
 * Upon validation, the system creates a new analysis job record which is
 * processed asynchronously. The endpoint ensures only authorized actors (owner
 * HR/tech reviewer) can schedule new analyses. Typical use cases include
 * re-running failed/older analyses, forcibly updating skills or contact
 * parsing, or batch-processing resumes. Business rules govern maximum frequency
 * and enforce audit logging.
 *
 * On success, the response returns the detailed created job record, including
 * status, type, and analysis metadata. Errors include unauthorized access or
 * business rule violations (e.g., repeated requests too soon).
 *
 * @param props.connection
 * @param props.resumeId UUID of the target resume to analyze
 * @param props.body Data specifying analysis type and initial options for
 *   launching an AI parsing job
 * @path /atsRecruitment/hrRecruiter/resumes/:resumeId/aiAnalyses
 * @accessor api.functional.atsRecruitment.hrRecruiter.resumes.aiAnalyses.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** UUID of the target resume to analyze */
    resumeId: string & tags.Format<"uuid">;

    /**
     * Data specifying analysis type and initial options for launching an AI
     * parsing job
     */
    body: IAtsRecruitmentResumeAiAnalysis.ICreate;
  };
  export type Body = IAtsRecruitmentResumeAiAnalysis.ICreate;
  export type Response = IAtsRecruitmentResumeAiAnalysis;

  export const METADATA = {
    method: "POST",
    path: "/atsRecruitment/hrRecruiter/resumes/:resumeId/aiAnalyses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/hrRecruiter/resumes/${encodeURIComponent(props.resumeId ?? "null")}/aiAnalyses`;
  export const random = (): IAtsRecruitmentResumeAiAnalysis =>
    typia.random<IAtsRecruitmentResumeAiAnalysis>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("resumeId")(() => typia.assert(props.resumeId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve/paginate AI/automation analysis jobs for a particular applicant
 * resume (ats_recruitment_resume_ai_analyses).
 *
 * This API operation allows retrieval of a filtered and paginated set of AI
 * analysis and parsing results associated with a specific resume. Examples of
 * recorded analysis jobs include initial OCR, named entity recognition,
 * extracted skills, education, experience summaries, and AI-driven tech stack
 * matching.
 *
 * Applicants and authorized HR users can use this API to view the current
 * analysis state, check for failures, and obtain details about individual
 * AI/automation jobs run on a resume. It supports advanced searching and
 * pagination for efficient UX even in high-frequency re-analysis scenarios
 * (such as repeated OCR or skill extraction attempts).
 *
 * Access is restricted to the resume's owner (applicant) and authorized HR
 * personnel. Error scenarios include non-existing resume references,
 * authorization violations, or malformed query parameters. Each entry provides
 * job status, results, meta information, and audit fields for debugging,
 * compliance, or human verification.
 *
 * @param props.connection
 * @param props.resumeId The unique identifier of the resume for which to
 *   retrieve AI analysis jobs.
 * @param props.body Request body filter/sort/pagination criteria for listing
 *   resume AI analyses.
 * @path /atsRecruitment/hrRecruiter/resumes/:resumeId/aiAnalyses
 * @accessor api.functional.atsRecruitment.hrRecruiter.resumes.aiAnalyses.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * The unique identifier of the resume for which to retrieve AI analysis
     * jobs.
     */
    resumeId: string & tags.Format<"uuid">;

    /**
     * Request body filter/sort/pagination criteria for listing resume AI
     * analyses.
     */
    body: IAtsRecruitmentResumeAiAnalysis.IRequest;
  };
  export type Body = IAtsRecruitmentResumeAiAnalysis.IRequest;
  export type Response = IPageIAtsRecruitmentResumeAiAnalysis;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/hrRecruiter/resumes/:resumeId/aiAnalyses",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/hrRecruiter/resumes/${encodeURIComponent(props.resumeId ?? "null")}/aiAnalyses`;
  export const random = (): IPageIAtsRecruitmentResumeAiAnalysis =>
    typia.random<IPageIAtsRecruitmentResumeAiAnalysis>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("resumeId")(() => typia.assert(props.resumeId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a specific resume AI analysis
 * (ats_recruitment_resume_ai_analyses).
 *
 * Retrieve details of a single AI analysis result for a given resume. This
 * endpoint provides the parsed AI/NLP processing information, including type,
 * status, original and result payloads, and analytics confidence scores
 * directly from the ats_recruitment_resume_ai_analyses schema.
 *
 * Security checks ensure the resumeId and aiAnalysisId are correctly related,
 * attached to an accessible resume, and the analysis has not been soft-deleted.
 * Only authorized applicants (owners), HR recruiters, or tech reviewers can
 * invoke this operation, in accordance with access policies.
 *
 * Business logic validates the association between resume and analysis,
 * returning all relevant information fields as stored. On error or unauthorized
 * attempts, a 404 or 403 response is returned. This endpoint is frequently used
 * with the operations for listing analyses on a resume or rerunning automated
 * parsing workflows.
 *
 * Response includes type, OCR/AI job metadata, request/result JSON, confidence
 * score, status (pending, completed, failed), and timestamp fields for the
 * requested analysis entry.
 *
 * @param props.connection
 * @param props.resumeId Unique identifier of the resume being analyzed
 * @param props.aiAnalysisId UUID of the AI analysis record to retrieve for this
 *   resume
 * @path /atsRecruitment/hrRecruiter/resumes/:resumeId/aiAnalyses/:aiAnalysisId
 * @accessor api.functional.atsRecruitment.hrRecruiter.resumes.aiAnalyses.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the resume being analyzed */
    resumeId: string & tags.Format<"uuid">;

    /** UUID of the AI analysis record to retrieve for this resume */
    aiAnalysisId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentResumeAiAnalysis;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/hrRecruiter/resumes/:resumeId/aiAnalyses/:aiAnalysisId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/hrRecruiter/resumes/${encodeURIComponent(props.resumeId ?? "null")}/aiAnalyses/${encodeURIComponent(props.aiAnalysisId ?? "null")}`;
  export const random = (): IAtsRecruitmentResumeAiAnalysis =>
    typia.random<IAtsRecruitmentResumeAiAnalysis>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("resumeId")(() => typia.assert(props.resumeId));
      assert.param("aiAnalysisId")(() => typia.assert(props.aiAnalysisId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a resume AI analysis record (ats_recruitment_resume_ai_analyses).
 *
 * Update (patch) limited fields of an existing AI analysis result for a resume.
 * Only authorized HR recruiters or tech reviewers can perform this operation,
 * and only on analyses that are not already finalized or soft-deleted.
 *
 * Editable fields may include reviewer notes or status corrections, but not the
 * main input/output AI analysis fields. Business logic strictly controls update
 * permissions and logs every change for compliance audit. Attempting to modify
 * non-editable fields or analyses linked to deleted resumes will result in
 * error.
 *
 * The response returns the updated AI analysis record, showing only the allowed
 * modifications and current persisted values.
 *
 * @param props.connection
 * @param props.resumeId UUID of the resume containing the analysis to update
 * @param props.aiAnalysisId ID of the specific AI analysis entry to update
 * @param props.body Values to patch for the targeted AI analysis record; only
 *   permitted fields are accepted
 * @path /atsRecruitment/hrRecruiter/resumes/:resumeId/aiAnalyses/:aiAnalysisId
 * @accessor api.functional.atsRecruitment.hrRecruiter.resumes.aiAnalyses.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the resume containing the analysis to update */
    resumeId: string & tags.Format<"uuid">;

    /** ID of the specific AI analysis entry to update */
    aiAnalysisId: string & tags.Format<"uuid">;

    /**
     * Values to patch for the targeted AI analysis record; only permitted
     * fields are accepted
     */
    body: IAtsRecruitmentResumeAiAnalysis.IUpdate;
  };
  export type Body = IAtsRecruitmentResumeAiAnalysis.IUpdate;
  export type Response = IAtsRecruitmentResumeAiAnalysis;

  export const METADATA = {
    method: "PUT",
    path: "/atsRecruitment/hrRecruiter/resumes/:resumeId/aiAnalyses/:aiAnalysisId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/hrRecruiter/resumes/${encodeURIComponent(props.resumeId ?? "null")}/aiAnalyses/${encodeURIComponent(props.aiAnalysisId ?? "null")}`;
  export const random = (): IAtsRecruitmentResumeAiAnalysis =>
    typia.random<IAtsRecruitmentResumeAiAnalysis>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("resumeId")(() => typia.assert(props.resumeId));
      assert.param("aiAnalysisId")(() => typia.assert(props.aiAnalysisId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a resume AI analysis record
 * (ats_recruitment_resume_ai_analyses).
 *
 * Permanently remove a specific AI analysis record linked to a resume. The
 * operation targets the ats_recruitment_resume_ai_analyses table, deleting the
 * specified analysis (by aiAnalysisId) if it is associated with the provided
 * resumeId and not currently under audit lock or soft-deleted.
 *
 * This endpoint can only be performed by authorized HR recruiters or tech
 * reviewers and may require additional business rule checks on compliance,
 * audit retention, or process state. If the delete is blocked due to policy, a
 * descriptive error is returned.
 *
 * Related non-delete operations include analysis retrieval, creation, and
 * update as part of resume/AI pipeline management.
 *
 * @param props.connection
 * @param props.resumeId UUID of the parent resume for which to erase the AI
 *   analysis record
 * @param props.aiAnalysisId ID of the resume AI analysis record to delete
 * @path /atsRecruitment/hrRecruiter/resumes/:resumeId/aiAnalyses/:aiAnalysisId
 * @accessor api.functional.atsRecruitment.hrRecruiter.resumes.aiAnalyses.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the parent resume for which to erase the AI analysis record */
    resumeId: string & tags.Format<"uuid">;

    /** ID of the resume AI analysis record to delete */
    aiAnalysisId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/atsRecruitment/hrRecruiter/resumes/:resumeId/aiAnalyses/:aiAnalysisId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/hrRecruiter/resumes/${encodeURIComponent(props.resumeId ?? "null")}/aiAnalyses/${encodeURIComponent(props.aiAnalysisId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("resumeId")(() => typia.assert(props.resumeId));
      assert.param("aiAnalysisId")(() => typia.assert(props.aiAnalysisId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
