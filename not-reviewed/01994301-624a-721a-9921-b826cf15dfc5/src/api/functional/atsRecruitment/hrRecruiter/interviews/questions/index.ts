import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentInterviewQuestion } from "../../../../../structures/IAtsRecruitmentInterviewQuestion";
import { IPageIAtsRecruitmentInterviewQuestion } from "../../../../../structures/IPageIAtsRecruitmentInterviewQuestion";

/**
 * Retrieve a specific interview question for a given interview from
 * ats_recruitment_interview_questions.
 *
 * Retrieve a specific interview question assigned to a particular interview.
 * This operation is used by HR recruiters, tech reviewers, or an applicant
 * participant (when permitted) to access the detailed content and properties of
 * an interview question as configured for a scheduled or historical interview
 * in the recruitment process.
 *
 * The endpoint validates both the interviewId and questionId path parameters,
 * ensuring correct association (questionId must belong to interviewId). Content
 * includes question order, type (e.g., behavioral, technical, coding), actual
 * question text, and template/manual status. Role-based authorization is
 * enforced ( only hrRecruiter and techReviewer can access any interview's
 * questions, while applicants may only view their assigned interview's
 * questions, subject to further security policies).
 *
 * The implementation must ensure secure handling, as some questions may contain
 * sensitive assessment information or AI-generated content. Related operations
 * include listing all questions for an interview, creating additional questions
 * (for HR/techReviewer only), and updating interview question content (where
 * permitted).
 *
 * @param props.connection
 * @param props.interviewId UUID of the interview containing the question.
 * @param props.questionId UUID of the interview question to retrieve.
 * @path /atsRecruitment/hrRecruiter/interviews/:interviewId/questions/:questionId
 * @accessor api.functional.atsRecruitment.hrRecruiter.interviews.questions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the interview containing the question. */
    interviewId: string & tags.Format<"uuid">;

    /** UUID of the interview question to retrieve. */
    questionId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentInterviewQuestion;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/hrRecruiter/interviews/:interviewId/questions/:questionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/hrRecruiter/interviews/${encodeURIComponent(props.interviewId ?? "null")}/questions/${encodeURIComponent(props.questionId ?? "null")}`;
  export const random = (): IAtsRecruitmentInterviewQuestion =>
    typia.random<IAtsRecruitmentInterviewQuestion>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("interviewId")(() => typia.assert(props.interviewId));
      assert.param("questionId")(() => typia.assert(props.questionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific interview question for a given interview session
 * (ats_recruitment_interview_questions).
 *
 * This API endpoint allows HR recruiters or authorized users to update the
 * content or metadata of a specific interview question, given its unique
 * question ID and parent interview ID. The target table is
 * ats_recruitment_interview_questions, which stores individual questions
 * assigned to an interview instance for an applicant.
 *
 * Updates can include the question text, its type (such as technical or
 * behavioral), template status, or its display order during the interview. The
 * operation checks user roles to ensure only permitted HR or technical
 * reviewers can modify questions. Each update is automatically logged for
 * traceability and audit trail compliance, which is essential for ATS systems
 * that must support audit-ready processes.
 *
 * Appropriate validation is performed to ensure the referenced interview and
 * question IDs exist, the user has the correct permissions, and no state
 * constraints (e.g., interview already completed) are violated. Related
 * endpoints, such as assigning new questions or retrieving the interview's full
 * question list, may be used together with this operation to provide a
 * comprehensive interview workflow.
 *
 * Error responses are returned if the requested question or interview do not
 * exist, if the user lacks authorization, or if the update would violate
 * business rules (such as editing a locked/completed interview). All changes
 * are tracked for audit and rollback if necessary.
 *
 * @param props.connection
 * @param props.interviewId Unique identifier of the target interview session
 * @param props.questionId Unique identifier of the interview question to update
 * @param props.body Updated information for the interview question, including
 *   text, order, type, etc
 * @path /atsRecruitment/hrRecruiter/interviews/:interviewId/questions/:questionId
 * @accessor api.functional.atsRecruitment.hrRecruiter.interviews.questions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target interview session */
    interviewId: string & tags.Format<"uuid">;

    /** Unique identifier of the interview question to update */
    questionId: string & tags.Format<"uuid">;

    /**
     * Updated information for the interview question, including text,
     * order, type, etc
     */
    body: IAtsRecruitmentInterviewQuestion.IUpdate;
  };
  export type Body = IAtsRecruitmentInterviewQuestion.IUpdate;
  export type Response = IAtsRecruitmentInterviewQuestion;

  export const METADATA = {
    method: "PUT",
    path: "/atsRecruitment/hrRecruiter/interviews/:interviewId/questions/:questionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/hrRecruiter/interviews/${encodeURIComponent(props.interviewId ?? "null")}/questions/${encodeURIComponent(props.questionId ?? "null")}`;
  export const random = (): IAtsRecruitmentInterviewQuestion =>
    typia.random<IAtsRecruitmentInterviewQuestion>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("interviewId")(() => typia.assert(props.interviewId));
      assert.param("questionId")(() => typia.assert(props.questionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific interview question from an interview session
 * (ats_recruitment_interview_questions).
 *
 * This API endpoint enables removal of an interview question from an interview
 * session, based on the provided interview ID and question ID path parameters.
 * The system accesses the ats_recruitment_interview_questions database table,
 * which links individual questions to interview instances.
 *
 * When a valid deletion request is issued, the targeted question is permanently
 * deleted from the database, meaning it will no longer appear in candidate or
 * interviewer workflows for the designated interview. Authorization checks are
 * performed to ensure that only HR recruiters or technical reviewers assigned
 * to the interview, or with system permission, may remove a question.
 *
 * Business logic prevents deletion if the question is associated with a
 * completed or locked interview session. All delete actions are logged for
 * audit compliance, and errors are returned in cases where the specified
 * interview or question does not exist, or if the requester lacks privileges.
 * The deletion is a hard delete as there is no dedicated soft delete column for
 * questions in the schema—once deleted, recovery is not possible.
 *
 * @param props.connection
 * @param props.interviewId Unique identifier of the interview session
 * @param props.questionId Unique identifier of the interview question to delete
 * @path /atsRecruitment/hrRecruiter/interviews/:interviewId/questions/:questionId
 * @accessor api.functional.atsRecruitment.hrRecruiter.interviews.questions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the interview session */
    interviewId: string & tags.Format<"uuid">;

    /** Unique identifier of the interview question to delete */
    questionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/atsRecruitment/hrRecruiter/interviews/:interviewId/questions/:questionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/hrRecruiter/interviews/${encodeURIComponent(props.interviewId ?? "null")}/questions/${encodeURIComponent(props.questionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("interviewId")(() => typia.assert(props.interviewId));
      assert.param("questionId")(() => typia.assert(props.questionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new interview question for a specified interview.
 *
 * Create a new question for a specific interview. This is used by HR recruiters
 * or technical reviewers to customize or augment the set of questions for an
 * interview session. New questions can be derived from templates, generated by
 * AI, or written manually (depending on business rules), and all properties of
 * the ats_recruitment_interview_questions schema can be populated.
 *
 * The operation strictly enforces interviewId matching and sequence
 * constraints—e.g., assigning correct order among questions, marking as
 * template/manual, and choosing type/category. Role-based access is mandatory:
 * only HR or technical reviewers assigned to the interview should be able to
 * create questions.
 *
 * After creation, the system may log this action in the audit trail for
 * compliance. Related functions include updating question content, listing, and
 * retrieving single questions for an interview.
 *
 * @param props.connection
 * @param props.interviewId UUID of the interview to which this question will be
 *   added.
 * @param props.body Interview question creation data (content, order, type,
 *   etc.)
 * @path /atsRecruitment/hrRecruiter/interviews/:interviewId/questions
 * @accessor api.functional.atsRecruitment.hrRecruiter.interviews.questions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** UUID of the interview to which this question will be added. */
    interviewId: string & tags.Format<"uuid">;

    /** Interview question creation data (content, order, type, etc.) */
    body: IAtsRecruitmentInterviewQuestion.ICreate;
  };
  export type Body = IAtsRecruitmentInterviewQuestion.ICreate;
  export type Response = IAtsRecruitmentInterviewQuestion;

  export const METADATA = {
    method: "POST",
    path: "/atsRecruitment/hrRecruiter/interviews/:interviewId/questions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/hrRecruiter/interviews/${encodeURIComponent(props.interviewId ?? "null")}/questions`;
  export const random = (): IAtsRecruitmentInterviewQuestion =>
    typia.random<IAtsRecruitmentInterviewQuestion>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("interviewId")(() => typia.assert(props.interviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve all questions assigned to a specific interview.
 *
 * Retrieve a paginated and filterable list of all interview questions for a
 * given interview. This is useful for HR recruiters or tech reviewers needing
 * to review, audit, or edit the sequence and composition of interview questions
 * prior to the interview taking place, as well as to support interview
 * evaluation processes.
 *
 * The operation validates the interviewId path parameter to return only valid
 * questions for the interview entity. In addition, it applies any complex
 * search/filter/pagination criteria provided in the request body (such as
 * question type, template/manual filter, keyword searching within question
 * text, or order-based sorting). The endpoint enforces proper access control so
 * that only authorized HR/techReviewer roles (and, in some contexts,
 * applicants) can retrieve the question sets.
 *
 * Returned data includes all properties from
 * ats_recruitment_interview_questions, such as question text, type,
 * template/manual status, and ordering. Related operations are single-question
 * retrieval, creation, and update of interview questions.
 *
 * @param props.connection
 * @param props.interviewId UUID of the interview whose questions will be
 *   searched/listed.
 * @param props.body Search/filters for question content, type, ordering, and
 *   pagination.
 * @path /atsRecruitment/hrRecruiter/interviews/:interviewId/questions
 * @accessor api.functional.atsRecruitment.hrRecruiter.interviews.questions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the interview whose questions will be searched/listed. */
    interviewId: string & tags.Format<"uuid">;

    /** Search/filters for question content, type, ordering, and pagination. */
    body: IAtsRecruitmentInterviewQuestion.IRequest;
  };
  export type Body = IAtsRecruitmentInterviewQuestion.IRequest;
  export type Response = IPageIAtsRecruitmentInterviewQuestion;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/hrRecruiter/interviews/:interviewId/questions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/hrRecruiter/interviews/${encodeURIComponent(props.interviewId ?? "null")}/questions`;
  export const random = (): IPageIAtsRecruitmentInterviewQuestion =>
    typia.random<IPageIAtsRecruitmentInterviewQuestion>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("interviewId")(() => typia.assert(props.interviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
