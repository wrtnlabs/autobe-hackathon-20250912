import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentInterviewSchedule } from "../../../../../structures/IAtsRecruitmentInterviewSchedule";

/**
 * Create a new interview schedule slot for a specific interview
 * (ats_recruitment_interview_schedules).
 *
 * This API operation creates a new schedule entry linked to a specific
 * interview in the ATS recruitment platform. The schedule slot includes fields
 * for start and end times (UTC), timezone, source (manual or automated), and
 * confirmation or proposal status. Operation ensures that the referenced
 * interview exists and is active, and checks for time conflicts to prevent
 * overlapping or duplicate booking. Only users assigned as participant roles
 * (HR, applicant, techReviewer) for this interview may invoke this operation.
 *
 * Upon creation, the slot is checked to confirm it does not conflict with
 * existing slots for the interview, and will fail gracefully with a meaningful
 * error if there are duplications or the referenced interview is not eligible
 * for new scheduling. The record stores the reason for any cancellation or
 * status update (e.g., rescheduled, cancelled, confirmed).
 *
 * Security: Only authorized HR recruiters, related applicants, or tech
 * reviewers can add schedules. All invocations are logged in audit trails for
 * compliance and traceability. Related operations are PUT (update slot), DELETE
 * (cancel slot), and PATCH (list slots for interview).
 *
 * @param props.connection
 * @param props.interviewId Unique identifier of the target interview for which
 *   to create a new schedule.
 * @param props.body Details of the interview schedule slot to create, including
 *   start/end time, timezone, schedule source, participant data, and
 *   confirmation status.
 * @path /atsRecruitment/techReviewer/interviews/:interviewId/schedules
 * @accessor api.functional.atsRecruitment.techReviewer.interviews.schedules.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the target interview for which to create a new
     * schedule.
     */
    interviewId: string & tags.Format<"uuid">;

    /**
     * Details of the interview schedule slot to create, including start/end
     * time, timezone, schedule source, participant data, and confirmation
     * status.
     */
    body: IAtsRecruitmentInterviewSchedule.ICreate;
  };
  export type Body = IAtsRecruitmentInterviewSchedule.ICreate;
  export type Response = IAtsRecruitmentInterviewSchedule;

  export const METADATA = {
    method: "POST",
    path: "/atsRecruitment/techReviewer/interviews/:interviewId/schedules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/techReviewer/interviews/${encodeURIComponent(props.interviewId ?? "null")}/schedules`;
  export const random = (): IAtsRecruitmentInterviewSchedule =>
    typia.random<IAtsRecruitmentInterviewSchedule>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("interviewId")(() => typia.assert(props.interviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing interview schedule slot for a given interview
 * (ats_recruitment_interview_schedules).
 *
 * This API operation updates details of an existing schedule slot for a
 * particular interview. Updatable fields include start_at, end_at, timezone,
 * schedule source, and schedule status or cancellation reason. It requires
 * checking that the interview and schedule both exist, are not deleted, and are
 * eligible for update according to the current status (e.g., slots that are
 * already confirmed as completed or cancelled cannot be updated).
 *
 * Validation rules enforce that the new slot time does not overlap with any
 * other slot linked to this interview, and that status transitions are allowed
 * per business policy (e.g., pending→confirmed, pending→cancelled).
 *
 * Security enforcement ensures that only participants (HR, related applicant,
 * techReviewer) associated with the interview or system administrators may
 * invoke this update. All updates are recorded in the audit trail for
 * compliance and subsequent event notification. Related operations are POST
 * (create slot), DELETE (cancel slot), and PATCH (list schedules).
 *
 * If the operation fails due to validation, proper error messages are returned
 * to guide the user (e.g., "proposed time conflicts with another confirmed
 * slot“).
 *
 * @param props.connection
 * @param props.interviewId Unique identifier of the target interview.
 * @param props.scheduleId Unique identifier of the schedule slot to update.
 * @param props.body Fields to update for the interview schedule slot, such as
 *   timing, timezone, source, or status change.
 * @path /atsRecruitment/techReviewer/interviews/:interviewId/schedules/:scheduleId
 * @accessor api.functional.atsRecruitment.techReviewer.interviews.schedules.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target interview. */
    interviewId: string & tags.Format<"uuid">;

    /** Unique identifier of the schedule slot to update. */
    scheduleId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the interview schedule slot, such as timing,
     * timezone, source, or status change.
     */
    body: IAtsRecruitmentInterviewSchedule.IUpdate;
  };
  export type Body = IAtsRecruitmentInterviewSchedule.IUpdate;
  export type Response = IAtsRecruitmentInterviewSchedule;

  export const METADATA = {
    method: "PUT",
    path: "/atsRecruitment/techReviewer/interviews/:interviewId/schedules/:scheduleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/techReviewer/interviews/${encodeURIComponent(props.interviewId ?? "null")}/schedules/${encodeURIComponent(props.scheduleId ?? "null")}`;
  export const random = (): IAtsRecruitmentInterviewSchedule =>
    typia.random<IAtsRecruitmentInterviewSchedule>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("interviewId")(() => typia.assert(props.interviewId));
      assert.param("scheduleId")(() => typia.assert(props.scheduleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (cancel) a specific interview schedule slot for a given interview
 * (ats_recruitment_interview_schedules).
 *
 * This API operation removes or cancels a schedule entry for an interview,
 * marking it as deleted or cancelled in the database. The operation first
 * validates that the interview and associated schedule exist and are in a
 * modifiable state (not completed, not already cancelled). The operation
 * retains a soft-deletion pattern by setting the deleted_at field for audit
 * recovery; hard delete is not performed so that all schedule changes remain
 * traceable. A cancellation reason can be recorded as part of the process.
 *
 * This is restricted to HR recruiters, technical reviewers, or system
 * administrators linked to the interview. Any attempt to delete a non-existent
 * or already-completed/cancelled slot results in a business rule error, with
 * details returned to the caller.
 *
 * All cancellations/deletions are logged to audit trails for compliance and
 * event notification to participants. Common related operations are POST
 * (create slot) and PUT (update slot).
 *
 * @param props.connection
 * @param props.interviewId Unique identifier of the interview whose schedule
 *   should be deleted.
 * @param props.scheduleId Unique identifier of the schedule slot to delete
 *   (cancel).
 * @path /atsRecruitment/techReviewer/interviews/:interviewId/schedules/:scheduleId
 * @accessor api.functional.atsRecruitment.techReviewer.interviews.schedules.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the interview whose schedule should be deleted. */
    interviewId: string & tags.Format<"uuid">;

    /** Unique identifier of the schedule slot to delete (cancel). */
    scheduleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/atsRecruitment/techReviewer/interviews/:interviewId/schedules/:scheduleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/techReviewer/interviews/${encodeURIComponent(props.interviewId ?? "null")}/schedules/${encodeURIComponent(props.scheduleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("interviewId")(() => typia.assert(props.interviewId));
      assert.param("scheduleId")(() => typia.assert(props.scheduleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
