import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentCodingTestReviewComment } from "../../../../../../structures/IAtsRecruitmentCodingTestReviewComment";
import { IPageIAtsRecruitmentCodingTestReviewComment } from "../../../../../../structures/IPageIAtsRecruitmentCodingTestReviewComment";

/**
 * Retrieve the details of a coding test review comment by ID for a given coding
 * test submission.
 *
 * This API retrieves all details of a specified review comment associated with
 * a particular coding test submission. It can be used by technical reviewers,
 * HR staff, or system admins to display the content, review type, timestamps,
 * and reviewer identification of a single comment for moderation/audit
 * purposes.
 *
 * Access to this endpoint should be restricted according to applicant privacy
 * and reviewer authorization rules, as review comments may contain sensitive
 * evaluation notes. Security checks must ensure the requesting actor is
 * permitted to view the review comment (e.g., must be the assigned tech
 * reviewer or HR of the job posting), as per platform policy.
 *
 * Referenced database columns include the immutable review comment text,
 * comment_type (e.g., 'manual', 'auto', or 'system'), timestamps for when the
 * comment was started and finalized, and the reviewer ID. The operation draws
 * from the ats_recruitment_coding_test_review_comments schema and supports
 * compliance by enabling audit of reviewer feedback and the integrity of the
 * review process.
 *
 * This endpoint is intended to be used after listing available review comments
 * for a submission (via listing endpoint), or when directly accessing a comment
 * from a moderation or feedback workflow UI. Error handling must clearly
 * distinguish not found, forbidden, or deleted resources, returning appropriate
 * error codes and audit logging all access for compliance.
 *
 * @param props.connection
 * @param props.codingTestId Unique identifier for the coding test to which the
 *   review comment belongs.
 * @param props.submissionId Unique identifier for the coding test submission
 *   associated with this review comment.
 * @param props.reviewCommentId Unique identifier for the review comment being
 *   retrieved.
 * @path /atsRecruitment/techReviewer/codingTests/:codingTestId/submissions/:submissionId/reviewComments/:reviewCommentId
 * @accessor api.functional.atsRecruitment.techReviewer.codingTests.submissions.reviewComments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier for the coding test to which the review comment
     * belongs.
     */
    codingTestId: string & tags.Format<"uuid">;

    /**
     * Unique identifier for the coding test submission associated with this
     * review comment.
     */
    submissionId: string & tags.Format<"uuid">;

    /** Unique identifier for the review comment being retrieved. */
    reviewCommentId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentCodingTestReviewComment;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/techReviewer/codingTests/:codingTestId/submissions/:submissionId/reviewComments/:reviewCommentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/techReviewer/codingTests/${encodeURIComponent(props.codingTestId ?? "null")}/submissions/${encodeURIComponent(props.submissionId ?? "null")}/reviewComments/${encodeURIComponent(props.reviewCommentId ?? "null")}`;
  export const random = (): IAtsRecruitmentCodingTestReviewComment =>
    typia.random<IAtsRecruitmentCodingTestReviewComment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("codingTestId")(() => typia.assert(props.codingTestId));
      assert.param("submissionId")(() => typia.assert(props.submissionId));
      assert.param("reviewCommentId")(() =>
        typia.assert(props.reviewCommentId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a review comment for a coding test submission
 * (ats_recruitment_coding_test_review_comments).
 *
 * Update a coding test review comment in the ATS recruitment system. This
 * endpoint is used by technical reviewers or system administrators to modify
 * existing feedback or commentary on a coding test submission.
 *
 * Authorization checks ensure that only technical reviewers associated with the
 * review comment or system administrators can update the comment. The operation
 * references the coding test and its submission for context, enforcing that the
 * specified reviewCommentId actually belongs to the target submission.
 *
 * Business validation ensures the comment text, type, and review timings remain
 * consistent with reviewer workflow policies. Updating soft-deleted or
 * non-existent comments will return an error. Usage of this endpoint is
 * auditable, and updates are tracked for compliance purposes.
 *
 * Related operations include creating new review comments, deleting comments,
 * or retrieving comments for a given submission. This operation supports the
 * technical review loop and code quality feedback in talent evaluation
 * processes.
 *
 * @param props.connection
 * @param props.codingTestId ID of the target coding test.
 * @param props.submissionId ID of the submission under the coding test.
 * @param props.reviewCommentId ID of the review comment to be updated.
 * @param props.body Updated information for the review comment.
 * @path /atsRecruitment/techReviewer/codingTests/:codingTestId/submissions/:submissionId/reviewComments/:reviewCommentId
 * @accessor api.functional.atsRecruitment.techReviewer.codingTests.submissions.reviewComments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** ID of the target coding test. */
    codingTestId: string & tags.Format<"uuid">;

    /** ID of the submission under the coding test. */
    submissionId: string & tags.Format<"uuid">;

    /** ID of the review comment to be updated. */
    reviewCommentId: string & tags.Format<"uuid">;

    /** Updated information for the review comment. */
    body: IAtsRecruitmentCodingTestReviewComment.IUpdate;
  };
  export type Body = IAtsRecruitmentCodingTestReviewComment.IUpdate;
  export type Response = IAtsRecruitmentCodingTestReviewComment;

  export const METADATA = {
    method: "PUT",
    path: "/atsRecruitment/techReviewer/codingTests/:codingTestId/submissions/:submissionId/reviewComments/:reviewCommentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/techReviewer/codingTests/${encodeURIComponent(props.codingTestId ?? "null")}/submissions/${encodeURIComponent(props.submissionId ?? "null")}/reviewComments/${encodeURIComponent(props.reviewCommentId ?? "null")}`;
  export const random = (): IAtsRecruitmentCodingTestReviewComment =>
    typia.random<IAtsRecruitmentCodingTestReviewComment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("codingTestId")(() => typia.assert(props.codingTestId));
      assert.param("submissionId")(() => typia.assert(props.submissionId));
      assert.param("reviewCommentId")(() =>
        typia.assert(props.reviewCommentId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a review comment for a coding test submission
 * (ats_recruitment_coding_test_review_comments).
 *
 * Permanently delete a review comment for a coding test submission in the ATS
 * recruitment system. Technical reviewers or system administrators may use this
 * endpoint to remove comments that are erroneous, inappropriate, or no longer
 * relevant to the evaluation process.
 *
 * Access control ensures only the comment owner, or users with the system
 * administrator role, may perform this operation. The operation verifies that
 * the reviewCommentId belongs to the referenced submission and coding test.
 *
 * The absence of a soft-delete column in the schema means deleted records
 * cannot be recovered. Deleted comments are removed from the feedback and
 * visibility loop for the submission and are not returned in future review
 * queries.
 *
 * Error handling covers cases where the comment does not exist or the requester
 * is not authorized. This is a destructive operation intended for exceptional
 * cases, not regular reviewer workflow.
 *
 * @param props.connection
 * @param props.codingTestId ID of the coding test.
 * @param props.submissionId ID of the coding test submission.
 * @param props.reviewCommentId ID of the review comment to delete.
 * @path /atsRecruitment/techReviewer/codingTests/:codingTestId/submissions/:submissionId/reviewComments/:reviewCommentId
 * @accessor api.functional.atsRecruitment.techReviewer.codingTests.submissions.reviewComments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** ID of the coding test. */
    codingTestId: string & tags.Format<"uuid">;

    /** ID of the coding test submission. */
    submissionId: string & tags.Format<"uuid">;

    /** ID of the review comment to delete. */
    reviewCommentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/atsRecruitment/techReviewer/codingTests/:codingTestId/submissions/:submissionId/reviewComments/:reviewCommentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/techReviewer/codingTests/${encodeURIComponent(props.codingTestId ?? "null")}/submissions/${encodeURIComponent(props.submissionId ?? "null")}/reviewComments/${encodeURIComponent(props.reviewCommentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("codingTestId")(() => typia.assert(props.codingTestId));
      assert.param("submissionId")(() => typia.assert(props.submissionId));
      assert.param("reviewCommentId")(() =>
        typia.assert(props.reviewCommentId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new coding test review comment for a specific submission.
 *
 * This API enables a technical reviewer to add a new review comment to a coding
 * test submission in the ATS platform. Only authenticated technical reviewers
 * assigned to the specific coding test may use this endpoint, which ensures
 * each review comment is properly attributed, timestamped, and stored immutably
 * for audit compliance.
 *
 * The request body must provide the content of the comment, type (manual, auto,
 * or system), and any supplementary information as defined by the business
 * process. The backend enforces one comment per reviewer per submission phase
 * (i.e., duplicate/redundant comments in the same phase are rejected), and all
 * fields are validated according to the underlying
 * ats_recruitment_coding_test_review_comments schema.
 *
 * Security best practices require that only authorized technical reviewers can
 * create comments for submissions to which they are assigned, and that all
 * comment creation events are logged for audit. In the case of unauthorized
 * attempts or failed validation, detailed and secure error messages are
 * returned.
 *
 * This operation is typically used in the review workflow after a coding test
 * is submitted and before final review is closed, providing an audit-ready log
 * of all reviewer feedback. Related endpoints include retrieval and listing of
 * comments, and modification is not supported (comments are immutable apart
 * from soft delete).
 *
 * @param props.connection
 * @param props.codingTestId Unique identifier for the coding test to assign the
 *   review comment to.
 * @param props.submissionId Unique identifier for the specific submission under
 *   review.
 * @param props.body Creation details of the review comment including text,
 *   type, and reviewer context.
 * @path /atsRecruitment/techReviewer/codingTests/:codingTestId/submissions/:submissionId/reviewComments
 * @accessor api.functional.atsRecruitment.techReviewer.codingTests.submissions.reviewComments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier for the coding test to assign the review comment
     * to.
     */
    codingTestId: string & tags.Format<"uuid">;

    /** Unique identifier for the specific submission under review. */
    submissionId: string & tags.Format<"uuid">;

    /**
     * Creation details of the review comment including text, type, and
     * reviewer context.
     */
    body: IAtsRecruitmentCodingTestReviewComment.ICreate;
  };
  export type Body = IAtsRecruitmentCodingTestReviewComment.ICreate;
  export type Response = IAtsRecruitmentCodingTestReviewComment;

  export const METADATA = {
    method: "POST",
    path: "/atsRecruitment/techReviewer/codingTests/:codingTestId/submissions/:submissionId/reviewComments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/techReviewer/codingTests/${encodeURIComponent(props.codingTestId ?? "null")}/submissions/${encodeURIComponent(props.submissionId ?? "null")}/reviewComments`;
  export const random = (): IAtsRecruitmentCodingTestReviewComment =>
    typia.random<IAtsRecruitmentCodingTestReviewComment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("codingTestId")(() => typia.assert(props.codingTestId));
      assert.param("submissionId")(() => typia.assert(props.submissionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated, filtered list of coding test review comments
 * for a specific submission.
 *
 * This API provides a way to retrieve a filtered and paginated list of all
 * review comments associated with a specific coding test submission, enabling
 * team members to audit, moderate, or collaboratively evaluate the applicant's
 * coding test. The request body may include search terms, reviewer filters,
 * date ranges, or comment type, supporting flexible UX scenarios for reviewing
 * or audit.
 *
 * Comments are returned ordered by commented_at descending, but support
 * additional sort options. The response includes pagination, total count, and a
 * list of matching review comments, as per the
 * ats_recruitment_coding_test_review_comments schema. Security rules ensure
 * that only authorized tech reviewers (those assigned), HR for the
 * corresponding job posting, or system admins can access the list, with full
 * audit logging of all data accesses.
 *
 * The endpoint is not intended to return the full coding test or submission
 * content, only the review comment metadata and content fields. Error handling
 * distinguishes between no results, forbidden access, and deleted resources.
 * Related endpoints include creation, single retrieval, and deletion of
 * comments.
 *
 * @param props.connection
 * @param props.codingTestId Unique identifier for the coding test to list
 *   review comments for.
 * @param props.submissionId Unique identifier for the coding test submission
 *   under review.
 * @param props.body Search, filter, and pagination parameters for reviewer
 *   comment query.
 * @path /atsRecruitment/techReviewer/codingTests/:codingTestId/submissions/:submissionId/reviewComments
 * @accessor api.functional.atsRecruitment.techReviewer.codingTests.submissions.reviewComments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier for the coding test to list review comments for. */
    codingTestId: string & tags.Format<"uuid">;

    /** Unique identifier for the coding test submission under review. */
    submissionId: string & tags.Format<"uuid">;

    /** Search, filter, and pagination parameters for reviewer comment query. */
    body: IAtsRecruitmentCodingTestReviewComment.IRequest;
  };
  export type Body = IAtsRecruitmentCodingTestReviewComment.IRequest;
  export type Response = IPageIAtsRecruitmentCodingTestReviewComment;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/techReviewer/codingTests/:codingTestId/submissions/:submissionId/reviewComments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/techReviewer/codingTests/${encodeURIComponent(props.codingTestId ?? "null")}/submissions/${encodeURIComponent(props.submissionId ?? "null")}/reviewComments`;
  export const random = (): IPageIAtsRecruitmentCodingTestReviewComment =>
    typia.random<IPageIAtsRecruitmentCodingTestReviewComment>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("codingTestId")(() => typia.assert(props.codingTestId));
      assert.param("submissionId")(() => typia.assert(props.submissionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
