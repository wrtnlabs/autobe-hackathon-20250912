import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentEnums } from "../../../../structures/IAtsRecruitmentEnums";

/**
 * Create a new global enumeration for the recruitment system
 * (ats_recruitment_enums table).
 *
 * This endpoint allows an authorized system administrator to add a new
 * enumeration value to the central enum registry used across the ATS platform.
 * The ats_recruitment_enums table is referenced for all business-specific codes
 * and labels (such as job state codes, employment types, and notification
 * channels) and supports critical application logic.
 *
 * The operation enforces that enum_type and enum_code are unique within their
 * grouping. Creation activity is logged for compliance and audit purposes. Only
 * users with the "systemAdmin" role are authorized to invoke this endpoint, as
 * incorrect or duplicate enums can cause system-wide lookup failures or
 * inconsistencies.
 *
 * During processing, the input is validated for format, uniqueness, and
 * required fields according to the schema. Optional attributes and extended
 * metadata can be added to support custom UI or logic extensions. Errors may be
 * thrown if constraint or naming violations occur, which are surfaced with
 * clear messages for maintenance and audit traceability.
 *
 * @param props.connection
 * @param props.body Creation data for enumeration value including enum_type,
 *   enum_code, label, and optional metadata.
 * @path /atsRecruitment/systemAdmin/enums
 * @accessor api.functional.atsRecruitment.systemAdmin.enums.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Creation data for enumeration value including enum_type, enum_code,
     * label, and optional metadata.
     */
    body: IAtsRecruitmentEnums.ICreate;
  };
  export type Body = IAtsRecruitmentEnums.ICreate;
  export type Response = IAtsRecruitmentEnums;

  export const METADATA = {
    method: "POST",
    path: "/atsRecruitment/systemAdmin/enums",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/atsRecruitment/systemAdmin/enums";
  export const random = (): IAtsRecruitmentEnums =>
    typia.random<IAtsRecruitmentEnums>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing enumeration value by UUID (ats_recruitment_enums table).
 *
 * This endpoint lets a system administrator update details of a specific
 * enumeration in the ats_recruitment_enums registry, identified by its unique
 * UUID. Use cases include renaming labels for localization, adding descriptions
 * for clarity, or modifying extended_data payloads for UI logic or
 * integrations.
 *
 * Reference to the existing enum is by enumId (UUID path parameter). Only the
 * label, description, or extended_data fields may be updatedâ€”enum_type and
 * enum_code should remain unchanged to avoid referential breakage. All
 * modifications are logged in the audit trail for governance.
 *
 * Strict permission checks ensure that only authorized system administrators
 * can perform modifications, as enum changes can have system-wide impact. Input
 * validation will enforce type and length limits according to schema. Error
 * responses are clear for traceability and remediation if the UUID is invalid
 * or if the record is not found.
 *
 * @param props.connection
 * @param props.enumId Unique identifier (UUID) of the enum value to update.
 * @param props.body Updated properties for the enumeration value (label,
 *   description, extended_data).
 * @path /atsRecruitment/systemAdmin/enums/:enumId
 * @accessor api.functional.atsRecruitment.systemAdmin.enums.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the enum value to update. */
    enumId: string & tags.Format<"uuid">;

    /**
     * Updated properties for the enumeration value (label, description,
     * extended_data).
     */
    body: IAtsRecruitmentEnums.IUpdate;
  };
  export type Body = IAtsRecruitmentEnums.IUpdate;
  export type Response = IAtsRecruitmentEnums;

  export const METADATA = {
    method: "PUT",
    path: "/atsRecruitment/systemAdmin/enums/:enumId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/systemAdmin/enums/${encodeURIComponent(props.enumId ?? "null")}`;
  export const random = (): IAtsRecruitmentEnums =>
    typia.random<IAtsRecruitmentEnums>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("enumId")(() => typia.assert(props.enumId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete an enumeration value from the ATS global registry
 * (ats_recruitment_enums table) by UUID.
 *
 * A system administrator can use this endpoint to logically remove (soft
 * delete) an enumeration value from the central ats_recruitment_enums registry
 * by specifying its UUID in the path parameter. Soft deletion sets the
 * deleted_at timestamp, thereby hiding the enum from future use in business
 * processes but keeping its record for audit and reference.
 *
 * This operation is protected and only accessible by the "systemAdmin" role
 * because enums are core to many business flows; improper deletion could break
 * lookups and workflows. Audit logs record the actor, timestamp, reason, and
 * affected record for compliance and future audits.
 *
 * The operation validates the uuid format and existence before marking as
 * deleted. Attempts to delete an already deleted or non-existent record result
 * in a clear error message for remediation or further investigation.
 *
 * @param props.connection
 * @param props.enumId Unique identifier (UUID) of the enum value to be soft
 *   deleted.
 * @path /atsRecruitment/systemAdmin/enums/:enumId
 * @accessor api.functional.atsRecruitment.systemAdmin.enums.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the enum value to be soft deleted. */
    enumId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/atsRecruitment/systemAdmin/enums/:enumId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/enums/${encodeURIComponent(props.enumId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("enumId")(() => typia.assert(props.enumId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
