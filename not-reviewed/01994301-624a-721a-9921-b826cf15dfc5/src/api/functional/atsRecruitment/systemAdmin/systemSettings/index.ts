import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentSystemSetting } from "../../../../structures/IAtsRecruitmentSystemSetting";
import { IPageIAtsRecruitmentSystemSetting } from "../../../../structures/IPageIAtsRecruitmentSystemSetting";

/**
 * Create a new ATS system setting (ats_recruitment_system_settings).
 *
 * This endpoint allows system administrators to add a new global configuration
 * setting to the ATS system. The input must provide a unique setting_name,
 * value, type, and optionally a description. Constraints include setting_name
 * uniqueness, valid value/type pairs, and full audit trace.
 *
 * If a setting with the same name already exists, the operation will fail with
 * a uniqueness violation error. Upon success, the endpoint returns the newly
 * created setting's data including timestamps and all schema-defined metadata.
 *
 * Every setting creation is logged for compliance review. Only systemAdmin role
 * may create or modify global configurations, as these settings can affect the
 * workflow for all users across the platform.
 *
 * @param props.connection
 * @param props.body Data required to create a new system setting, including
 *   unique name, value, type, and optional documentation.
 * @path /atsRecruitment/systemAdmin/systemSettings
 * @accessor api.functional.atsRecruitment.systemAdmin.systemSettings.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Data required to create a new system setting, including unique name,
     * value, type, and optional documentation.
     */
    body: IAtsRecruitmentSystemSetting.ICreate;
  };
  export type Body = IAtsRecruitmentSystemSetting.ICreate;
  export type Response = IAtsRecruitmentSystemSetting;

  export const METADATA = {
    method: "POST",
    path: "/atsRecruitment/systemAdmin/systemSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/atsRecruitment/systemAdmin/systemSettings";
  export const random = (): IAtsRecruitmentSystemSetting =>
    typia.random<IAtsRecruitmentSystemSetting>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered, paginated list of ATS system settings
 * (ats_recruitment_system_settings).
 *
 * This endpoint allows system administrators to search for and retrieve a
 * paginated list of all ATS platform-wide system settings. The operation
 * provides advanced filtering on setting name, value, type, and temporal
 * ranges.
 *
 * It supports searching for specific settings, retrieving only
 * active/non-deleted entries, filtering by created/updated timestamps, and
 * sorting by name/type/created date. This helps administrators keep track of
 * configuration changes, audit compliance, and troubleshoot system behavior
 * based on global parameters.
 *
 * Due to the sensitive nature of system settings, access is restricted to
 * systemAdmin role, and every invocation is audit-logged. Results are fully
 * compliant with the underlying ats_recruitment_system_settings schema,
 * including all key fields and relations. If no settings match the filter, an
 * empty array is returned.
 *
 * @param props.connection
 * @param props.body Search and filter criteria for system settings, including
 *   setting name, type, value, date range, pagination, and sort options.
 * @path /atsRecruitment/systemAdmin/systemSettings
 * @accessor api.functional.atsRecruitment.systemAdmin.systemSettings.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and filter criteria for system settings, including setting
     * name, type, value, date range, pagination, and sort options.
     */
    body: IAtsRecruitmentSystemSetting.IRequest;
  };
  export type Body = IAtsRecruitmentSystemSetting.IRequest;
  export type Response = IPageIAtsRecruitmentSystemSetting;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/systemAdmin/systemSettings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/atsRecruitment/systemAdmin/systemSettings";
  export const random = (): IPageIAtsRecruitmentSystemSetting =>
    typia.random<IPageIAtsRecruitmentSystemSetting>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single system setting's detailed information by systemSettingId
 * (ats_recruitment_system_settings).
 *
 * This endpoint allows a system administrator to fetch the complete details of
 * a single ATS system setting by specifying its unique ID. It returns all
 * defined metadata including setting name, value, type, full description, audit
 * timestamps, and deleted_at if present.
 *
 * Use cases include auditing configuration changes, investigating system
 * behavior, or preparing to update or disable a specific setting. If the
 * setting is soft-deleted, a deleted_at value will be present for recovery or
 * compliance monitoring.
 *
 * The response structure matches the ats_recruitment_system_settings Prisma
 * model, exposing every field necessary for platform configuration management.
 * Only systemAdmin roles are authorized to call this endpoint.
 *
 * @param props.connection
 * @param props.systemSettingId Unique ID of the target ATS system setting to
 *   retrieve.
 * @path /atsRecruitment/systemAdmin/systemSettings/:systemSettingId
 * @accessor api.functional.atsRecruitment.systemAdmin.systemSettings.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique ID of the target ATS system setting to retrieve. */
    systemSettingId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentSystemSetting;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/systemAdmin/systemSettings/:systemSettingId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/systemSettings/${encodeURIComponent(props.systemSettingId ?? "null")}`;
  export const random = (): IAtsRecruitmentSystemSetting =>
    typia.random<IAtsRecruitmentSystemSetting>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemSettingId")(() =>
        typia.assert(props.systemSettingId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing ATS system setting by ID
 * (ats_recruitment_system_settings).
 *
 * This endpoint enables system administrators to modify an existing ATS system
 * setting by specifying its ID and providing new values for the fields to
 * update. Partial updates require specifying all relevant fields, and all
 * changes are subject to validation against the schema, including uniqueness of
 * setting_name.
 *
 * On success, the endpoint returns the updated system setting record,
 * reflecting changes including value, type, description, and updated_at
 * timestamp. This is used to manage platform behavior, enable/disable features,
 * or adjust thresholds and parameters at runtime.
 *
 * All update actions are audit-logged for traceability and compliance. Only the
 * systemAdmin role is authorized to update global configuration settings.
 *
 * @param props.connection
 * @param props.systemSettingId Unique ID of the system setting to update.
 * @param props.body Data containing the fields to update for the target system
 *   setting.
 * @path /atsRecruitment/systemAdmin/systemSettings/:systemSettingId
 * @accessor api.functional.atsRecruitment.systemAdmin.systemSettings.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique ID of the system setting to update. */
    systemSettingId: string & tags.Format<"uuid">;

    /** Data containing the fields to update for the target system setting. */
    body: IAtsRecruitmentSystemSetting.IUpdate;
  };
  export type Body = IAtsRecruitmentSystemSetting.IUpdate;
  export type Response = IAtsRecruitmentSystemSetting;

  export const METADATA = {
    method: "PUT",
    path: "/atsRecruitment/systemAdmin/systemSettings/:systemSettingId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/systemAdmin/systemSettings/${encodeURIComponent(props.systemSettingId ?? "null")}`;
  export const random = (): IAtsRecruitmentSystemSetting =>
    typia.random<IAtsRecruitmentSystemSetting>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemSettingId")(() =>
        typia.assert(props.systemSettingId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a system setting (ats_recruitment_system_settings table) by ID.
 *
 * This delete operation is leveraged to mark a system-wide configuration
 * parameter as deleted in the ats_recruitment_system_settings table. The
 * setting is not physically removed, but rather, the deleted_at field is set
 * with the current timestamp, which is a soft delete implementation.
 *
 * The endpoint requires system administrator privileges and is strictly audited
 * by the ats_recruitment_audit_trails model for regulatory compliance and
 * traceability. Any attempt by a non-admin user or request for a non-existent
 * or previously deleted record results in an error.
 *
 * This operation is used in conjunction with settings index, retrieval, and
 * update endpoints. It is essential that business logic ensures only
 * non-critical settings can be deleted, and deleted settings are not loaded
 * into the live system configuration. Recovery, undo, or reactivation may
 * require alternate routes and audit review. Error handling includes validation
 * of permissions, existence, and current status before marking as deleted.
 *
 * @param props.connection
 * @param props.systemSettingId Unique identifier (UUID) of the system setting
 *   to delete.
 * @path /atsRecruitment/systemAdmin/systemSettings/:systemSettingId
 * @accessor api.functional.atsRecruitment.systemAdmin.systemSettings.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the system setting to delete. */
    systemSettingId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/atsRecruitment/systemAdmin/systemSettings/:systemSettingId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/systemSettings/${encodeURIComponent(props.systemSettingId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemSettingId")(() =>
        typia.assert(props.systemSettingId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
