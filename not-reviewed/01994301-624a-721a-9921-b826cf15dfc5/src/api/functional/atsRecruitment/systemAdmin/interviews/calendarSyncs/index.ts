import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentInterviewCalendarSync } from "../../../../../structures/IAtsRecruitmentInterviewCalendarSync";
import { IPageIAtsRecruitmentInterviewCalendarSync } from "../../../../../structures/IPageIAtsRecruitmentInterviewCalendarSync";

/**
 * List and search all calendar sync attempts for a given interview
 * (ats_recruitment_interview_calendar_syncs).
 *
 * This API operation returns a paginated, filterable collection of all calendar
 * synchronization attempt records for a specific interview. Records include
 * sync type (e.g., google_calendar), status, external event ids, and error
 * messages where applicable. The operation supports advanced filtering by
 * sync_status (success, failed, pending), sync_type, and time range
 * (sync_time_from/to) to enable troubleshooting and compliance review by HR and
 * technical staff.
 *
 * Only authorized interview participants or system administrators may view this
 * information. Results are fully auditable, and read operations are tracked for
 * compliance and privacy. Integration with failure handling allows users to
 * quickly identify failed syncs and examine error details. Related operations
 * are POST (initiate new calendar sync) and GET/PUT for managing interview core
 * data.
 *
 * @param props.connection
 * @param props.interviewId Unique identifier of the interview whose calendar
 *   sync events are being listed or searched.
 * @param props.body Search, filtering, and pagination criteria for retrieving
 *   calendar sync events (optional filters for status, type, time, pagination
 *   info).
 * @path /atsRecruitment/systemAdmin/interviews/:interviewId/calendarSyncs
 * @accessor api.functional.atsRecruitment.systemAdmin.interviews.calendarSyncs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the interview whose calendar sync events are
     * being listed or searched.
     */
    interviewId: string & tags.Format<"uuid">;

    /**
     * Search, filtering, and pagination criteria for retrieving calendar
     * sync events (optional filters for status, type, time, pagination
     * info).
     */
    body: IAtsRecruitmentInterviewCalendarSync.IRequest;
  };
  export type Body = IAtsRecruitmentInterviewCalendarSync.IRequest;
  export type Response = IPageIAtsRecruitmentInterviewCalendarSync;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/systemAdmin/interviews/:interviewId/calendarSyncs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/systemAdmin/interviews/${encodeURIComponent(props.interviewId ?? "null")}/calendarSyncs`;
  export const random = (): IPageIAtsRecruitmentInterviewCalendarSync =>
    typia.random<IPageIAtsRecruitmentInterviewCalendarSync>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("interviewId")(() => typia.assert(props.interviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific interview calendar sync record by ID.
 *
 * Retrieve a single calendar synchronization record for a specific interview.
 * This operation is typically used by HR recruiters, system admins, or
 * technical reviewers to check the details and result of an attempt to sync an
 * interview schedule with an external calendar provider (such as Google
 * Calendar).
 *
 * The endpoint validates both the interviewId (parent resource) and
 * calendarSyncId (target record), confirming they match and ensuring that only
 * authorized roles can access the data. Returned information includes sync
 * type, time, status (pending, success, failed), error messages for
 * diagnostics, and tokens as permitted by security policy.
 *
 * Role-based security ensures that only interview participants (HR recruiter,
 * tech reviewer, applicant) or system admins may access the sync log. Related
 * endpoints include listing all sync attempts and handling manual sync retries
 * or failure audits.
 *
 * @param props.connection
 * @param props.interviewId UUID of the interview whose calendar sync is being
 *   retrieved.
 * @param props.calendarSyncId UUID of the calendar synchronization record to
 *   retrieve.
 * @path /atsRecruitment/systemAdmin/interviews/:interviewId/calendarSyncs/:calendarSyncId
 * @accessor api.functional.atsRecruitment.systemAdmin.interviews.calendarSyncs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the interview whose calendar sync is being retrieved. */
    interviewId: string & tags.Format<"uuid">;

    /** UUID of the calendar synchronization record to retrieve. */
    calendarSyncId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentInterviewCalendarSync;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/systemAdmin/interviews/:interviewId/calendarSyncs/:calendarSyncId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/interviews/${encodeURIComponent(props.interviewId ?? "null")}/calendarSyncs/${encodeURIComponent(props.calendarSyncId ?? "null")}`;
  export const random = (): IAtsRecruitmentInterviewCalendarSync =>
    typia.random<IAtsRecruitmentInterviewCalendarSync>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("interviewId")(() => typia.assert(props.interviewId));
      assert.param("calendarSyncId")(() => typia.assert(props.calendarSyncId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
