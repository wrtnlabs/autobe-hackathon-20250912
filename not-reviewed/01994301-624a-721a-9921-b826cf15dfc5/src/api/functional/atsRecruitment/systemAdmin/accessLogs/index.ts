import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentAccessLog } from "../../../../structures/IAtsRecruitmentAccessLog";
import { IPageIAtsRecruitmentAccessLog } from "../../../../structures/IPageIAtsRecruitmentAccessLog";

/**
 * Search and retrieve paginated access logs for ATS data access audit
 * (ats_recruitment_access_logs table).
 *
 * This API operation enables authorized administrators and auditors to query
 * the complete access history of sensitive recruitment data within the ATS
 * system. It supports complex filtering and search on actor type (applicant,
 * recruiter, reviewer, admin, system), access target (resume, application,
 * interview, credentials, etc.), access reason (normal operation, audit,
 * compliance, incident investigation), and flexible date range queries. Full
 * pagination and sorting are supported for high-volume log review.
 *
 * Authorization controls restrict this endpoint to users with explicit
 * audit/compliance roles, as log data can expose sensitive system behavior.
 * Data returned is read-only and cannot be manipulated via this endpoint. Each
 * access log entry adheres to the normalized schema field definitions,
 * including target IDs, timestamps, and contextual device/network information.
 *
 * The access logs table is foundational for regulatory compliance (e.g., GDPR,
 * internal policy, client audits), fraud detection, and breach investigation.
 * This endpoint is typically used in concert with other admin tools such as
 * single log record lookup, export, and audit attestation workflows. All
 * returned data is subject to redaction/masking policies where required.
 *
 * @param props.connection
 * @param props.body Query, filter, and pagination criteria for searching access
 *   logs (by actor, data type, time range, access reason, etc.)
 * @path /atsRecruitment/systemAdmin/accessLogs
 * @accessor api.functional.atsRecruitment.systemAdmin.accessLogs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Query, filter, and pagination criteria for searching access logs (by
     * actor, data type, time range, access reason, etc.)
     */
    body: IAtsRecruitmentAccessLog.IRequest;
  };
  export type Body = IAtsRecruitmentAccessLog.IRequest;
  export type Response = IPageIAtsRecruitmentAccessLog.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/systemAdmin/accessLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/atsRecruitment/systemAdmin/accessLogs";
  export const random = (): IPageIAtsRecruitmentAccessLog.ISummary =>
    typia.random<IPageIAtsRecruitmentAccessLog.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed single access log record for audit/compliance
 * (ats_recruitment_access_logs table).
 *
 * Use this API to obtain the complete details of a single data access event for
 * security, audit, or compliance review purposes. The payload includes the
 * actor who accessed the data, their role, the specific data type and record
 * accessed, when and from where the access occurred, and any provided
 * business/system reason. Data is returned as a read-only, immutable record for
 * audit trail purposes. The accessLogId provided must match an existing record;
 * attempts to access logs without sufficient permission or for deleted/invalid
 * IDs will result in error.
 *
 * Access is strictly limited to system administrators or explicitly authorized
 * compliance auditors. The endpoint integrates with monitoring dashboards,
 * incident response playbooks, and audit reconciliation tools. Combined with
 * list endpoints and export workflows, it supports full compliance lifecycle
 * and business policy enforcement for data usage transparency.
 *
 * @param props.connection
 * @param props.accessLogId Unique identifier (UUID) of the access log record to
 *   retrieve.
 * @path /atsRecruitment/systemAdmin/accessLogs/:accessLogId
 * @accessor api.functional.atsRecruitment.systemAdmin.accessLogs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the access log record to retrieve. */
    accessLogId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentAccessLog;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/systemAdmin/accessLogs/:accessLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/accessLogs/${encodeURIComponent(props.accessLogId ?? "null")}`;
  export const random = (): IAtsRecruitmentAccessLog =>
    typia.random<IAtsRecruitmentAccessLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("accessLogId")(() => typia.assert(props.accessLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
