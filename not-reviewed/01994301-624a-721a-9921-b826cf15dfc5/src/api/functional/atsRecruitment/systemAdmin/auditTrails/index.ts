import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentAuditTrails } from "../../../../structures/IAtsRecruitmentAuditTrails";
import { IPageIAtsRecruitmentAuditTrails } from "../../../../structures/IPageIAtsRecruitmentAuditTrails";
import { IAtsRecruitmentAuditTrail } from "../../../../structures/IAtsRecruitmentAuditTrail";

/**
 * Search and retrieve paginated audit trails for all
 * administrative/configuration events (ats_recruitment_audit_trails table).
 *
 * This endpoint delivers a paginated and filterable list of audit trails for
 * the ATS system, as recorded in the ats_recruitment_audit_trails table. It
 * supports robust querying on actor ID, operation types (e.g., CREATE, UPDATE,
 * DELETE, ACCESS), target types, time ranges, and partial/full-text event
 * details (using trigram search where enabled).
 *
 * The audit log index is vital for compliance and security review, supporting
 * internal and external audit requirements for configuration changes, sensitive
 * data access, and administrative actions. All API activity, business object
 * modifications, and system events are chronologically archived and available
 * to system administrators.
 *
 * Access to this API is strictly restricted to the "systemAdmin" role for
 * security and data privacy reasons. Requests specify search parameters,
 * pagination options, and sorting preferences, returning a paged set of audit
 * trail entries and associated metadata for review or download.
 *
 * @param props.connection
 * @param props.body Search and filter parameters for querying audit logs
 *   (actor, operation, time range, etc.).
 * @path /atsRecruitment/systemAdmin/auditTrails
 * @accessor api.functional.atsRecruitment.systemAdmin.auditTrails.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and filter parameters for querying audit logs (actor,
     * operation, time range, etc.).
     */
    body: IAtsRecruitmentAuditTrails.IRequest;
  };
  export type Body = IAtsRecruitmentAuditTrails.IRequest;
  export type Response = IPageIAtsRecruitmentAuditTrails;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/systemAdmin/auditTrails",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/atsRecruitment/systemAdmin/auditTrails";
  export const random = (): IPageIAtsRecruitmentAuditTrails =>
    typia.random<IPageIAtsRecruitmentAuditTrails>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific audit trail entry by its ID from
 * ats_recruitment_audit_trails.
 *
 * This operation fetches a single, detailed audit trail entry from the ATS
 * Audit Log using the primary key. The audit log record comprises information
 * such as event timestamp, actor information, operation type, affected target
 * and its type, event detail, IP address, and user agent string.
 *
 * Access is strictly limited to users with the systemAdmin role due to the
 * sensitivity and confidentiality of audit data, in compliance with audit and
 * security requirements. The response structure mirrors the full schema of
 * ats_recruitment_audit_trails, ensuring all relevant metadata for incident
 * investigation is included.
 *
 * Error handling: Returns 404 if the specified auditTrailId does not exist or
 * caller lacks permission; all access attempts are further audited for
 * compliance logging.
 *
 * @param props.connection
 * @param props.auditTrailId Unique identifier of the audit trail record to
 *   retrieve.
 * @path /atsRecruitment/systemAdmin/auditTrails/:auditTrailId
 * @accessor api.functional.atsRecruitment.systemAdmin.auditTrails.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the audit trail record to retrieve. */
    auditTrailId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentAuditTrail;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/systemAdmin/auditTrails/:auditTrailId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/auditTrails/${encodeURIComponent(props.auditTrailId ?? "null")}`;
  export const random = (): IAtsRecruitmentAuditTrail =>
    typia.random<IAtsRecruitmentAuditTrail>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("auditTrailId")(() => typia.assert(props.auditTrailId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
