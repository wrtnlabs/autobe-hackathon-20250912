import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentNotification } from "../../../../structures/IAtsRecruitmentNotification";
import { IPageIAtsRecruitmentNotification } from "../../../../structures/IPageIAtsRecruitmentNotification";
export * as deliveries from "./deliveries/index";
export * as failures from "./failures/index";

/**
 * Create a new notification event in the ATS notification system
 * (ats_recruitment_notifications table).
 *
 * This API allows authorized system actors to create a notification intent for
 * delivery to users. Each notification consists of business context (type,
 * related entity), recipients (by role and user id), reference to the business
 * table and entity (such as an application or interview), and payload
 * parameters for template rendering.
 *
 * This operation does not directly deliver or send the notification but creates
 * a business event that will then be processed by the notification service and
 * delivery system. Only users with roles that have privilege to create
 * notifications may invoke this operation; in general, hrRecruiter,
 * techReviewer, and systemAdmin may generate notifications relevant to business
 * workflow. Applicant-facing notifications should typically be
 * system-triggered, not user-triggered.
 *
 * Security and privacy are enforced by checking both the callers'
 * authentication/authorization context and the validity of reference ids. All
 * creation events are captured for audit and compliance. Certain types may
 * require business validation (e.g., disallowing HR to send notifications on
 * behalf of systemAdmin). Field and template references must be valid and
 * reference permissible entity types according to business rules.
 *
 * @param props.connection
 * @param props.body Notification creation data: recipient, event type,
 *   reference business entity, and payload.
 * @path /atsRecruitment/systemAdmin/notifications
 * @accessor api.functional.atsRecruitment.systemAdmin.notifications.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Notification creation data: recipient, event type, reference business
     * entity, and payload.
     */
    body: IAtsRecruitmentNotification.ICreate;
  };
  export type Body = IAtsRecruitmentNotification.ICreate;
  export type Response = IAtsRecruitmentNotification;

  export const METADATA = {
    method: "POST",
    path: "/atsRecruitment/systemAdmin/notifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/atsRecruitment/systemAdmin/notifications";
  export const random = (): IAtsRecruitmentNotification =>
    typia.random<IAtsRecruitmentNotification>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search, filter, and paginate notification records in the ATS
 * (ats_recruitment_notifications).
 *
 * This endpoint enables advanced querying and paginated retrieval of
 * notification records, drawing from the ats_recruitment_notifications table.
 * Users can specify a variety of search and filter criteria, such as event type
 * (e.g., status updates, system alerts), delivery status (pending, sent,
 * failed), recipient roles (applicant, HR recruiter, tech reviewer,
 * systemAdmin), creation/update time ranges, and references to associated
 * business context (application, interview, export job, etc.).
 *
 * Authenticated users—admins, HR recruiters, and tech reviewers—use this
 * operation to manage, audit, or troubleshoot notification workflows. Granular
 * permission checks ensure users see only notifications relevant to their role
 * or those they are authorized to view. The API supports sorting, field
 * selection, and efficient pagination for large datasets, optimizing admin and
 * support workflows in large-scale recruitment operations.
 *
 * Error handling covers invalid filter requests, permissions issues, and server
 * failures. Related APIs include notification detail retrieval and raw
 * notification delivery logs, as part of comprehensive notification management
 * capabilities.
 *
 * @param props.connection
 * @param props.body Search, filtering, and pagination parameters for
 *   notifications
 * @path /atsRecruitment/systemAdmin/notifications
 * @accessor api.functional.atsRecruitment.systemAdmin.notifications.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filtering, and pagination parameters for notifications */
    body: IAtsRecruitmentNotification.IRequest;
  };
  export type Body = IAtsRecruitmentNotification.IRequest;
  export type Response = IPageIAtsRecruitmentNotification.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/systemAdmin/notifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/atsRecruitment/systemAdmin/notifications";
  export const random = (): IPageIAtsRecruitmentNotification.ISummary =>
    typia.random<IPageIAtsRecruitmentNotification.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detail for a specific notification event
 * (ats_recruitment_notifications).
 *
 * This endpoint provides a detailed view of an individual notification record,
 * returning all metadata and payload information associated with the given
 * notification ID. The API targets the ats_recruitment_notifications table and
 * is accessible to authorized users including system administrators, HR
 * recruiters, and tech reviewers.
 *
 * Information returned includes recipient (by user role and ID), event type,
 * reference entity (such as application, interview, export job), full
 * notification template payload, delivery status, timestamps, and any relevant
 * audit or system fields. Permission checks ensure a user can only access
 * notifications relevant to their role and privileges, in compliance with
 * privacy and business policies.
 *
 * This detailed retrieval operation supports notification management,
 * troubleshooting, and auditing workflows. Errors are returned for non-existent
 * records or permission violations. Used with the search (index) endpoint to
 * review and drill into system notification events.
 *
 * @param props.connection
 * @param props.notificationId Unique identifier of the notification to retrieve
 * @path /atsRecruitment/systemAdmin/notifications/:notificationId
 * @accessor api.functional.atsRecruitment.systemAdmin.notifications.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the notification to retrieve */
    notificationId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentNotification;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/systemAdmin/notifications/:notificationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): IAtsRecruitmentNotification =>
    typia.random<IAtsRecruitmentNotification>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a notification event's metadata/status/payload by notificationId
 * (ats_recruitment_notifications).
 *
 * This API allows privileged actors (such as systemAdmin, techReviewer, or
 * hrRecruiter depending on notification type) to update an existing
 * notification event, changing status or payload if needed for workflow
 * continuity or correction. Notification records are immutable for certain
 * statuses (e.g., after delivery), and audit trails are mandatory for
 * compliance.
 *
 * Typical use cases include adjusting notification status (e.g., from pending
 * to cancelled), correcting related entity references, or updating template
 * payload before final delivery. Attempting to update notifications already
 * processed (delivered or failed) will result in an error. Only system-level
 * roles and privileged notification creators should use this endpoint.
 *
 * All changes are logged and subject to business/process validation. Proper
 * permission checks and entity existence validation are performed for every
 * update request. This endpoint does not directly manage delivery attempts or
 * channel-level logs; it only updates notification record metadata and status.
 *
 * @param props.connection
 * @param props.notificationId Target notification's unique identifier.
 * @param props.body Fields for updating notification record: can include
 *   status, payload, or references.
 * @path /atsRecruitment/systemAdmin/notifications/:notificationId
 * @accessor api.functional.atsRecruitment.systemAdmin.notifications.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target notification's unique identifier. */
    notificationId: string & tags.Format<"uuid">;

    /**
     * Fields for updating notification record: can include status, payload,
     * or references.
     */
    body: IAtsRecruitmentNotification.IUpdate;
  };
  export type Body = IAtsRecruitmentNotification.IUpdate;
  export type Response = IAtsRecruitmentNotification;

  export const METADATA = {
    method: "PUT",
    path: "/atsRecruitment/systemAdmin/notifications/:notificationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/systemAdmin/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): IAtsRecruitmentNotification =>
    typia.random<IAtsRecruitmentNotification>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Hard delete a notification event by notificationId from
 * ats_recruitment_notifications (irreversible).
 *
 * This API allows a system administrator or privileged user to completely
 * remove a notification event record from the ATS system, based on its ID. The
 * operation is audited with complete before/after snapshot and rationale to
 * maintain compliance with notification audit and delivery policies.
 *
 * Notification deletion is subject to business validation: only undelivered,
 * failed, or cancelled notifications are usually permitted for deletion.
 * Delivered notifications may be subject to retention policies, and attempts to
 * delete them may be rejected by the API. Deletion not only removes the
 * business event metadata but also breaks any future processing for the
 * referenced business entity. The operation should be limited to administrative
 * and incident scenarios (e.g., removal of erroneous, misaddressed, or
 * privacy-violating notifications), not for routine workflow cleanup.
 *
 * This is a hard delete according to the table schema, not a soft delete;
 * deleted records are irrecoverable outside of system backup.
 *
 * @param props.connection
 * @param props.notificationId Unique identifier of the notification event to be
 *   deleted.
 * @path /atsRecruitment/systemAdmin/notifications/:notificationId
 * @accessor api.functional.atsRecruitment.systemAdmin.notifications.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the notification event to be deleted. */
    notificationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/atsRecruitment/systemAdmin/notifications/:notificationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/notifications/${encodeURIComponent(props.notificationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
