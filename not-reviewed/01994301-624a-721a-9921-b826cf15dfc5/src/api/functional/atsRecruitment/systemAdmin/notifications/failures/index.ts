import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentNotificationFailure } from "../../../../../structures/IAtsRecruitmentNotificationFailure";
import { IPageIAtsRecruitmentNotificationFailure } from "../../../../../structures/IPageIAtsRecruitmentNotificationFailure";

/**
 * Search and view paginated list of notification failure records
 * (ats_recruitment_notification_failures) for a notification.
 *
 * This endpoint allows authorized users (primarily system administrators and
 * possibly HR recruiters) to search and view the history of notification
 * delivery failures for a given notification. Notification failures record each
 * case where a notification could not be delivered through its intended
 * channel, including details such as failure type, error message, timestamp,
 * and associated delivery attempts.
 *
 * The operation supports search and filtering by various attributes such as
 * failure type, recipient channel, delivery status, message pattern, and date
 * ranges. Results are paginated for efficient review. This enables analysis of
 * recurring notification issues, tracking compliance with alerting policies,
 * and facilitating remediationâ€”such as resending or escalation.
 *
 * Access to failure records is typically restricted to admin roles due to
 * sensitivity around notification content and error data, and all queries are
 * logged for compliance.
 *
 * @param props.connection
 * @param props.notificationId Unique identifier of the notification whose
 *   failures are being queried.
 * @param props.body Search/filter and pagination parameters for notification
 *   failure records.
 * @path /atsRecruitment/systemAdmin/notifications/:notificationId/failures
 * @accessor api.functional.atsRecruitment.systemAdmin.notifications.failures.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the notification whose failures are being
     * queried.
     */
    notificationId: string & tags.Format<"uuid">;

    /**
     * Search/filter and pagination parameters for notification failure
     * records.
     */
    body: IAtsRecruitmentNotificationFailure.IRequest;
  };
  export type Body = IAtsRecruitmentNotificationFailure.IRequest;
  export type Response = IPageIAtsRecruitmentNotificationFailure.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/systemAdmin/notifications/:notificationId/failures",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/systemAdmin/notifications/${encodeURIComponent(props.notificationId ?? "null")}/failures`;
  export const random = (): IPageIAtsRecruitmentNotificationFailure.ISummary =>
    typia.random<IPageIAtsRecruitmentNotificationFailure.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a notification failure record
 * (ats_recruitment_notification_failures) by notificationId and failureId.
 *
 * This endpoint fetches the complete detail of a particular notification
 * failure event that occurred for a notification, as indexed by
 * 'notificationId' and the specific failure's 'failureId'. The record includes
 * information such as the failure mode (e.g., provider error, invalid address,
 * user opt-out), detailed error message from the provider or system, event
 * timestamp, and related delivery.
 *
 * The data is used to conduct compliance reviews, debug notification delivery
 * issues, and document problem trends. Access is restricted to system
 * administrators due to the sensitivity and potential for exposure of recipient
 * contact or operational error details.
 *
 * Error scenarios include non-existent notification/failureId or unauthorized
 * access. The operation is trace-logged for audit purposes. No request body is
 * required for this GET operation, and the result is a structured object with
 * full failure context.
 *
 * @param props.connection
 * @param props.notificationId Unique identifier for the parent notification
 *   event.
 * @param props.failureId Unique identifier for the failure record to retrieve.
 * @path /atsRecruitment/systemAdmin/notifications/:notificationId/failures/:failureId
 * @accessor api.functional.atsRecruitment.systemAdmin.notifications.failures.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the parent notification event. */
    notificationId: string & tags.Format<"uuid">;

    /** Unique identifier for the failure record to retrieve. */
    failureId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentNotificationFailure;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/systemAdmin/notifications/:notificationId/failures/:failureId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/notifications/${encodeURIComponent(props.notificationId ?? "null")}/failures/${encodeURIComponent(props.failureId ?? "null")}`;
  export const random = (): IAtsRecruitmentNotificationFailure =>
    typia.random<IAtsRecruitmentNotificationFailure>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationId")(() => typia.assert(props.notificationId));
      assert.param("failureId")(() => typia.assert(props.failureId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
