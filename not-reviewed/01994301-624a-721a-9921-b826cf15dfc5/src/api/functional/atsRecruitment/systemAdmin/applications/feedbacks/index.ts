import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentApplicationFeedback } from "../../../../../structures/IAtsRecruitmentApplicationFeedback";
import { IPageIAtsRecruitmentApplicationFeedback } from "../../../../../structures/IPageIAtsRecruitmentApplicationFeedback";

/**
 * Create a new feedback entry for an application
 * (ats_recruitment_application_feedback).
 *
 * Create a new feedback entry for a job application using this endpoint. Upon
 * submission, the system validates the reviewer's permission to provide
 * feedback for the referenced application and ensures data integrity for
 * feedback body, rating, and the recommendation status fields.
 *
 * This feedback mechanism enhances transparency in the candidate evaluation
 * process and supports structured collaboration among HR recruiters and
 * technical reviewers. The API enforces a unique reviewerâ€“application feedback
 * combination to prevent duplicate entries for the same reviewer and
 * application.
 *
 * This operation directly interacts with the
 * ats_recruitment_application_feedback table as defined in the Prisma schema,
 * populating all relevant columns. Access to this endpoint is controlled to
 * ensure only designated reviewers (HR, technical reviewers, or authorized
 * admins) can submit feedback for an application. Business logic includes
 * validation of the application existence, reviewer eligibility, and correct
 * feedback data structure. Error handling provides responses for unauthorized
 * access, validation failures, or constraint violations (such as duplicate
 * feedback).
 *
 * @param props.connection
 * @param props.applicationId Unique identifier for the application to which the
 *   feedback is being added.
 * @param props.body Feedback creation payload, including reviewer, body,
 *   rating, and recommendation flag.
 * @path /atsRecruitment/systemAdmin/applications/:applicationId/feedbacks
 * @accessor api.functional.atsRecruitment.systemAdmin.applications.feedbacks.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier for the application to which the feedback is being
     * added.
     */
    applicationId: string & tags.Format<"uuid">;

    /**
     * Feedback creation payload, including reviewer, body, rating, and
     * recommendation flag.
     */
    body: IAtsRecruitmentApplicationFeedback.ICreate;
  };
  export type Body = IAtsRecruitmentApplicationFeedback.ICreate;
  export type Response = IAtsRecruitmentApplicationFeedback;

  export const METADATA = {
    method: "POST",
    path: "/atsRecruitment/systemAdmin/applications/:applicationId/feedbacks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/systemAdmin/applications/${encodeURIComponent(props.applicationId ?? "null")}/feedbacks`;
  export const random = (): IAtsRecruitmentApplicationFeedback =>
    typia.random<IAtsRecruitmentApplicationFeedback>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("applicationId")(() => typia.assert(props.applicationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a paginated, filtered list of feedback for an application
 * (ats_recruitment_application_feedback table).
 *
 * This operation enables authorized HR recruiters, tech reviewers, or system
 * administrators to retrieve a paginated and filtered list of feedback entries
 * for a specific job application. Feedback records are stored in the
 * ats_recruitment_application_feedback table and may be created by both HR
 * recruiters and tech reviewers, with each entry containing reviewer identity,
 * textual feedback, rating, and recommendation status.
 *
 * Search and filtering can include attributes such as reviewer ID, date ranges,
 * numerical ratings, and whether the feedback is the final recommendation.
 * Pagination is supported to handle large numbers of feedbacks efficiently.
 * Responses are formatted as a page of summary feedback records, ensuring
 * scalability and performance for operational review panels.
 *
 * Security restricts access to authorized users and ensures sensitive feedback
 * content is only presented to permitted HR, reviewer, or administrator roles.
 * All access to feedback records should be logged for compliance and audit.
 * Business logic may restrict views to only non-deleted or appropriately
 * filtered feedback.
 *
 * @param props.connection
 * @param props.applicationId Unique identifier of the job application whose
 *   feedbacks are being queried.
 * @param props.body Pagination, filtering, and sorting criteria for feedback
 *   search.
 * @path /atsRecruitment/systemAdmin/applications/:applicationId/feedbacks
 * @accessor api.functional.atsRecruitment.systemAdmin.applications.feedbacks.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the job application whose feedbacks are being
     * queried.
     */
    applicationId: string & tags.Format<"uuid">;

    /** Pagination, filtering, and sorting criteria for feedback search. */
    body: IAtsRecruitmentApplicationFeedback.IRequest;
  };
  export type Body = IAtsRecruitmentApplicationFeedback.IRequest;
  export type Response = IPageIAtsRecruitmentApplicationFeedback.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/systemAdmin/applications/:applicationId/feedbacks",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/systemAdmin/applications/${encodeURIComponent(props.applicationId ?? "null")}/feedbacks`;
  export const random = (): IPageIAtsRecruitmentApplicationFeedback.ISummary =>
    typia.random<IPageIAtsRecruitmentApplicationFeedback.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("applicationId")(() => typia.assert(props.applicationId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific feedback entry for an application
 * (ats_recruitment_application_feedback).
 *
 * Fetch the details of a particular feedback entry associated with a job
 * application from the ATS system's application feedback table. This API allows
 * HR recruiters and tech reviewers to retrieve comprehensive feedback
 * information, encompassing fields such as feedback text, reviewer
 * identification, associated application, rating, final recommendation flag,
 * and creation timestamp.
 *
 * Proper authorization is required to access this endpoint, typically limiting
 * access to HR, tech reviewers, or admins with assignments to the targeted
 * application. Reviewing the feedback promotes transparency in the evaluation
 * process and supports compliance with audit and reporting needs.
 *
 * The operation references 'ats_recruitment_application_feedback' and validates
 * that the referenced feedbackId is associated with the specified
 * applicationId. Error handling covers invalid UUIDs, unauthorized access
 * attempts, or missing feedback records.
 *
 * @param props.connection
 * @param props.applicationId Unique identifier of the target application
 *   containing the feedback.
 * @param props.feedbackId Unique identifier of the feedback entry to retrieve.
 * @path /atsRecruitment/systemAdmin/applications/:applicationId/feedbacks/:feedbackId
 * @accessor api.functional.atsRecruitment.systemAdmin.applications.feedbacks.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target application containing the feedback. */
    applicationId: string & tags.Format<"uuid">;

    /** Unique identifier of the feedback entry to retrieve. */
    feedbackId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentApplicationFeedback;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/systemAdmin/applications/:applicationId/feedbacks/:feedbackId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/applications/${encodeURIComponent(props.applicationId ?? "null")}/feedbacks/${encodeURIComponent(props.feedbackId ?? "null")}`;
  export const random = (): IAtsRecruitmentApplicationFeedback =>
    typia.random<IAtsRecruitmentApplicationFeedback>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("applicationId")(() => typia.assert(props.applicationId));
      assert.param("feedbackId")(() => typia.assert(props.feedbackId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing feedback entry for an application
 * (ats_recruitment_application_feedback).
 *
 * Update a specific feedback entry for an application using this endpoint. The
 * operation enforces reviewer identity and permission, ensuring only the
 * original reviewer or appropriately privileged actors can alter an existing
 * feedback record.
 *
 * The update process applies changes to fields such as feedback body, rating,
 * and the is_final_recommendation flag while maintaining an audit trail of
 * modifications. Updates must comply with table uniqueness constraints, and
 * only authorized users assigned to the application or with system-level
 * privileges may perform changes.
 *
 * Business logic includes validation of feedback existence, reviewer-authority
 * linkage, and data structure of the update body. Proper error handling ensures
 * clients are informed of unauthorized attempts, record-not-found scenarios, or
 * update constraint violations.
 *
 * @param props.connection
 * @param props.applicationId Unique identifier for the application containing
 *   the feedback to update.
 * @param props.feedbackId Unique identifier of the feedback entry to update.
 * @param props.body Payload with fields to be updated for the feedback entry.
 * @path /atsRecruitment/systemAdmin/applications/:applicationId/feedbacks/:feedbackId
 * @accessor api.functional.atsRecruitment.systemAdmin.applications.feedbacks.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier for the application containing the feedback to
     * update.
     */
    applicationId: string & tags.Format<"uuid">;

    /** Unique identifier of the feedback entry to update. */
    feedbackId: string & tags.Format<"uuid">;

    /** Payload with fields to be updated for the feedback entry. */
    body: IAtsRecruitmentApplicationFeedback.IUpdate;
  };
  export type Body = IAtsRecruitmentApplicationFeedback.IUpdate;
  export type Response = IAtsRecruitmentApplicationFeedback;

  export const METADATA = {
    method: "PUT",
    path: "/atsRecruitment/systemAdmin/applications/:applicationId/feedbacks/:feedbackId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/systemAdmin/applications/${encodeURIComponent(props.applicationId ?? "null")}/feedbacks/${encodeURIComponent(props.feedbackId ?? "null")}`;
  export const random = (): IAtsRecruitmentApplicationFeedback =>
    typia.random<IAtsRecruitmentApplicationFeedback>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("applicationId")(() => typia.assert(props.applicationId));
      assert.param("feedbackId")(() => typia.assert(props.feedbackId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a feedback entry for an application
 * (ats_recruitment_application_feedback).
 *
 * Permanently delete a feedback entry for a job application using this
 * endpoint. Only the reviewer who authored the feedback or a system
 * administrator may perform deletion actions. The system validates both user
 * authorization and the association between feedbackId and applicationId before
 * executing the operation.
 *
 * The underlying schema for ats_recruitment_application_feedback does not
 * include soft delete fields; therefore, deletions are permanent and
 * unrecoverable. Audit logs of such actions may be maintained in the system
 * (separately) for compliance, but the record itself is removed from the
 * business table.
 *
 * Access is strictly controlled to prevent unauthorized or accidental data
 * loss. Proper error handling includes responses for invalid IDs, missing
 * records, unauthorized access, and business logic conflicts (such as
 * attempting to delete feedback not associated with the specified
 * application).
 *
 * @param props.connection
 * @param props.applicationId Unique identifier for the application containing
 *   the feedback to delete.
 * @param props.feedbackId Unique identifier of the feedback entry to delete.
 * @path /atsRecruitment/systemAdmin/applications/:applicationId/feedbacks/:feedbackId
 * @accessor api.functional.atsRecruitment.systemAdmin.applications.feedbacks.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier for the application containing the feedback to
     * delete.
     */
    applicationId: string & tags.Format<"uuid">;

    /** Unique identifier of the feedback entry to delete. */
    feedbackId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/atsRecruitment/systemAdmin/applications/:applicationId/feedbacks/:feedbackId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/systemAdmin/applications/${encodeURIComponent(props.applicationId ?? "null")}/feedbacks/${encodeURIComponent(props.feedbackId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("applicationId")(() => typia.assert(props.applicationId));
      assert.param("feedbackId")(() => typia.assert(props.feedbackId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
