import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAtsRecruitmentResumeFile } from "../../../../../structures/IAtsRecruitmentResumeFile";
import { IAtsRecruitmentResumeUploadHistory } from "../../../../../structures/IAtsRecruitmentResumeUploadHistory";
import { IPageIAtsRecruitmentResumeUploadHistory } from "../../../../../structures/IPageIAtsRecruitmentResumeUploadHistory";

/**
 * Upload or replace a resume file for an existing applicant resume
 * (ats_recruitment_resume_files).
 *
 * This API operation allows applicants to upload a new or replacement file to
 * their resume by targeting an existing resume record. The file must comply
 * with policy constraints—only PDF and DOCX file types are accepted, files must
 * not exceed 10MB, and each resume can have only one current file attached
 * (replacing prior uploads).
 *
 * For security and auditability, the operation records metadata including
 * original filename, permanent object storage URI, extension, file size, and
 * upload timestamp on the ats_recruitment_resume_files table. Upon uploading a
 * new file, any existing file record for this resume is replaced according to
 * the unique constraint on ats_recruitment_resume_files. Resume parsing, OCR/AI
 * analysis, and applicant data extraction workflows may be triggered
 * asynchronously after upload.
 *
 * Authorization ensures that only the resume's owner (applicant) can upload
 * files to their resume. Attempting to upload files with disallowed extensions
 * or oversized files will yield validation errors. Upload actions are captured
 * for compliance, and file metadata is available for subsequent resume parsing
 * and analysis automation. Typical error handling includes guidance for
 * unsupported format, over-size, or unexpected server errors.
 *
 * @param props.connection
 * @param props.resumeId The unique identifier of the resume to which the file
 *   will be attached or replaced.
 * @param props.body Resume file metadata and storage details for upload
 *   (PDF/DOCX, max 10MB).
 * @path /atsRecruitment/applicant/resumes/:resumeId/files
 * @accessor api.functional.atsRecruitment.applicant.resumes.files.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * The unique identifier of the resume to which the file will be
     * attached or replaced.
     */
    resumeId: string & tags.Format<"uuid">;

    /**
     * Resume file metadata and storage details for upload (PDF/DOCX, max
     * 10MB).
     */
    body: IAtsRecruitmentResumeFile.ICreate;
  };
  export type Body = IAtsRecruitmentResumeFile.ICreate;
  export type Response = IAtsRecruitmentResumeFile;

  export const METADATA = {
    method: "POST",
    path: "/atsRecruitment/applicant/resumes/:resumeId/files",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/applicant/resumes/${encodeURIComponent(props.resumeId ?? "null")}/files`;
  export const random = (): IAtsRecruitmentResumeFile =>
    typia.random<IAtsRecruitmentResumeFile>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("resumeId")(() => typia.assert(props.resumeId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get file upload histories for a specific resume from
 * ats_recruitment_resume_upload_histories table.
 *
 * This endpoint provides authenticated applicants with visibility into their
 * historical file upload attempts for a specific resume, as maintained in the
 * ats_recruitment_resume_upload_histories table. Each record displays the file
 * meta, timestamp, file size, and parsing summary at the time of upload.
 *
 * Applicants can use this information for version management, tracking
 * replacements, or reviewing accidental upload events. Management and
 * inspection of this audit trail helps resolve user support scenarios related
 * to lost, overwritten, or corrupted files. Pagination and advanced
 * filtering/sorting are supported to manage large upload histories. Only the
 * owner applicant can access this history; all queries enforce strict
 * permission checks to protect personal data.
 *
 * @param props.connection
 * @param props.resumeId Unique identifier of the resume whose upload files
 *   history is being queried
 * @param props.body Request parameters for upload history listing, supports
 *   advanced filters and pagination
 * @path /atsRecruitment/applicant/resumes/:resumeId/files
 * @accessor api.functional.atsRecruitment.applicant.resumes.files.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the resume whose upload files history is being
     * queried
     */
    resumeId: string & tags.Format<"uuid">;

    /**
     * Request parameters for upload history listing, supports advanced
     * filters and pagination
     */
    body: IAtsRecruitmentResumeUploadHistory.IRequest;
  };
  export type Body = IAtsRecruitmentResumeUploadHistory.IRequest;
  export type Response = IPageIAtsRecruitmentResumeUploadHistory;

  export const METADATA = {
    method: "PATCH",
    path: "/atsRecruitment/applicant/resumes/:resumeId/files",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/applicant/resumes/${encodeURIComponent(props.resumeId ?? "null")}/files`;
  export const random = (): IPageIAtsRecruitmentResumeUploadHistory =>
    typia.random<IPageIAtsRecruitmentResumeUploadHistory>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("resumeId")(() => typia.assert(props.resumeId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get uploaded resume file metadata (for download/inspect) from
 * ats_recruitment_resume_files table.
 *
 * This API endpoint enables an authenticated applicant to view metadata details
 * about a particular uploaded resume file associated with their resume. The
 * record is returned from the ats_recruitment_resume_files table, including
 * information such as file name, file extension, file size, upload timestamp,
 * and storage URI.
 *
 * This function is typically used when displaying document information on an
 * applicant's dashboard, before allowing file downloads or integrity
 * verification. Only the file's owner (the applicant who uploaded the resume)
 * is permitted to access this information. Attempts to access files for resumes
 * not belonging to the applicant, or where the referenced fileId does not tie
 * back to the resumeId, result in a forbidden or not found error.
 *
 * System audit trails enforce compliance with data protection policies, and all
 * access is logged for privacy and support analysis.
 *
 * @param props.connection
 * @param props.resumeId Identifier of the parent resume
 * @param props.fileId Identifier of the resume file record to retrieve
 * @path /atsRecruitment/applicant/resumes/:resumeId/files/:fileId
 * @accessor api.functional.atsRecruitment.applicant.resumes.files.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the parent resume */
    resumeId: string & tags.Format<"uuid">;

    /** Identifier of the resume file record to retrieve */
    fileId: string & tags.Format<"uuid">;
  };
  export type Response = IAtsRecruitmentResumeFile;

  export const METADATA = {
    method: "GET",
    path: "/atsRecruitment/applicant/resumes/:resumeId/files/:fileId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/applicant/resumes/${encodeURIComponent(props.resumeId ?? "null")}/files/${encodeURIComponent(props.fileId ?? "null")}`;
  export const random = (): IAtsRecruitmentResumeFile =>
    typia.random<IAtsRecruitmentResumeFile>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("resumeId")(() => typia.assert(props.resumeId));
      assert.param("fileId")(() => typia.assert(props.fileId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update metadata for an uploaded resume file (ats_recruitment_resume_files).
 *
 * This API operation allows an applicant to update descriptive metadata about
 * their previously uploaded resume file (such as display name, labeling, or
 * additional tags used for auditing or internal search). It does not permit the
 * actual binary file or object storage URI to be changed—file replacements are
 * only possible via a dedicated upload/replace operation.
 *
 * Use cases include correcting display titles, marking tags for filtering, or
 * providing comments on file use. Modifications are audited, and only the
 * file's owner (the applicant) is authorized to perform updates. Operations
 * attempting to alter immutable or storage-related fields will result in
 * validation errors. All changes are tracked for compliance and data lineage
 * requirements.
 *
 * @param props.connection
 * @param props.resumeId The unique identifier of the resume record to which the
 *   file belongs.
 * @param props.fileId The unique identifier of the file record to update.
 * @param props.body Metadata fields for updating descriptive properties of the
 *   resume file (not the binary file itself).
 * @path /atsRecruitment/applicant/resumes/:resumeId/files/:fileId
 * @accessor api.functional.atsRecruitment.applicant.resumes.files.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier of the resume record to which the file belongs. */
    resumeId: string & tags.Format<"uuid">;

    /** The unique identifier of the file record to update. */
    fileId: string & tags.Format<"uuid">;

    /**
     * Metadata fields for updating descriptive properties of the resume
     * file (not the binary file itself).
     */
    body: IAtsRecruitmentResumeFile.IUpdate;
  };
  export type Body = IAtsRecruitmentResumeFile.IUpdate;
  export type Response = IAtsRecruitmentResumeFile;

  export const METADATA = {
    method: "PUT",
    path: "/atsRecruitment/applicant/resumes/:resumeId/files/:fileId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/atsRecruitment/applicant/resumes/${encodeURIComponent(props.resumeId ?? "null")}/files/${encodeURIComponent(props.fileId ?? "null")}`;
  export const random = (): IAtsRecruitmentResumeFile =>
    typia.random<IAtsRecruitmentResumeFile>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("resumeId")(() => typia.assert(props.resumeId));
      assert.param("fileId")(() => typia.assert(props.fileId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (logical remove) a resume file for a given applicant resume
 * (ats_recruitment_resume_files).
 *
 * This API operation enables applicants to remove their uploaded resume files.
 * Rather than hard-deleting the file from storage (which may violate audit/GDPR
 * compliance), the operation sets the 'deleted_at' field to mark the file as
 * deleted, allowing for recovery if needed and ensuring audit trail
 * continuity.
 *
 * Only the applicant who owns the resume and file may invoke this operation.
 * Attempting to delete files for resumes not owned by the applicant is denied.
 * Once deleted, the file is no longer accessible from resume-related queries,
 * and the deletion action is recorded for audit purposes. Actual blob/object
 * file removal may be conducted periodically in accordance with policy or
 * compliance requirements. Error handling includes validation of existence,
 * authorization, and conflict scenarios (such as already deleted files).
 *
 * @param props.connection
 * @param props.resumeId The unique identifier of the resume record whose file
 *   is to be deleted.
 * @param props.fileId The unique identifier of the resume file to delete.
 * @path /atsRecruitment/applicant/resumes/:resumeId/files/:fileId
 * @accessor api.functional.atsRecruitment.applicant.resumes.files.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * The unique identifier of the resume record whose file is to be
     * deleted.
     */
    resumeId: string & tags.Format<"uuid">;

    /** The unique identifier of the resume file to delete. */
    fileId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/atsRecruitment/applicant/resumes/:resumeId/files/:fileId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/atsRecruitment/applicant/resumes/${encodeURIComponent(props.resumeId ?? "null")}/files/${encodeURIComponent(props.fileId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("resumeId")(() => typia.assert(props.resumeId));
      assert.param("fileId")(() => typia.assert(props.fileId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
