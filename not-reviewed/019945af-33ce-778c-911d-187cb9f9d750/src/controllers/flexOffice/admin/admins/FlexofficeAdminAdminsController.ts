import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { patchflexOfficeAdminAdmins } from "../../../../providers/patchflexOfficeAdminAdmins";
import { AdminAuth } from "../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../decorators/payload/AdminPayload";
import { getflexOfficeAdminAdminsAdminId } from "../../../../providers/getflexOfficeAdminAdminsAdminId";
import { putflexOfficeAdminAdminsAdminId } from "../../../../providers/putflexOfficeAdminAdminsAdminId";
import { deleteflexOfficeAdminAdminsAdminId } from "../../../../providers/deleteflexOfficeAdminAdminsAdminId";

import { IPageIFlexOfficeAdmin } from "../../../../api/structures/IPageIFlexOfficeAdmin";
import { IFlexOfficeAdmin } from "../../../../api/structures/IFlexOfficeAdmin";

@Controller("/flexOffice/admin/admins")
export class FlexofficeAdminAdminsController {
  /**
   * List administrative user accounts with pagination and filtering.
   *
   * Retrieve a filtered, paginated list of administrative user accounts. This
   * operation supports advanced search criteria such as email filtering, date
   * ranges, and sorting preferences.
   *
   * Security: Only users with the admin role are authorized to access this
   * endpoint.
   *
   * Relationships: Admin users are unique by email and have associated activity
   * logs and role assignments.
   *
   * Validation: Search parameters are validated for correctness.
   *
   * Expected behavior: Returns paginated summaries of admins according to query
   * criteria. Errors are handled gracefully with appropriate status codes and
   * messages.
   *
   * @param connection
   * @param body Search criteria and pagination parameters for admin filtering
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async searchAdmins(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: IFlexOfficeAdmin.IRequest,
  ): Promise<IPageIFlexOfficeAdmin.ISummary> {
    try {
      return await patchflexOfficeAdminAdmins({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get detailed information of an admin user by ID.
   *
   * Get detailed information about a specific admin user by their unique
   * adminId. Returns the admin's email, timestamps, and deletion status if
   * applicable.
   *
   * Security: Only users with admin role can access detailed admin information.
   *
   * Relationships: Admin users have unique emails and may have linked activity
   * logs and role assignments.
   *
   * Validation: The adminId must be a valid UUID and exist in the database.
   *
   * Expected behavior: Returns the detailed admin record matching the given id.
   * Errors are returned if the id is invalid or not found.
   *
   * @param connection
   * @param adminId Unique identifier of the admin user
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":adminId")
  public async atAdmin(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("adminId")
    adminId: string & tags.Format<"uuid">,
  ): Promise<IFlexOfficeAdmin> {
    try {
      return await getflexOfficeAdminAdminsAdminId({
        admin,
        adminId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing admin user by ID.
   *
   * This operation updates an existing Admin user in the FlexOffice system. The
   * admin is uniquely identified by their adminId, a UUID string. The operation
   * accepts updated admin data including email and password hash, which must be
   * unique and securely stored.
   *
   * Security considerations ensure only authorized users can perform admin
   * updates, preserving account integrity.
   *
   * Underlying data references the flex_office_admins table with fields for
   * email, password_hash, and audit timestamps. Soft deletion (deleted_at) is
   * tracked but not modified via this endpoint.
   *
   * Validation rules include ensuring email uniqueness and proper UUID format
   * for the adminId path parameter.
   *
   * Related admin management APIs include delete by adminId (this API's
   * complement) and admin creation APIs.
   *
   * On success, returns the updated Admin user entity reflecting persisted
   * data.
   *
   * Error handling includes 404 if the adminId does not exist and validation
   * errors for duplicate email or invalid input.
   *
   * @param connection
   * @param adminId Unique identifier of the admin user to update
   * @param body Admin user update payload
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":adminId")
  public async updateAdmin(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("adminId")
    adminId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficeAdmin.IUpdate,
  ): Promise<IFlexOfficeAdmin> {
    try {
      return await putflexOfficeAdminAdminsAdminId({
        admin,
        adminId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Permanently delete an admin user by ID.
   *
   * This operation permanently deletes an Admin user from the FlexOffice system
   * identified by adminId, effectively removing all related data. This is a
   * hard delete operation with no soft deletion semantics.
   *
   * Only authorized admin users can execute this operation.
   *
   * The flex_office_admins database table is directly affected, removing the
   * record where id matches adminId.
   *
   * Caller must handle irreversibility and audit compliance externally.
   *
   * On success, no content is returned.
   *
   * Errors include 404 if adminId is not found and authorization errors if
   * caller lacks permissions.
   *
   * @param connection
   * @param adminId Unique identifier of the admin user to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":adminId")
  public async eraseAdmin(
    @AdminAuth()
    admin: AdminPayload,
    @TypedParam("adminId")
    adminId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteflexOfficeAdminAdminsAdminId({
        admin,
        adminId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
