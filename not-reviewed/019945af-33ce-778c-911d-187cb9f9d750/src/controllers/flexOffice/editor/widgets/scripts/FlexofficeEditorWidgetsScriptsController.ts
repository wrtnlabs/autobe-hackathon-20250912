import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postflexOfficeEditorWidgetsWidgetIdScripts } from "../../../../../providers/postflexOfficeEditorWidgetsWidgetIdScripts";
import { EditorAuth } from "../../../../../decorators/EditorAuth";
import { EditorPayload } from "../../../../../decorators/payload/EditorPayload";
import { patchflexOfficeEditorWidgetsWidgetIdScripts } from "../../../../../providers/patchflexOfficeEditorWidgetsWidgetIdScripts";
import { getflexOfficeEditorWidgetsWidgetIdScriptsScriptId } from "../../../../../providers/getflexOfficeEditorWidgetsWidgetIdScriptsScriptId";
import { putflexOfficeEditorWidgetsWidgetIdScriptsScriptId } from "../../../../../providers/putflexOfficeEditorWidgetsWidgetIdScriptsScriptId";
import { deleteflexOfficeEditorWidgetsWidgetIdScriptsScriptId } from "../../../../../providers/deleteflexOfficeEditorWidgetsWidgetIdScriptsScriptId";

import { IFlexOfficeWidgetScript } from "../../../../../api/structures/IFlexOfficeWidgetScript";
import { IPageIFlexOfficeWidgetScript } from "../../../../../api/structures/IPageIFlexOfficeWidgetScript";

@Controller("/flexOffice/editor/widgets/:widgetId/scripts")
export class FlexofficeEditorWidgetsScriptsController {
  /**
   * Create widget script for a widget.
   *
   * Create a new script associated with a widget specified by widgetId. Input
   * includes script type and content.
   *
   * Validates access permissions.
   *
   * Returns detailed information of the created script.
   *
   * Rejects malformed input or unauthorized access.
   *
   * @param connection
   * @param widgetId Unique identifier of the target widget
   * @param body Information required to create a widget script
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("widgetId")
    widgetId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficeWidgetScript.ICreate,
  ): Promise<IFlexOfficeWidgetScript> {
    try {
      return await postflexOfficeEditorWidgetsWidgetIdScripts({
        editor,
        widgetId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List widget scripts for a widget with pagination and filtering.
   *
   * Retrieve a paginated and filtered list of scripts associated with the
   * widget identified by widgetId. Supports comprehensive filtering, sorting,
   * and pagination capabilities.
   *
   * Security enforcement ensures only authorized users can access the widget's
   * scripts.
   *
   * The response provides concise script summaries suitable for listing and
   * browsing.
   *
   * All requested scripts correspond to the target widgetId.
   *
   * Returns errors if widgetId is invalid or access is unauthorized.
   *
   * @param connection
   * @param widgetId Unique identifier of the target widget
   * @param body Filtering, pagination, and sorting criteria for fetching widget
   *   scripts
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("widgetId")
    widgetId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficeWidgetScript.IRequest,
  ): Promise<IPageIFlexOfficeWidgetScript.ISummary> {
    try {
      return await patchflexOfficeEditorWidgetsWidgetIdScripts({
        editor,
        widgetId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get widget script details by widgetId and scriptId.
   *
   * Retrieve detailed information for a widget script specified by scriptId
   * under the widget identified by widgetId.
   *
   * Includes full script metadata and source content.
   *
   * Requires valid UUIDs for widgetId and scriptId.
   *
   * Access control restricts to authorized users.
   *
   * Returns 404 if not found or access denied.
   *
   * @param connection
   * @param widgetId Unique identifier of the target widget
   * @param scriptId Unique identifier of the target script
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":scriptId")
  public async at(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("widgetId")
    widgetId: string & tags.Format<"uuid">,
    @TypedParam("scriptId")
    scriptId: string & tags.Format<"uuid">,
  ): Promise<IFlexOfficeWidgetScript> {
    try {
      return await getflexOfficeEditorWidgetsWidgetIdScriptsScriptId({
        editor,
        widgetId,
        scriptId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update widget script for a given widget.
   *
   * Update a widget script identified by scriptId under the widget identified
   * by widgetId. Input body contains script update details.
   *
   * Validates user authorization.
   *
   * Returns full updated script information.
   *
   * Errors if script does not exist or access denied.
   *
   * @param connection
   * @param widgetId Unique identifier of the target widget
   * @param scriptId Unique identifier of the target script
   * @param body Details to update widget script
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":scriptId")
  public async update(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("widgetId")
    widgetId: string & tags.Format<"uuid">,
    @TypedParam("scriptId")
    scriptId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficeWidgetScript.IUpdate,
  ): Promise<IFlexOfficeWidgetScript> {
    try {
      return await putflexOfficeEditorWidgetsWidgetIdScriptsScriptId({
        editor,
        widgetId,
        scriptId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete a UI widget script by ID.
   *
   * Deletes a UI widget script from the system given the widgetId and scriptId.
   * This operation permanently removes the script record from the
   * flex_office_widget_scripts table and cannot be undone.
   *
   * Security considerations dictate that only Admin and Editor roles with
   * proper authorizations can perform this action.
   *
   * The operation requires both widgetId and scriptId path parameters, both
   * UUIDs, to identify the target script associated with the widget.
   *
   * Errors may include resource not found or unauthorized access, which are
   * appropriately handled.
   *
   * There is no request body or response content for this operation.
   *
   * @param connection
   * @param widgetId Unique identifier of the UI widget
   * @param scriptId Unique identifier of the widget script to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":scriptId")
  public async erase(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("widgetId")
    widgetId: string & tags.Format<"uuid">,
    @TypedParam("scriptId")
    scriptId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteflexOfficeEditorWidgetsWidgetIdScriptsScriptId({
        editor,
        widgetId,
        scriptId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
