import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postflexOfficeEditorPagesPageIdWidgets } from "../../../../../providers/postflexOfficeEditorPagesPageIdWidgets";
import { EditorAuth } from "../../../../../decorators/EditorAuth";
import { EditorPayload } from "../../../../../decorators/payload/EditorPayload";
import { patchflexOfficeEditorPagesPageIdWidgets } from "../../../../../providers/patchflexOfficeEditorPagesPageIdWidgets";
import { getflexOfficeEditorPagesPageIdWidgetsWidgetId } from "../../../../../providers/getflexOfficeEditorPagesPageIdWidgetsWidgetId";
import { putflexOfficeEditorPagesPageIdWidgetsWidgetId } from "../../../../../providers/putflexOfficeEditorPagesPageIdWidgetsWidgetId";
import { deleteflexOfficeEditorPagesPageIdWidgetsWidgetId } from "../../../../../providers/deleteflexOfficeEditorPagesPageIdWidgetsWidgetId";

import { IFlexOfficeWidget } from "../../../../../api/structures/IFlexOfficeWidget";
import { IPageIFlexOfficeWidget } from "../../../../../api/structures/IPageIFlexOfficeWidget";

@Controller("/flexOffice/editor/pages/:pageId/widgets")
export class FlexofficeEditorPagesWidgetsController {
  /**
   * Create a new widget in a UI page.
   *
   * Create a new widget in the specified page. The operation accepts widget
   * properties including type, name, and optional configuration JSON.
   *
   * Only users with admin or editor roles can perform this creation.
   *
   * Request body must conform to the structure of IFlexOfficeWidget.ICreate
   * with required fields.
   *
   * On success, returns the full representation of the created widget.
   *
   * Errors may include validation failures if widget name duplicates or
   * widgetType is missing.
   *
   * @param connection
   * @param pageId Unique identifier of the target page
   * @param body Properties required to create a new widget
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageId")
    pageId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficeWidget.ICreate,
  ): Promise<IFlexOfficeWidget> {
    try {
      return await postflexOfficeEditorPagesPageIdWidgets({
        editor,
        pageId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and list widgets on a UI page with pagination and filters.
   *
   * Retrieve a paginated list of widgets on the specified UI page. Supports
   * filtering by widget type, name, and status.
   *
   * Only users with 'admin' or 'editor' roles can access this data.
   *
   * Supports pagination parameters such as page number and size to handle large
   * sets.
   *
   * Includes summary widget details optimized for listing.
   *
   * Related operations allow managing individual widgets and scripts
   * separately.
   *
   * @param connection
   * @param pageId Unique identifier of the page whose widgets are to be
   *   retrieved
   * @param body Search, filter, and pagination parameters for widgets.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageId")
    pageId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficeWidget.IRequest,
  ): Promise<IPageIFlexOfficeWidget.ISummary> {
    try {
      return await patchflexOfficeEditorPagesPageIdWidgets({
        editor,
        pageId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get details of a specific widget by pageId and widgetId.
   *
   * Retrieve detailed information about a specific widget associated with a
   * given UI page. This operation fetches data from the 'flex_office_widgets'
   * table, which stores widget characteristics including type, name, and
   * configuration details.
   *
   * Users accessing this endpoint must be authenticated and authorized as
   * admins, editors, or viewers to ensure appropriate access control.
   *
   * The response includes all persistent fields of the widget, such as
   * timestamps and soft-deletion status, providing comprehensive insight into
   * the widget's current configuration and state.
   *
   * Typical error responses include not found if the widget or page does not
   * exist, or unauthorized access if the user lacks sufficient permissions.
   *
   * This operation integrates with the UI/Page Builder frontend to support
   * widget editing and display workflows.
   *
   * @param connection
   * @param pageId Unique identifier of the target page
   * @param widgetId Unique identifier of the target widget
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":widgetId")
  public async at(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageId")
    pageId: string & tags.Format<"uuid">,
    @TypedParam("widgetId")
    widgetId: string & tags.Format<"uuid">,
  ): Promise<IFlexOfficeWidget> {
    try {
      return await getflexOfficeEditorPagesPageIdWidgetsWidgetId({
        editor,
        pageId,
        widgetId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing widget by pageId and widgetId.
   *
   * Update an existing widget of a given page, identified by widgetId.
   *
   * This operation modifies widget properties including name, type, and
   * configuration.
   *
   * Only users with admin or editor roles may update widgets.
   *
   * Returns the updated widget entity upon success.
   *
   * Validation errors or unauthorized access are possible failure modes.
   *
   * @param connection
   * @param pageId Unique identifier of the target page
   * @param widgetId Unique identifier of the target widget
   * @param body Properties to update on the widget
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":widgetId")
  public async update(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageId")
    pageId: string & tags.Format<"uuid">,
    @TypedParam("widgetId")
    widgetId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficeWidget.IUpdate,
  ): Promise<IFlexOfficeWidget> {
    try {
      return await putflexOfficeEditorPagesPageIdWidgetsWidgetId({
        editor,
        pageId,
        widgetId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete a widget from a page.
   *
   * Delete a widget from a specific page permanently. This removes the widget
   * record from the database.
   *
   * Only users with admin or editor roles may perform deletion.
   *
   * No request body required.
   *
   * Clients should handle errors such as widget not found or unauthorized
   * access.
   *
   * This operation employs hard deletion despite the presence of 'deleted_at'
   * for soft delete support in the database.
   *
   * @param connection
   * @param pageId Unique identifier of the target page
   * @param widgetId Unique identifier of the target widget
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":widgetId")
  public async erase(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageId")
    pageId: string & tags.Format<"uuid">,
    @TypedParam("widgetId")
    widgetId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteflexOfficeEditorPagesPageIdWidgetsWidgetId({
        editor,
        pageId,
        widgetId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
