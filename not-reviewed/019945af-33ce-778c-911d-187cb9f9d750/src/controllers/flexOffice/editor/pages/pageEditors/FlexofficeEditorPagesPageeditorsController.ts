import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postflexOfficeEditorPagesPageIdPageEditors } from "../../../../../providers/postflexOfficeEditorPagesPageIdPageEditors";
import { EditorAuth } from "../../../../../decorators/EditorAuth";
import { EditorPayload } from "../../../../../decorators/payload/EditorPayload";
import { patchflexOfficeEditorPagesPageIdPageEditors } from "../../../../../providers/patchflexOfficeEditorPagesPageIdPageEditors";
import { getflexOfficeEditorPagesPageIdPageEditorsPageEditorId } from "../../../../../providers/getflexOfficeEditorPagesPageIdPageEditorsPageEditorId";
import { putflexOfficeEditorPagesPageIdPageEditorsPageEditorId } from "../../../../../providers/putflexOfficeEditorPagesPageIdPageEditorsPageEditorId";
import { deleteflexOfficeEditorPagesPageIdPageEditorsPageEditorId } from "../../../../../providers/deleteflexOfficeEditorPagesPageIdPageEditorsPageEditorId";

import { IFlexOfficePageEditor } from "../../../../../api/structures/IFlexOfficePageEditor";
import { IPageIFlexOfficePageEditor } from "../../../../../api/structures/IPageIFlexOfficePageEditor";

@Controller("/flexOffice/editor/pages/:pageId/pageEditors")
export class FlexofficeEditorPagesPageeditorsController {
  /**
   * Create a new page editor session for a given UI page and editor user.
   *
   * This enables collaborative editing by tracking active editor sessions and
   * enforcing concurrency control.
   *
   * It is critical that each editor is only active once per page to preserve
   * concurrency limits.
   *
   * The request body must include valid references to the page and editor, and
   * optionally timestamps can be supplied but the system usually maintains
   * them.
   *
   * @param connection
   * @param pageId Unique identifier of the UI page to create the editor session
   *   for
   * @param body Information required to create a page editor session
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageId")
    pageId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficePageEditor.ICreate,
  ): Promise<IFlexOfficePageEditor> {
    try {
      return await postflexOfficeEditorPagesPageIdPageEditors({
        editor,
        pageId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List editor sessions for a specific page.
   *
   * Search and retrieve a paginated list of page editor sessions for a
   * specified page ID.
   *
   * Supports complex filtering, sorting, and pagination defined in the request
   * payload to enable efficient management of active editors involved in
   * collaborative editing.
   *
   * This endpoint interacts with the flex_office_page_editors table, filtering
   * sessions belonging to the specified page.
   *
   * Response data shows summarized active editor session information suitable
   * for UI display and management controls.
   *
   * Access restrictions ensure only authorized users access this data.
   *
   * Errors are managed via validation of pageId and request filters.
   *
   * @param connection
   * @param pageId Unique identifier of the page whose editor sessions are
   *   requested
   * @param body Filtering, sorting, and pagination parameters
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageId")
    pageId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficePageEditor.IRequest,
  ): Promise<IPageIFlexOfficePageEditor.ISummary> {
    try {
      return await patchflexOfficeEditorPagesPageIdPageEditors({
        editor,
        pageId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve specific page editor session details.
   *
   * Retrieve details of a specific page editor session by page ID and page
   * editor ID. This operation allows clients to fetch comprehensive information
   * about the editor session for collaboration management.
   *
   * Security considerations include ensuring that only authorized users with at
   * least editor role or higher can access this data to maintain privacy and
   * integrity of editing sessions.
   *
   * The underlying data is sourced from the flex_office_page_editors table,
   * which tracks active editors for enforcing concurrent editing limits.
   *
   * Requests must specify valid UUIDs for both the page and the editor session.
   * The response returns structured data including timestamps for session
   * creation and updates, with nullable deleted_at indicating active or closed
   * sessions.
   *
   * Errors include 404 when no matching session is found, or 403 if the user
   * lacks permission.
   *
   * @param connection
   * @param pageId Unique identifier of the UI page the editor session belongs
   *   to
   * @param pageEditorId Unique identifier of the page editor session to
   *   retrieve
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":pageEditorId")
  public async at(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageId")
    pageId: string & tags.Format<"uuid">,
    @TypedParam("pageEditorId")
    pageEditorId: string & tags.Format<"uuid">,
  ): Promise<IFlexOfficePageEditor> {
    try {
      return await getflexOfficeEditorPagesPageIdPageEditorsPageEditorId({
        editor,
        pageId,
        pageEditorId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update page editor session details.
   *
   * Update an existing page editor session by page ID and page editor ID.
   *
   * This allows modification of session metadata such as timestamps and soft
   * deletion state.
   *
   * Clients must provide updated session information adhering to the expected
   * schema.
   *
   * Authorization roles required are editor and admin.
   *
   * @param connection
   * @param pageId Unique identifier of the UI page the editor session belongs
   *   to
   * @param pageEditorId Unique identifier of the page editor session to update
   * @param body Updated information for the page editor session
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":pageEditorId")
  public async update(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageId")
    pageId: string & tags.Format<"uuid">,
    @TypedParam("pageEditorId")
    pageEditorId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficePageEditor.IUpdate,
  ): Promise<IFlexOfficePageEditor> {
    try {
      return await putflexOfficeEditorPagesPageIdPageEditorsPageEditorId({
        editor,
        pageId,
        pageEditorId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete (soft) a page editor session.
   *
   * Soft-delete a page editor session by page ID and page editor ID.
   *
   * Marks the session as deleted but retains it for audit purposes.
   *
   * Ensures that collaborative editing session counts remain correct by
   * tracking active sessions.
   *
   * Authorization required for editor or admin roles.
   *
   * @param connection
   * @param pageId Unique identifier of the UI page the editor session belongs
   *   to
   * @param pageEditorId Unique identifier of the page editor session to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":pageEditorId")
  public async erase(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageId")
    pageId: string & tags.Format<"uuid">,
    @TypedParam("pageEditorId")
    pageEditorId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteflexOfficeEditorPagesPageIdPageEditorsPageEditorId({
        editor,
        pageId,
        pageEditorId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
