import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postflexOfficeEditorPageEditors } from "../../../../providers/postflexOfficeEditorPageEditors";
import { EditorAuth } from "../../../../decorators/EditorAuth";
import { EditorPayload } from "../../../../decorators/payload/EditorPayload";
import { patchflexOfficeEditorPageEditors } from "../../../../providers/patchflexOfficeEditorPageEditors";
import { getflexOfficeEditorPageEditorsPageEditorId } from "../../../../providers/getflexOfficeEditorPageEditorsPageEditorId";
import { putflexOfficeEditorPageEditorsPageEditorId } from "../../../../providers/putflexOfficeEditorPageEditorsPageEditorId";
import { deleteflexOfficeEditorPageEditorsPageEditorId } from "../../../../providers/deleteflexOfficeEditorPageEditorsPageEditorId";

import { IFlexOfficePageEditor } from "../../../../api/structures/IFlexOfficePageEditor";
import { IPageIFlexOfficePageEditor } from "../../../../api/structures/IPageIFlexOfficePageEditor";

@Controller("/flexOffice/editor/pageEditors")
export class FlexofficeEditorPageeditorsController {
  /**
   * Create a new editor session (flex_office_page_editors).
   *
   * Create a new active editor session on a FlexOffice UI page. This operation
   * enables a user with editor privileges to join the editing session of a
   * specific page, thereby contributing to real-time collaborative editing and
   * enforcing concurrency limits.
   *
   * Security considerations include verifying the editor's credentials and
   * ensuring they have permissions to edit the target page. The system avoids
   * duplicate editor sessions for the same page and user.
   *
   * This endpoint interfaces directly with the flex_office_page_editors table,
   * linking the editor and the page via their unique IDs and creating a new
   * record to represent this session.
   *
   * Validation rules enforce uniqueness of the (page_id, editor_id) pair and
   * ensure references exist to both flex_office_pages and flex_office_editors
   * tables.
   *
   * The operation will handle business logic like concurrency limits, rejecting
   * or queuing requests beyond allowed concurrent editor caps.
   *
   * Expected behavior includes returning the newly created page editor session
   * details including timestamps.
   *
   * @param connection
   * @param body Editor session creation payload
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @EditorAuth()
    editor: EditorPayload,
    @TypedBody()
    body: IFlexOfficePageEditor.ICreate,
  ): Promise<IFlexOfficePageEditor> {
    try {
      return await postflexOfficeEditorPageEditors({
        editor,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve a paginated list of active page editors.
   *
   * Get a list of page editors currently active on pages with support for
   * pagination and filtering. Each record shows editor and page associations
   * and timestamps.
   *
   * This operation allows administrators and editors to see concurrent editing
   * activity.
   *
   * Underlying data is sourced from the flex_office_page_editors table with
   * fields for page and editor references, and session timestamps.
   *
   * Returns paginated, filtered list of active page editors.
   *
   * @param connection
   * @param body Search criteria and pagination parameters for page editors
   *   filtering
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async search(
    @EditorAuth()
    editor: EditorPayload,
    @TypedBody()
    body: IFlexOfficePageEditor.IRequest,
  ): Promise<IPageIFlexOfficePageEditor.ISummary> {
    try {
      return await patchflexOfficeEditorPageEditors({
        editor,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve detailed page editor session information by ID.
   *
   * Fetch detailed info of an active or historic page editor session specified
   * by pageEditorId. Data includes page and editor references and session
   * timestamps.
   *
   * This supports collaboration management and audit functionalities.
   *
   * Data source is the flex_office_page_editors table.
   *
   * Returns full detail of the page editor session record.
   *
   * @param connection
   * @param pageEditorId Unique identifier of the target page editor session
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":pageEditorId")
  public async at(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageEditorId")
    pageEditorId: string & tags.Format<"uuid">,
  ): Promise<IFlexOfficePageEditor> {
    try {
      return await getflexOfficeEditorPageEditorsPageEditorId({
        editor,
        pageEditorId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a page editor session by ID.
   *
   * Update an existing editor session identified by pageEditorId. Allows
   * modification of page editor session details such as associated page,
   * editor, and updated timestamps.
   *
   * Security checks ensure the updating user has rights to modify this session.
   * Business logic enforces concurrency rules and session integrity.
   *
   * This operation targets the flex_office_page_editors table and updates the
   * specified record based on the provided data.
   *
   * It returns the updated entity details for client confirmation.
   *
   * @param connection
   * @param pageEditorId Unique identifier of the page editor session to update
   * @param body Page editor session update payload
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":pageEditorId")
  public async update(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageEditorId")
    pageEditorId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IFlexOfficePageEditor.IUpdate,
  ): Promise<IFlexOfficePageEditor> {
    try {
      return await putflexOfficeEditorPageEditorsPageEditorId({
        editor,
        pageEditorId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete a page editor session.
   *
   * Remove an editor session from a page by deleting the session record
   * identified by pageEditorId.
   *
   * Security controls must confirm the user has sufficient rights. This
   * operation affects real-time collaboration state by potentially freeing a
   * concurrency slot.
   *
   * The response contains no body upon success.
   *
   * @param connection
   * @param pageEditorId Unique identifier of the page editor session to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":pageEditorId")
  public async erase(
    @EditorAuth()
    editor: EditorPayload,
    @TypedParam("pageEditorId")
    pageEditorId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleteflexOfficeEditorPageEditorsPageEditorId({
        editor,
        pageEditorId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
