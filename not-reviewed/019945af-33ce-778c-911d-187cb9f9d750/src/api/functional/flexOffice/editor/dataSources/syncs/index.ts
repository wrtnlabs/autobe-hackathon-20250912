import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IFlexOfficeDataSourceSync } from "../../../../../structures/IFlexOfficeDataSourceSync";
import { IPageIFlexOfficeDataSourceSync } from "../../../../../structures/IPageIFlexOfficeDataSourceSync";

/**
 * Create a new synchronization task for a specified data source.
 *
 * This API operation creates a new synchronization attempt record linked to an
 * existing data source in the system. It enables authorized users to trigger or
 * schedule a new sync job for updating data from external sources like MySQL,
 * PostgreSQL databases or uploaded spreadsheets.
 *
 * The 'dataSourceId' path parameter identifies the exact external data source
 * to be synchronized. The operation verifies that the provided dataSourceId
 * references an active and valid data source record.
 *
 * Upon invocation, a new flex_office_data_source_syncs record is created with
 * initial scheduling and status fields setup to mark a scheduled sync. The
 * system will later update this record with actual run timestamps, completion
 * status, and errors if any.
 *
 * Security considerations restrict this operation to authorized roles able to
 * manage synchronization tasks. Permissions ensure users only trigger syncs for
 * data sources they are permitted to access.
 *
 * Related operations include querying sync job histories, updating sync
 * records, and deleting obsolete sync tasks, which help manage data refresh
 * workflows comprehensively.
 *
 * Client applications should handle potential errors such as invalid
 * dataSourceId, permission denials, or system failures gracefully.
 *
 * This operation does not require a request body beyond the path parameter and
 * returns the newly created sync record on success.
 *
 * @param props.connection
 * @param props.dataSourceId Unique identifier of the external data source
 * @param props.body Information to create a new sync task
 * @path /flexOffice/editor/dataSources/:dataSourceId/syncs
 * @accessor api.functional.flexOffice.editor.dataSources.syncs.createSync
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createSync(
  connection: IConnection,
  props: createSync.Props,
): Promise<createSync.Response> {
  return true === connection.simulate
    ? createSync.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createSync.METADATA,
          path: createSync.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createSync {
  export type Props = {
    /** Unique identifier of the external data source */
    dataSourceId: string & tags.Format<"uuid">;

    /** Information to create a new sync task */
    body: IFlexOfficeDataSourceSync.ICreate;
  };
  export type Body = IFlexOfficeDataSourceSync.ICreate;
  export type Response = IFlexOfficeDataSourceSync;

  export const METADATA = {
    method: "POST",
    path: "/flexOffice/editor/dataSources/:dataSourceId/syncs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/flexOffice/editor/dataSources/${encodeURIComponent(props.dataSourceId ?? "null")}/syncs`;
  export const random = (): IFlexOfficeDataSourceSync =>
    typia.random<IFlexOfficeDataSourceSync>();
  export const simulate = (
    connection: IConnection,
    props: createSync.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createSync.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("dataSourceId")(() => typia.assert(props.dataSourceId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated sync operation records for a data source.
 *
 * Search synchronization operations of a particular data source identified by
 * dataSourceId. Supports advanced filters, pagination, and sorting to navigate
 * sync history and status.
 *
 * This operation facilitates monitoring and management of data refresh jobs,
 * enabling display of sync scheduling, completion status, errors, and timing.
 *
 * Role-based access ensures only authorized users can review synchronization
 * logs for secure operations.
 *
 * Related operations include retrieving specific sync details and managing data
 * source configurations.
 *
 * @param props.connection
 * @param props.dataSourceId Unique identifier of the target data source
 * @param props.body Search filters and pagination info for data source syncs
 * @path /flexOffice/editor/dataSources/:dataSourceId/syncs
 * @accessor api.functional.flexOffice.editor.dataSources.syncs.searchSyncs
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function searchSyncs(
  connection: IConnection,
  props: searchSyncs.Props,
): Promise<searchSyncs.Response> {
  return true === connection.simulate
    ? searchSyncs.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...searchSyncs.METADATA,
          path: searchSyncs.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace searchSyncs {
  export type Props = {
    /** Unique identifier of the target data source */
    dataSourceId: string & tags.Format<"uuid">;

    /** Search filters and pagination info for data source syncs */
    body: IFlexOfficeDataSourceSync.IRequest;
  };
  export type Body = IFlexOfficeDataSourceSync.IRequest;
  export type Response = IPageIFlexOfficeDataSourceSync;

  export const METADATA = {
    method: "PATCH",
    path: "/flexOffice/editor/dataSources/:dataSourceId/syncs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/flexOffice/editor/dataSources/${encodeURIComponent(props.dataSourceId ?? "null")}/syncs`;
  export const random = (): IPageIFlexOfficeDataSourceSync =>
    typia.random<IPageIFlexOfficeDataSourceSync>();
  export const simulate = (
    connection: IConnection,
    props: searchSyncs.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: searchSyncs.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("dataSourceId")(() => typia.assert(props.dataSourceId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed synchronization status by ID for a data source.
 *
 * Get detailed synchronization information by syncId for data source identified
 * by dataSourceId. Provides status, timing, error message details of sync
 * operation.
 *
 * Ensures authorized access control and accurate identification with composite
 * primary keys.
 *
 * Related operations include searching sync logs and managing data sources.
 *
 * @param props.connection
 * @param props.dataSourceId Unique identifier of the data source containing the
 *   sync record
 * @param props.syncId Unique identifier of the synchronization record
 * @path /flexOffice/editor/dataSources/:dataSourceId/syncs/:syncId
 * @accessor api.functional.flexOffice.editor.dataSources.syncs.atSync
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atSync(
  connection: IConnection,
  props: atSync.Props,
): Promise<atSync.Response> {
  return true === connection.simulate
    ? atSync.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atSync.METADATA,
          path: atSync.path(props),
          status: null,
        },
      );
}
export namespace atSync {
  export type Props = {
    /** Unique identifier of the data source containing the sync record */
    dataSourceId: string & tags.Format<"uuid">;

    /** Unique identifier of the synchronization record */
    syncId: string & tags.Format<"uuid">;
  };
  export type Response = IFlexOfficeDataSourceSync;

  export const METADATA = {
    method: "GET",
    path: "/flexOffice/editor/dataSources/:dataSourceId/syncs/:syncId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/flexOffice/editor/dataSources/${encodeURIComponent(props.dataSourceId ?? "null")}/syncs/${encodeURIComponent(props.syncId ?? "null")}`;
  export const random = (): IFlexOfficeDataSourceSync =>
    typia.random<IFlexOfficeDataSourceSync>();
  export const simulate = (
    connection: IConnection,
    props: atSync.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atSync.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("dataSourceId")(() => typia.assert(props.dataSourceId));
      assert.param("syncId")(() => typia.assert(props.syncId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
