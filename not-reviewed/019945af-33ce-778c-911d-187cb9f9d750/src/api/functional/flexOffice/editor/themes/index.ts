import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IFlexOfficeTheme } from "../../../../structures/IFlexOfficeTheme";
import { IPageIFlexOfficeTheme } from "../../../../structures/IPageIFlexOfficeTheme";

/**
 * Create a new UI theme.
 *
 * Create a new UI/Page Builder theme by providing name and optional CSS
 * content. The operation inserts a new record into the flex_office_themes
 * table.
 *
 * Input validation ensures the name is unique and CSS content is valid text.
 *
 * Upon successful creation, the response returns the full newly created theme
 * including ID and timestamps.
 *
 * Authorized users include Admins and Editors who manage UI customization.
 *
 * Request requires a JSON request body specifying theme creation fields defined
 * in the IFlexOfficeTheme.ICreate DTO.
 *
 * @param props.connection
 * @param props.body Theme creation data including name and CSS
 * @path /flexOffice/editor/themes
 * @accessor api.functional.flexOffice.editor.themes.createTheme
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createTheme(
  connection: IConnection,
  props: createTheme.Props,
): Promise<createTheme.Response> {
  return true === connection.simulate
    ? createTheme.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createTheme.METADATA,
          path: createTheme.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createTheme {
  export type Props = {
    /** Theme creation data including name and CSS */
    body: IFlexOfficeTheme.ICreate;
  };
  export type Body = IFlexOfficeTheme.ICreate;
  export type Response = IFlexOfficeTheme;

  export const METADATA = {
    method: "POST",
    path: "/flexOffice/editor/themes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/flexOffice/editor/themes";
  export const random = (): IFlexOfficeTheme =>
    typia.random<IFlexOfficeTheme>();
  export const simulate = (
    connection: IConnection,
    props: createTheme.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createTheme.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate UI themes.
 *
 * Retrieve a filtered, sorted, and paginated list of UI/Page Builder themes
 * stored in the FlexOffice system. The operation accesses the
 * flex_office_themes table which contains theming information represented by
 * theme names and CSS content.
 *
 * This PATCH endpoint accepts search criteria such as name filters and supports
 * pagination fields like page number and size. The response contains a
 * paginated collection of theme summary information optimizing data transfer
 * and UI rendering.
 *
 * Authorized users typically include Admins and Editors who can view, create,
 * and manage themes in the system. Users can utilize this operation to find
 * existing themes quickly and support UI customization workflows.
 *
 * The response contains only summary data rather than full theme details to
 * ensure efficiency.
 *
 * @param props.connection
 * @param props.body Filter and pagination parameters for searching themes
 * @path /flexOffice/editor/themes
 * @accessor api.functional.flexOffice.editor.themes.searchThemes
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function searchThemes(
  connection: IConnection,
  props: searchThemes.Props,
): Promise<searchThemes.Response> {
  return true === connection.simulate
    ? searchThemes.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...searchThemes.METADATA,
          path: searchThemes.path(),
          status: null,
        },
        props.body,
      );
}
export namespace searchThemes {
  export type Props = {
    /** Filter and pagination parameters for searching themes */
    body: IFlexOfficeTheme.IRequest;
  };
  export type Body = IFlexOfficeTheme.IRequest;
  export type Response = IPageIFlexOfficeTheme.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/flexOffice/editor/themes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/flexOffice/editor/themes";
  export const random = (): IPageIFlexOfficeTheme.ISummary =>
    typia.random<IPageIFlexOfficeTheme.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: searchThemes.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: searchThemes.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a UI theme by ID.
 *
 * Retrieve detailed information about a specific UI/Page Builder theme
 * identified by its unique ID. Themes store CSS content and metadata for
 * consistent UI appearance.
 *
 * This GET operation fetches all fields of the theme entity from the
 * flex_office_themes table in the database.
 *
 * Authorized users with Admin or Editor roles can access this endpoint to view
 * or manage theme details.
 *
 * If the ID is invalid or the theme does not exist, an appropriate HTTP error
 * response is returned.
 *
 * The request requires a single path parameter specifying the UUID of the
 * theme.
 *
 * @param props.connection
 * @param props.id Unique identifier of the UI theme
 * @path /flexOffice/editor/themes/:id
 * @accessor api.functional.flexOffice.editor.themes.atTheme
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atTheme(
  connection: IConnection,
  props: atTheme.Props,
): Promise<atTheme.Response> {
  return true === connection.simulate
    ? atTheme.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atTheme.METADATA,
          path: atTheme.path(props),
          status: null,
        },
      );
}
export namespace atTheme {
  export type Props = {
    /** Unique identifier of the UI theme */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IFlexOfficeTheme;

  export const METADATA = {
    method: "GET",
    path: "/flexOffice/editor/themes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/flexOffice/editor/themes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IFlexOfficeTheme =>
    typia.random<IFlexOfficeTheme>();
  export const simulate = (
    connection: IConnection,
    props: atTheme.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atTheme.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details of a theme by ID in flex_office_themes.
 *
 * Update the details of a theme, including its name and CSS styles. This
 * operation modifies the theme record identified by the given id path
 * parameter. The request body allows changing the name, description, and CSS
 * properties of the theme.
 *
 * Security considerations: Only authorized roles can perform this update to
 * prevent unauthorized visual changes.
 *
 * Relationships: The theme is referenced by UI pages, so updates may affect
 * page appearances.
 *
 * Validation: The theme name must remain unique and the CSS content should be
 * valid CSS text.
 *
 * Related APIs:
 *
 * - GET /themes/{id} to retrieve theme details
 * - DELETE /themes/{id} to remove a theme
 *
 * Expected behavior: The updated theme record is returned with accurate
 * timestamps. Errors are raised if the theme id does not exist or on validation
 * failures.
 *
 * @param props.connection
 * @param props.id Unique identifier of the target theme
 * @param props.body Update data for the theme
 * @path /flexOffice/editor/themes/:id
 * @accessor api.functional.flexOffice.editor.themes.updateTheme
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateTheme(
  connection: IConnection,
  props: updateTheme.Props,
): Promise<updateTheme.Response> {
  return true === connection.simulate
    ? updateTheme.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateTheme.METADATA,
          path: updateTheme.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateTheme {
  export type Props = {
    /** Unique identifier of the target theme */
    id: string & tags.Format<"uuid">;

    /** Update data for the theme */
    body: IFlexOfficeTheme.IUpdate;
  };
  export type Body = IFlexOfficeTheme.IUpdate;
  export type Response = IFlexOfficeTheme;

  export const METADATA = {
    method: "PUT",
    path: "/flexOffice/editor/themes/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/flexOffice/editor/themes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IFlexOfficeTheme =>
    typia.random<IFlexOfficeTheme>();
  export const simulate = (
    connection: IConnection,
    props: updateTheme.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateTheme.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a theme by ID in flex_office_themes.
 *
 * Permanently delete a theme by its unique identifier. This operation removes
 * the theme record from the database completely.
 *
 * Security considerations: Only admins and editors can perform this delete to
 * avoid accidental loss.
 *
 * Relationship: The theme may be referenced by pages, so deletion should be
 * done carefully, ensuring no pages are broken.
 *
 * Validation: The theme id must exist; otherwise, an error is returned.
 *
 * Expected behavior: The theme is removed from the database and cannot be
 * recovered. No content is returned upon success.
 *
 * @param props.connection
 * @param props.id Unique identifier of the target theme
 * @path /flexOffice/editor/themes/:id
 * @accessor api.functional.flexOffice.editor.themes.eraseTheme
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseTheme(
  connection: IConnection,
  props: eraseTheme.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseTheme.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseTheme.METADATA,
          path: eraseTheme.path(props),
          status: null,
        },
      );
}
export namespace eraseTheme {
  export type Props = {
    /** Unique identifier of the target theme */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/flexOffice/editor/themes/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/flexOffice/editor/themes/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseTheme.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseTheme.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
