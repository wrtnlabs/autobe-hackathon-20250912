import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IFlexOfficeTablePermission } from "../../../../structures/IFlexOfficeTablePermission";
import { IPageIFlexOfficeTablePermission } from "../../../../structures/IPageIFlexOfficeTablePermission";
export * as columnPermissions from "./columnPermissions/index";
export * as rowPermissions from "./rowPermissions/index";

/**
 * Create a new table permission record linking permission and table.
 *
 * This POST operation allows administrators to create a new entry in the
 * flex_office_table_permissions table, establishing a link between a permission
 * and a database table. The request body must provide the required fields such
 * as permission ID and target table name.
 *
 * Upon success, the operation returns the created table permission record,
 * including timestamps and identifiers.
 *
 * Security measures restrict this creation to admins to maintain control over
 * access rights.
 *
 * No path parameters required. Request body must specify creation data.
 *
 * @param props.connection
 * @param props.body Details for creating a new table permission record
 * @path /flexOffice/admin/tablePermissions
 * @accessor api.functional.flexOffice.admin.tablePermissions.createTablePermission
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createTablePermission(
  connection: IConnection,
  props: createTablePermission.Props,
): Promise<createTablePermission.Response> {
  return true === connection.simulate
    ? createTablePermission.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createTablePermission.METADATA,
          path: createTablePermission.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createTablePermission {
  export type Props = {
    /** Details for creating a new table permission record */
    body: IFlexOfficeTablePermission.ICreate;
  };
  export type Body = IFlexOfficeTablePermission.ICreate;
  export type Response = IFlexOfficeTablePermission;

  export const METADATA = {
    method: "POST",
    path: "/flexOffice/admin/tablePermissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/flexOffice/admin/tablePermissions";
  export const random = (): IFlexOfficeTablePermission =>
    typia.random<IFlexOfficeTablePermission>();
  export const simulate = (
    connection: IConnection,
    props: createTablePermission.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createTablePermission.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated list of table permissions.
 *
 * This PATCH operation enables clients to query the
 * flex_office_table_permissions table with flexible filtering options like
 * table name, permission, status, etc., combined with pagination settings.
 *
 * It returns a paginated list of table permission summaries suitable for
 * administrative interfaces managing RBAC assignments. Security requires admin
 * authentication due to privileged nature of permission management data.
 *
 * No path parameters are required, but a request body defines the search
 * filters and pagination parameters. The response includes paginated table
 * permission summaries.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for table
 *   permissions
 * @path /flexOffice/admin/tablePermissions
 * @accessor api.functional.flexOffice.admin.tablePermissions.indexTablePermission
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexTablePermission(
  connection: IConnection,
  props: indexTablePermission.Props,
): Promise<indexTablePermission.Response> {
  return true === connection.simulate
    ? indexTablePermission.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexTablePermission.METADATA,
          path: indexTablePermission.path(),
          status: null,
        },
        props.body,
      );
}
export namespace indexTablePermission {
  export type Props = {
    /** Search criteria and pagination parameters for table permissions */
    body: IFlexOfficeTablePermission.IRequest;
  };
  export type Body = IFlexOfficeTablePermission.IRequest;
  export type Response = IPageIFlexOfficeTablePermission.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/flexOffice/admin/tablePermissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/flexOffice/admin/tablePermissions";
  export const random = (): IPageIFlexOfficeTablePermission.ISummary =>
    typia.random<IPageIFlexOfficeTablePermission.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: indexTablePermission.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexTablePermission.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information of a table permission by ID.
 *
 * This GET operation fetches a detailed view of a single table permission by
 * its ID. It includes permission key, table name, related column permissions,
 * and row permissions if present. The operation requires the table permission's
 * unique identifier as a path parameter.
 *
 * Access to this information is restricted to authorized users such as
 * administrators managing access control policies.
 *
 * The operation does not require a request body and returns the full table
 * permission resource.
 *
 * @param props.connection
 * @param props.id Unique identifier of the target table permission
 * @path /flexOffice/admin/tablePermissions/:id
 * @accessor api.functional.flexOffice.admin.tablePermissions.atTablePermission
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atTablePermission(
  connection: IConnection,
  props: atTablePermission.Props,
): Promise<atTablePermission.Response> {
  return true === connection.simulate
    ? atTablePermission.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atTablePermission.METADATA,
          path: atTablePermission.path(props),
          status: null,
        },
      );
}
export namespace atTablePermission {
  export type Props = {
    /** Unique identifier of the target table permission */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IFlexOfficeTablePermission;

  export const METADATA = {
    method: "GET",
    path: "/flexOffice/admin/tablePermissions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/flexOffice/admin/tablePermissions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IFlexOfficeTablePermission =>
    typia.random<IFlexOfficeTablePermission>();
  export const simulate = (
    connection: IConnection,
    props: atTablePermission.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atTablePermission.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing table permission by ID.
 *
 * Update a specific table permission in the FlexOffice system.
 *
 * This operation updates the details of a table permission record, identified
 * uniquely by its ID. Table permissions define which database tables a specific
 * permission applies to, allowing for granular control over access to database
 * resources.
 *
 * The 'flex_office_table_permissions' Prisma model includes fields for linking
 * to permissions and specifying target tables. Updates must preserve data
 * integrity and audit fields. Soft deletion timestamps exist but this operation
 * modifies non-deleted records.
 *
 * Authorization is required to ensure only authorized users can update
 * permissions, maintaining system security. Proper error handling is expected
 * if the resource does not exist.
 *
 * Related endpoints include GET for reading and DELETE for removing table
 * permissions.
 *
 * No request body is returned; the response includes the updated table
 * permission object.
 *
 * @param props.connection
 * @param props.id Unique identifier of the table permission
 * @param props.body Update information for the table permission
 * @path /flexOffice/admin/tablePermissions/:id
 * @accessor api.functional.flexOffice.admin.tablePermissions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the table permission */
    id: string & tags.Format<"uuid">;

    /** Update information for the table permission */
    body: IFlexOfficeTablePermission.IUpdate;
  };
  export type Body = IFlexOfficeTablePermission.IUpdate;
  export type Response = IFlexOfficeTablePermission;

  export const METADATA = {
    method: "PUT",
    path: "/flexOffice/admin/tablePermissions/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/flexOffice/admin/tablePermissions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IFlexOfficeTablePermission =>
    typia.random<IFlexOfficeTablePermission>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a table permission by ID.
 *
 * Delete a specified table permission by ID.
 *
 * This endpoint performs a soft delete on the table permission entity. Instead
 * of permanently removing the data, the soft delete marks the record as
 * deleted, preserving it for audit and recovery purposes.
 *
 * Authorization is strictly enforced to ensure only users with admin roles can
 * delete table permissions. Attempts to delete non-existing or already deleted
 * records should be handled gracefully.
 *
 * This operation is critical for managing access control policies while
 * maintaining historical records for compliance.
 *
 * Related operations include update and read endpoints for table permissions.
 *
 * No content is returned on success.
 *
 * @param props.connection
 * @param props.id Unique identifier of the table permission
 * @path /flexOffice/admin/tablePermissions/:id
 * @accessor api.functional.flexOffice.admin.tablePermissions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the table permission */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/flexOffice/admin/tablePermissions/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/flexOffice/admin/tablePermissions/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
