import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IFlexOfficeColumnPermission } from "../../../../../structures/IFlexOfficeColumnPermission";
import { IPageIFlexOfficeColumnPermission } from "../../../../../structures/IPageIFlexOfficeColumnPermission";

/**
 * Create a new column permission for a specified table permission.
 *
 * Create a new column permission under the specified table permission in the
 * FlexOffice access control system. This allows administrators to define
 * fine-grained access restrictions by specifying permissions on individual
 * columns within a database table.
 *
 * The operation requires the `tablePermissionId` path parameter to identify the
 * parent table permission entity, ensuring the column permission is linked
 * correctly. The request body must include the column name to restrict and the
 * system sets audit timestamps accordingly.
 *
 * Proper authorization for this operation ensures that only appropriate
 * administrative users can assign new column permissions. The API returns the
 * details of the created column permission record, including its unique
 * identifier and timestamps.
 *
 * @param props.connection
 * @param props.tablePermissionId The unique identifier of the target table
 *   permission
 * @param props.body Information required to create a new column permission
 * @path /flexOffice/admin/tablePermissions/:tablePermissionId/columnPermissions
 * @accessor api.functional.flexOffice.admin.tablePermissions.columnPermissions.createColumnPermission
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createColumnPermission(
  connection: IConnection,
  props: createColumnPermission.Props,
): Promise<createColumnPermission.Response> {
  return true === connection.simulate
    ? createColumnPermission.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createColumnPermission.METADATA,
          path: createColumnPermission.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createColumnPermission {
  export type Props = {
    /** The unique identifier of the target table permission */
    tablePermissionId: string & tags.Format<"uuid">;

    /** Information required to create a new column permission */
    body: IFlexOfficeColumnPermission.ICreate;
  };
  export type Body = IFlexOfficeColumnPermission.ICreate;
  export type Response = IFlexOfficeColumnPermission;

  export const METADATA = {
    method: "POST",
    path: "/flexOffice/admin/tablePermissions/:tablePermissionId/columnPermissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/flexOffice/admin/tablePermissions/${encodeURIComponent(props.tablePermissionId ?? "null")}/columnPermissions`;
  export const random = (): IFlexOfficeColumnPermission =>
    typia.random<IFlexOfficeColumnPermission>();
  export const simulate = (
    connection: IConnection,
    props: createColumnPermission.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createColumnPermission.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("tablePermissionId")(() =>
        typia.assert(props.tablePermissionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List column permissions under a table permission.
 *
 * Retrieve a paginated list of column permissions for a specific table
 * permission.
 *
 * This endpoint allows clients to query and browse column-level permissions
 * linked to a table permission record. Filtering and pagination are supported
 * for efficient navigation.
 *
 * Each column permission controls access at the column granularity, linked to
 * the broader table permission entity.
 *
 * The operation enforces authorization to limit access to users with admin
 * privileges managing access control configurations.
 *
 * Related operations include detailed reads and modifications of column
 * permissions.
 *
 * Response contains paginated summary details of column permissions matching
 * the request criteria.
 *
 * @param props.connection
 * @param props.tablePermissionId ID of the parent table permission
 * @param props.body Search and pagination parameters for column permissions
 * @path /flexOffice/admin/tablePermissions/:tablePermissionId/columnPermissions
 * @accessor api.functional.flexOffice.admin.tablePermissions.columnPermissions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** ID of the parent table permission */
    tablePermissionId: string & tags.Format<"uuid">;

    /** Search and pagination parameters for column permissions */
    body: IFlexOfficeColumnPermission.IRequest;
  };
  export type Body = IFlexOfficeColumnPermission.IRequest;
  export type Response = IPageIFlexOfficeColumnPermission.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/flexOffice/admin/tablePermissions/:tablePermissionId/columnPermissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/flexOffice/admin/tablePermissions/${encodeURIComponent(props.tablePermissionId ?? "null")}/columnPermissions`;
  export const random = (): IPageIFlexOfficeColumnPermission.ISummary =>
    typia.random<IPageIFlexOfficeColumnPermission.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("tablePermissionId")(() =>
        typia.assert(props.tablePermissionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information of a column permission by ID.
 *
 * Retrieve detailed information about a specific column permission.
 *
 * This endpoint fetches a single column permission record by its unique
 * identifier, scoped within a parent table permission. It enables inspection of
 * column-level permission configurations including controlled columns and
 * associated access rights.
 *
 * Authorization ensures that only users with administrative privileges can
 * access this sensitive configuration.
 *
 * Complementary operations include list, update, and delete APIs for column
 * permissions.
 *
 * Returns full column permission entity information upon success.
 *
 * @param props.connection
 * @param props.tablePermissionId ID of the parent table permission
 * @param props.columnPermissionId ID of the target column permission
 * @path /flexOffice/admin/tablePermissions/:tablePermissionId/columnPermissions/:columnPermissionId
 * @accessor api.functional.flexOffice.admin.tablePermissions.columnPermissions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** ID of the parent table permission */
    tablePermissionId: string & tags.Format<"uuid">;

    /** ID of the target column permission */
    columnPermissionId: string & tags.Format<"uuid">;
  };
  export type Response = IFlexOfficeColumnPermission;

  export const METADATA = {
    method: "GET",
    path: "/flexOffice/admin/tablePermissions/:tablePermissionId/columnPermissions/:columnPermissionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/flexOffice/admin/tablePermissions/${encodeURIComponent(props.tablePermissionId ?? "null")}/columnPermissions/${encodeURIComponent(props.columnPermissionId ?? "null")}`;
  export const random = (): IFlexOfficeColumnPermission =>
    typia.random<IFlexOfficeColumnPermission>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("tablePermissionId")(() =>
        typia.assert(props.tablePermissionId),
      );
      assert.param("columnPermissionId")(() =>
        typia.assert(props.columnPermissionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing column permission by its ID under a specified table
 * permission.
 *
 * Update details of a column permission for a given table permission in the
 * FlexOffice access control system. This enables administrative users to modify
 * access restrictions at the column level within database tables.
 *
 * The operation requires path parameters `tablePermissionId` and
 * `columnPermissionId` to uniquely identify the record being updated. The
 * request body allows changes to the column name and other editable fields.
 * Audit timestamps are maintained to track modifications.
 *
 * Authorization ensures only privileged users can perform updates. The API
 * response includes the fully updated column permission details to confirm
 * changes.
 *
 * @param props.connection
 * @param props.tablePermissionId The unique identifier of the target table
 *   permission
 * @param props.columnPermissionId The unique identifier of the column
 *   permission to be updated
 * @param props.body Updated information for the column permission
 * @path /flexOffice/admin/tablePermissions/:tablePermissionId/columnPermissions/:columnPermissionId
 * @accessor api.functional.flexOffice.admin.tablePermissions.columnPermissions.updateColumnPermission
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateColumnPermission(
  connection: IConnection,
  props: updateColumnPermission.Props,
): Promise<updateColumnPermission.Response> {
  return true === connection.simulate
    ? updateColumnPermission.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateColumnPermission.METADATA,
          path: updateColumnPermission.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateColumnPermission {
  export type Props = {
    /** The unique identifier of the target table permission */
    tablePermissionId: string & tags.Format<"uuid">;

    /** The unique identifier of the column permission to be updated */
    columnPermissionId: string & tags.Format<"uuid">;

    /** Updated information for the column permission */
    body: IFlexOfficeColumnPermission.IUpdate;
  };
  export type Body = IFlexOfficeColumnPermission.IUpdate;
  export type Response = IFlexOfficeColumnPermission;

  export const METADATA = {
    method: "PUT",
    path: "/flexOffice/admin/tablePermissions/:tablePermissionId/columnPermissions/:columnPermissionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/flexOffice/admin/tablePermissions/${encodeURIComponent(props.tablePermissionId ?? "null")}/columnPermissions/${encodeURIComponent(props.columnPermissionId ?? "null")}`;
  export const random = (): IFlexOfficeColumnPermission =>
    typia.random<IFlexOfficeColumnPermission>();
  export const simulate = (
    connection: IConnection,
    props: updateColumnPermission.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateColumnPermission.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("tablePermissionId")(() =>
        typia.assert(props.tablePermissionId),
      );
      assert.param("columnPermissionId")(() =>
        typia.assert(props.columnPermissionId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a column permission permanently by IDs.
 *
 * Delete a column permission identified by its ID and associated table
 * permission ID in FlexOffice. This operation removes column-level access
 * control constraints for the specified column.
 *
 * The API expects path parameters `tablePermissionId` and `columnPermissionId`
 * to locate the exact record. This is a hard delete operation which
 * irreversibly removes the record from the database, ensuring the access
 * control is no longer active for the column.
 *
 * Authorization is required to perform this sensitive operation, typically
 * limited to administrators. The operation does not return any content upon
 * success.
 *
 * @param props.connection
 * @param props.tablePermissionId The unique identifier of the target table
 *   permission
 * @param props.columnPermissionId The unique identifier of the column
 *   permission to delete
 * @path /flexOffice/admin/tablePermissions/:tablePermissionId/columnPermissions/:columnPermissionId
 * @accessor api.functional.flexOffice.admin.tablePermissions.columnPermissions.eraseColumnPermission
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseColumnPermission(
  connection: IConnection,
  props: eraseColumnPermission.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseColumnPermission.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseColumnPermission.METADATA,
          path: eraseColumnPermission.path(props),
          status: null,
        },
      );
}
export namespace eraseColumnPermission {
  export type Props = {
    /** The unique identifier of the target table permission */
    tablePermissionId: string & tags.Format<"uuid">;

    /** The unique identifier of the column permission to delete */
    columnPermissionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/flexOffice/admin/tablePermissions/:tablePermissionId/columnPermissions/:columnPermissionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/flexOffice/admin/tablePermissions/${encodeURIComponent(props.tablePermissionId ?? "null")}/columnPermissions/${encodeURIComponent(props.columnPermissionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseColumnPermission.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseColumnPermission.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("tablePermissionId")(() =>
        typia.assert(props.tablePermissionId),
      );
      assert.param("columnPermissionId")(() =>
        typia.assert(props.columnPermissionId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
