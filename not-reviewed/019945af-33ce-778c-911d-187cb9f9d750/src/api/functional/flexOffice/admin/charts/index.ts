import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IFlexOfficeChart } from "../../../../structures/IFlexOfficeChart";
export * as filterConditions from "./filterConditions/index";

/**
 * Create a new analytics chart in the FlexOffice system.
 *
 * This API endpoint allows the creation of a new analytics chart within the
 * FlexOffice platform. The chart entity acts as the foundational metadata
 * container for visualization widgets associated with UI page widgets. Users
 * can specify the chart type such as bar, line, or pie, set a meaningful title,
 * and optionally provide a description to inform viewers of the chart's context
 * and purpose.
 *
 * Security-wise, this operation requires authenticated user access restricted
 * to roles 'admin', 'editor', or 'viewer' to ensure authorized users can manage
 * chart metadata.
 *
 * The created chart will be linked to an existing UI widget by ID and stored
 * atomically in the database, ensuring data integrity. Backend services are
 * responsible for generating unique IDs, timestamps, and managing soft deletion
 * flags where applicable.
 *
 * This operation complements related operations such as updating charts,
 * deleting charts, and retrieving chart details or summaries. Error handling
 * includes validation of widget existence and chart type correctness.
 *
 * The response returns the fully created chart entity with all relevant fields.
 *
 * @param props.connection
 * @param props.body Detailed information for creating a FlexOffice chart
 * @path /flexOffice/admin/charts
 * @accessor api.functional.flexOffice.admin.charts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Detailed information for creating a FlexOffice chart */
    body: IFlexOfficeChart.ICreate;
  };
  export type Body = IFlexOfficeChart.ICreate;
  export type Response = IFlexOfficeChart;

  export const METADATA = {
    method: "POST",
    path: "/flexOffice/admin/charts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/flexOffice/admin/charts";
  export const random = (): IFlexOfficeChart =>
    typia.random<IFlexOfficeChart>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing analytics chart by chartId.
 *
 * This API endpoint updates the attributes of an existing analytics chart in
 * the FlexOffice platform. By specifying the chart ID, authorized users such as
 * admin, editor, or viewer roles can modify properties such as chart type,
 * descriptive title, and optional descriptive fields to keep visualizations
 * accurate and relevant.
 *
 * Strict access control is enforced ensuring that only authorized users with
 * roles 'admin', 'editor', or 'viewer' can perform modifications to prevent
 * unauthorized data tampering.
 *
 * The system will validate the existence of the target chart prior to applying
 * updates and return the updated entity in the response. This operation serves
 * as a complement to chart creation, deletion, and retrieval endpoints.
 *
 * Errors include handling cases of not found chart ID or invalid update data.
 *
 * @param props.connection
 * @param props.chartId Unique identifier of the target chart to update
 * @param props.body Update data for an existing FlexOffice chart
 * @path /flexOffice/admin/charts/:chartId
 * @accessor api.functional.flexOffice.admin.charts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target chart to update */
    chartId: string & tags.Format<"uuid">;

    /** Update data for an existing FlexOffice chart */
    body: IFlexOfficeChart.IUpdate;
  };
  export type Body = IFlexOfficeChart.IUpdate;
  export type Response = IFlexOfficeChart;

  export const METADATA = {
    method: "PUT",
    path: "/flexOffice/admin/charts/:chartId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/flexOffice/admin/charts/${encodeURIComponent(props.chartId ?? "null")}`;
  export const random = (): IFlexOfficeChart =>
    typia.random<IFlexOfficeChart>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("chartId")(() => typia.assert(props.chartId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an analytics chart permanently by chartId.
 *
 * This API endpoint permanently removes a FlexOffice chart from the system by
 * its unique identifier. The operation is a hard delete that will erase all
 * associated data with the chart, making it unrecoverable. Only authorized
 * users such as admin, editor, or viewer may perform this action to protect
 * data integrity and comply with permission policies.
 *
 * The operation expects the target chart to exist; otherwise, an error will be
 * returned. It complements other chart management endpoints such as create,
 * update, and retrieve. No request body is required.
 *
 * Care must be taken to handle cascading effects on dependent entities, such as
 * filter conditions or linked widgets, which should also be cleaned up by
 * backend transactional logic.
 *
 * @param props.connection
 * @param props.chartId Unique identifier of the target chart to delete
 * @path /flexOffice/admin/charts/:chartId
 * @accessor api.functional.flexOffice.admin.charts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target chart to delete */
    chartId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/flexOffice/admin/charts/:chartId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/flexOffice/admin/charts/${encodeURIComponent(props.chartId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("chartId")(() => typia.assert(props.chartId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
