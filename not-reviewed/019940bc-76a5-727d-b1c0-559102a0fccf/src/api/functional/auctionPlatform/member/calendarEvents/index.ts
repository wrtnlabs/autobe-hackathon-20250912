import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IAuctionPlatformCalendarEvent } from "../../../../structures/IAuctionPlatformCalendarEvent";
import { IAuctionPlatformCalendarEvents } from "../../../../structures/IAuctionPlatformCalendarEvents";
import { IPageIAuctionPlatformCalendarEvents } from "../../../../structures/IPageIAuctionPlatformCalendarEvents";

/**
 * Create a new auction calendar event to schedule an auction room. The
 * operation requires the auction room ID, a descriptive title, and a mandatory
 * start time. Optionally, an end time can be specified to denote auction
 * conclusion.
 *
 * The system validates references and temporal consistency before persisting
 * the event.
 *
 * Only authorized users can create new calendar events.
 *
 * Upon success, the newly created event details are returned.
 *
 * @param props.connection
 * @param props.body Data for new calendar event creation
 * @path /auctionPlatform/member/calendarEvents
 * @accessor api.functional.auctionPlatform.member.calendarEvents.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Data for new calendar event creation */
    body: IAuctionPlatformCalendarEvent.ICreate;
  };
  export type Body = IAuctionPlatformCalendarEvent.ICreate;
  export type Response = IAuctionPlatformCalendarEvent;

  export const METADATA = {
    method: "POST",
    path: "/auctionPlatform/member/calendarEvents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auctionPlatform/member/calendarEvents";
  export const random = (): IAuctionPlatformCalendarEvent =>
    typia.random<IAuctionPlatformCalendarEvent>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of auction calendar events.
 *
 * Retrieve a filtered and paginated list of auction platform calendar events
 * from the system. Each calendar event is linked to an auction room and
 * contains vital scheduling information such as start date (mandatory) and end
 * date (optional).
 *
 * The API supports advanced filtering, searching, and sorting capabilities to
 * help clients find auction events based on streamer names, dates, or other
 * criteria. Pagination parameters control the volume of data per query for
 * efficient network usage.
 *
 * Security considerations restrict access to authorized users only, ensuring
 * sensitive schedule information is protected. The operation integrates
 * directly with the auction_platform_calendar_events table from the Prisma
 * schema, leveraging all its columns and relationships.
 *
 * The response consists of a paginated list of calendar event summaries
 * optimized for calendar display with essential metadata.
 *
 * @param props.connection
 * @param props.body Filter criteria and pagination parameters for calendar
 *   event retrieval
 * @path /auctionPlatform/member/calendarEvents
 * @accessor api.functional.auctionPlatform.member.calendarEvents.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter criteria and pagination parameters for calendar event
     * retrieval
     */
    body: IAuctionPlatformCalendarEvents.IRequest;
  };
  export type Body = IAuctionPlatformCalendarEvents.IRequest;
  export type Response = IPageIAuctionPlatformCalendarEvents.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/auctionPlatform/member/calendarEvents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auctionPlatform/member/calendarEvents";
  export const random = (): IPageIAuctionPlatformCalendarEvents.ISummary =>
    typia.random<IPageIAuctionPlatformCalendarEvents.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information of a specific auction calendar event.
 *
 * Fetch detailed information of an auction calendar event by its ID. The
 * operation returns a single calendar event entity that includes all pertinent
 * scheduling data, such as the auction room linkage, title, start time, and
 * optional end time.
 *
 * Only authorized users may retrieve calendar event details to ensure sensitive
 * auction scheduling information remains secure.
 *
 * Errors such as invalid or non-existent IDs result in appropriate error
 * responses.
 *
 * This operation corresponds to the auction_platform_calendar_events table in
 * the Prisma schema.
 *
 * @param props.connection
 * @param props.calendarEventId Unique identifier of the target calendar event
 * @path /auctionPlatform/member/calendarEvents/:calendarEventId
 * @accessor api.functional.auctionPlatform.member.calendarEvents.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target calendar event */
    calendarEventId: string & tags.Format<"uuid">;
  };
  export type Response = IAuctionPlatformCalendarEvent;

  export const METADATA = {
    method: "GET",
    path: "/auctionPlatform/member/calendarEvents/:calendarEventId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/auctionPlatform/member/calendarEvents/${encodeURIComponent(props.calendarEventId ?? "null")}`;
  export const random = (): IAuctionPlatformCalendarEvent =>
    typia.random<IAuctionPlatformCalendarEvent>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("calendarEventId")(() =>
        typia.assert(props.calendarEventId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing auction calendar event.
 *
 * Update details of an existing auction calendar event identified by ID. The
 * operation accepts new values for the auction room linkage, title, start time,
 * and optional end time.
 *
 * All updates are validated and audited for consistency.
 *
 * Access is limited to authorized users.
 *
 * Upon success, the updated calendar event data is returned.
 *
 * @param props.connection
 * @param props.calendarEventId Unique identifier of the calendar event to
 *   update
 * @param props.body Update data for the calendar event
 * @path /auctionPlatform/member/calendarEvents/:calendarEventId
 * @accessor api.functional.auctionPlatform.member.calendarEvents.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the calendar event to update */
    calendarEventId: string & tags.Format<"uuid">;

    /** Update data for the calendar event */
    body: IAuctionPlatformCalendarEvent.IUpdate;
  };
  export type Body = IAuctionPlatformCalendarEvent.IUpdate;
  export type Response = IAuctionPlatformCalendarEvent;

  export const METADATA = {
    method: "PUT",
    path: "/auctionPlatform/member/calendarEvents/:calendarEventId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/auctionPlatform/member/calendarEvents/${encodeURIComponent(props.calendarEventId ?? "null")}`;
  export const random = (): IAuctionPlatformCalendarEvent =>
    typia.random<IAuctionPlatformCalendarEvent>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("calendarEventId")(() =>
        typia.assert(props.calendarEventId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
