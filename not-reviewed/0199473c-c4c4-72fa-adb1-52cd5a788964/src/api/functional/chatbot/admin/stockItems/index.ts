import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IChatbotStockItem } from "../../../../structures/IChatbotStockItem";
import { IChatbotStockItems } from "../../../../structures/IChatbotStockItems";

/**
 * Create a new chatbot virtual stock item.
 *
 * Create a new chatbot stock item with the provided code, name, and initial
 * price. The new record is stored in the chatbot_stock_items table, ensuring
 * the uniqueness of the code and name fields.
 *
 * Admins use this endpoint to add new stock items available for trading in the
 * virtual stock minigame.
 *
 * The request body must conform to the IChatbotStockItem.ICreate schema,
 * including validation for code, name, and initial price.
 *
 * Successful creation returns the full chatbot stock item record including
 * timestamps.
 *
 * Security restricts this operation to users with the admin role.
 *
 * @param props.connection
 * @param props.body Information required to create a new chatbot stock item
 * @path /chatbot/admin/stockItems
 * @accessor api.functional.chatbot.admin.stockItems.createStockItem
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createStockItem(
  connection: IConnection,
  props: createStockItem.Props,
): Promise<createStockItem.Response> {
  return true === connection.simulate
    ? createStockItem.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createStockItem.METADATA,
          path: createStockItem.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createStockItem {
  export type Props = {
    /** Information required to create a new chatbot stock item */
    body: IChatbotStockItem.ICreate;
  };
  export type Body = IChatbotStockItem.ICreate;
  export type Response = IChatbotStockItem;

  export const METADATA = {
    method: "POST",
    path: "/chatbot/admin/stockItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/chatbot/admin/stockItems";
  export const random = (): IChatbotStockItem =>
    typia.random<IChatbotStockItem>();
  export const simulate = (
    connection: IConnection,
    props: createStockItem.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createStockItem.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a virtual stock item's details by ID.
 *
 * Update the details of a virtual stock item identified by its stockItemId.
 * This operation allows administrators to change the stock item's code, name,
 * and initial price within valid ranges. The stock item must exist. The update
 * affects future transactions and price computations but does not alter
 * historical snapshots.
 *
 * Security considerations: This endpoint should be restricted to users with
 * administrative roles only. Proper authorization checks must be enforced.
 *
 * The operation relates directly to the chatbot_stock_items table in the Prisma
 * schema. The validated request body must contain details confirming to the
 * IChatbotStockItems.IUpdate DTO including the stock code, name, and initial
 * price.
 *
 * Validation rules enforce that the stockItemId is a valid UUID. The stock code
 * and name are unique. The initial price must be within 100 to 1,000,000
 * points.
 *
 * Related operations include listing stocks, adding new stocks, and deleting
 * stocks. Updating a stock is part of the administrative controls for managing
 * the virtual stock market.
 *
 * Error handling includes appropriate 404 if the stock item does not exist, and
 * validation errors for invalid input values.
 *
 * @param props.connection
 * @param props.stockItemId The unique identifier (UUID) of the target stock
 *   item
 * @param props.body Payload containing stock item update information
 * @path /chatbot/admin/stockItems/:stockItemId
 * @accessor api.functional.chatbot.admin.stockItems.updateStockItem
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateStockItem(
  connection: IConnection,
  props: updateStockItem.Props,
): Promise<updateStockItem.Response> {
  return true === connection.simulate
    ? updateStockItem.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateStockItem.METADATA,
          path: updateStockItem.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateStockItem {
  export type Props = {
    /** The unique identifier (UUID) of the target stock item */
    stockItemId: string & tags.Format<"uuid">;

    /** Payload containing stock item update information */
    body: IChatbotStockItems.IUpdate;
  };
  export type Body = IChatbotStockItems.IUpdate;
  export type Response = IChatbotStockItems;

  export const METADATA = {
    method: "PUT",
    path: "/chatbot/admin/stockItems/:stockItemId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/chatbot/admin/stockItems/${encodeURIComponent(props.stockItemId ?? "null")}`;
  export const random = (): IChatbotStockItems =>
    typia.random<IChatbotStockItems>();
  export const simulate = (
    connection: IConnection,
    props: updateStockItem.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateStockItem.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("stockItemId")(() => typia.assert(props.stockItemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a virtual stock item by ID (hard delete).
 *
 * Permanently delete a virtual stock item identified by its stockItemId. This
 * operation will remove the stock from listings and refund all user holdings
 * associated with this stock. The operation performs a hard delete of the
 * record from the chatbot_stock_items table.
 *
 * Only administrators can call this API to maintain system integrity.
 *
 * Error handling includes 404 if the stock does not exist and business logic
 * handling for refunding user holdings and adjusting balances.
 *
 * @param props.connection
 * @param props.stockItemId The unique identifier (UUID) of the stock item to
 *   delete
 * @path /chatbot/admin/stockItems/:stockItemId
 * @accessor api.functional.chatbot.admin.stockItems.eraseStockItem
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseStockItem(
  connection: IConnection,
  props: eraseStockItem.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseStockItem.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseStockItem.METADATA,
          path: eraseStockItem.path(props),
          status: null,
        },
      );
}
export namespace eraseStockItem {
  export type Props = {
    /** The unique identifier (UUID) of the stock item to delete */
    stockItemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/chatbot/admin/stockItems/:stockItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/chatbot/admin/stockItems/${encodeURIComponent(props.stockItemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseStockItem.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseStockItem.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("stockItemId")(() => typia.assert(props.stockItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
