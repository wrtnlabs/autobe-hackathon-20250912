import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEasySignFreelancerUser } from "../../../structures/IEasySignFreelancerUser";

/**
 * Register a new freelancerUser account and issue JWT tokens.
 *
 * This operation provides user registration for the role freelancerUser, whose
 * users are individual freelancers able to create and send contracts without
 * approval. It consumes email and password. The email field corresponds to
 * easy_sign_freelancerusers.email which is unique. Password hashes are stored
 * in easy_sign_user_credentials linked by user id. Upon successful
 * registration, JWT tokens including accessToken and refreshToken will be
 * issued, represented by response type IEasySignFreelancerUser.IAuthorized.
 * This endpoint is open to new user registrations, supporting token issuance
 * and subsequent authenticated access.
 *
 * Security considerations include proper password hashing before storage, email
 * uniqueness verification, and secure JWT token generation. This operation
 * forms the basis for all authenticated interactions for freelancer users.
 *
 * Related operations include login and refresh token issuance, supporting
 * session management lifecycle.
 *
 * The path /auth/freelancerUser/join is explicitly designated for user
 * registration requests for this role.
 *
 * Soft deletion in easy_sign_freelancerusers supports user deactivation without
 * data loss.
 *
 * @param props.connection
 * @param props.body Payload to register a freelancerUser, including email and
 *   password as basic credentials
 * @setHeader token.access Authorization
 *
 * @path /auth/freelancerUser/join
 * @accessor api.functional.auth.freelancerUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Payload to register a freelancerUser, including email and password as
     * basic credentials
     */
    body: IEasySignFreelancerUser.ICreate;
  };
  export type Body = IEasySignFreelancerUser.ICreate;
  export type Response = IEasySignFreelancerUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/freelancerUser/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/freelancerUser/join";
  export const random = (): IEasySignFreelancerUser.IAuthorized =>
    typia.random<IEasySignFreelancerUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate freelancerUser and issue JWT tokens.
 *
 * Authenticate freelancerUser by verifying email and password credentials.
 * Returns JWT access and refresh tokens for authenticated session management.
 * Password safety and uniqueness of email enforced per schema
 * easy_sign_freelancerusers and easy_sign_user_credentials.
 *
 * Useful for daily login and obtaining authorized access tokens for protected
 * APIs.
 *
 * Path /auth/freelancerUser/login serves as authentication entry point for this
 * role.
 *
 * Security threat mitigation includes hashed password verification and token
 * invalidation on logout.
 *
 * @param props.connection
 * @param props.body Credentials payload with email and password to authenticate
 *   freelancerUser
 * @setHeader token.access Authorization
 *
 * @path /auth/freelancerUser/login
 * @accessor api.functional.auth.freelancerUser.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Credentials payload with email and password to authenticate
     * freelancerUser
     */
    body: IEasySignFreelancerUser.ILogin;
  };
  export type Body = IEasySignFreelancerUser.ILogin;
  export type Response = IEasySignFreelancerUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/freelancerUser/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/freelancerUser/login";
  export const random = (): IEasySignFreelancerUser.IAuthorized =>
    typia.random<IEasySignFreelancerUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT tokens for freelancerUser.
 *
 * Refresh the JWT access token for freelancerUser using a valid refresh token.
 * Validates token and issues updated token set following security policies.
 *
 * Important for maintaining user sessions without requiring frequent logins.
 *
 * Ensures only authorized users maintain active sessions with up-to-date
 * tokens.
 *
 * Security measures include revocation check and token expiration.
 *
 * Returned tokens conform to IEasySignFreelancerUser.IAuthorized.
 *
 * Related to login and join operations for session flow.
 *
 * @param props.connection
 * @param props.body Payload containing refresh token for freelancerUser token
 *   renewal
 * @setHeader token.access Authorization
 *
 * @path /auth/freelancerUser/refresh
 * @accessor api.functional.auth.freelancerUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Payload containing refresh token for freelancerUser token renewal */
    body: IEasySignFreelancerUser.IRefresh;
  };
  export type Body = IEasySignFreelancerUser.IRefresh;
  export type Response = IEasySignFreelancerUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/freelancerUser/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/freelancerUser/refresh";
  export const random = (): IEasySignFreelancerUser.IAuthorized =>
    typia.random<IEasySignFreelancerUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
