import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPoliticalNewsCrawlerCrawlAttempt } from "../../../../../structures/IPoliticalNewsCrawlerCrawlAttempt";
import { IPageIPoliticalNewsCrawlerCrawlAttempt } from "../../../../../structures/IPageIPoliticalNewsCrawlerCrawlAttempt";

/**
 * Create a crawl attempt for a specified crawl job.
 *
 * Create a new crawl attempt record associated with a specific crawl job. The
 * operation logs the start of a crawl process for a political news source,
 * enabling tracking of individual crawl executions.
 *
 * Security considerations: This operation is restricted to system components or
 * users with a role capable of scheduling and managing crawling tasks. It
 * requires ownership or management privileges for the referenced crawl job.
 *
 * The API request must include details such as the crawl job ID and initial
 * crawl attempt metadata like the start time. The response confirms creation
 * with complete crawl attempt details.
 *
 * This operation interacts directly with the
 * political_news_crawler_crawl_attempts database table, ensuring each crawl
 * attempt is logged accurately for audit and operational monitoring.
 *
 * Validation rules prevent creation with nonexistent crawl job IDs and ensure
 * timestamp formats conform to ISO 8601 standards.
 *
 * This API is typically called by backend scheduler services or crawling
 * orchestrators to start crawl attempts.
 *
 * @param props.connection
 * @param props.crawlJobId Unique identifier of the crawl job
 * @param props.body Creation information for a new crawl attempt
 * @path /politicalNewsCrawler/guest/crawlJobs/:crawlJobId/crawlAttempts
 * @accessor api.functional.politicalNewsCrawler.guest.crawlJobs.crawlAttempts.createCrawlAttempt
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createCrawlAttempt(
  connection: IConnection,
  props: createCrawlAttempt.Props,
): Promise<createCrawlAttempt.Response> {
  return true === connection.simulate
    ? createCrawlAttempt.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createCrawlAttempt.METADATA,
          path: createCrawlAttempt.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createCrawlAttempt {
  export type Props = {
    /** Unique identifier of the crawl job */
    crawlJobId: string & tags.Format<"uuid">;

    /** Creation information for a new crawl attempt */
    body: IPoliticalNewsCrawlerCrawlAttempt.ICreate;
  };
  export type Body = IPoliticalNewsCrawlerCrawlAttempt.ICreate;
  export type Response = IPoliticalNewsCrawlerCrawlAttempt;

  export const METADATA = {
    method: "POST",
    path: "/politicalNewsCrawler/guest/crawlJobs/:crawlJobId/crawlAttempts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/politicalNewsCrawler/guest/crawlJobs/${encodeURIComponent(props.crawlJobId ?? "null")}/crawlAttempts`;
  export const random = (): IPoliticalNewsCrawlerCrawlAttempt =>
    typia.random<IPoliticalNewsCrawlerCrawlAttempt>();
  export const simulate = (
    connection: IConnection,
    props: createCrawlAttempt.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createCrawlAttempt.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("crawlJobId")(() => typia.assert(props.crawlJobId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List crawl attempts for a specific crawl job.
 *
 * Retrieve a filtered and paginated list of crawl attempts performed under a
 * specific crawl job. This enables monitoring and auditing of individual
 * execution runs, including success status, run times, and error details.
 *
 * The operation accepts the crawl job ID as a path parameter and supports
 * complex search criteria in the request body.
 *
 * It returns a paginated list of crawl attempt summaries with metadata.
 *
 * Access to this operation requires guest role authorization as per system role
 * configuration.
 *
 * Related operations include retrieving individual crawl attempt details.
 *
 * Expected behavior is to supply crawl attempt data efficiently and support
 * pagination for large datasets.
 *
 * @param props.connection
 * @param props.crawlJobId Unique identifier of the crawl job whose attempts to
 *   retrieve
 * @param props.body Search parameters for crawl attempts
 * @path /politicalNewsCrawler/guest/crawlJobs/:crawlJobId/crawlAttempts
 * @accessor api.functional.politicalNewsCrawler.guest.crawlJobs.crawlAttempts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the crawl job whose attempts to retrieve */
    crawlJobId: string & tags.Format<"uuid">;

    /** Search parameters for crawl attempts */
    body: IPoliticalNewsCrawlerCrawlAttempt.IRequest;
  };
  export type Body = IPoliticalNewsCrawlerCrawlAttempt.IRequest;
  export type Response = IPageIPoliticalNewsCrawlerCrawlAttempt.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/politicalNewsCrawler/guest/crawlJobs/:crawlJobId/crawlAttempts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/politicalNewsCrawler/guest/crawlJobs/${encodeURIComponent(props.crawlJobId ?? "null")}/crawlAttempts`;
  export const random = (): IPageIPoliticalNewsCrawlerCrawlAttempt.ISummary =>
    typia.random<IPageIPoliticalNewsCrawlerCrawlAttempt.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("crawlJobId")(() => typia.assert(props.crawlJobId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a crawl attempt by ID.
 *
 * Fetch detailed information for a crawl attempt identified by its unique ID,
 * linked to a specific crawl job. This allows inspection of individual crawl
 * execution details including timestamps, success status, and error messages.
 *
 * The operation requires both the crawl job ID and the crawl attempt ID to
 * locate the record.
 *
 * Access to this operation requires guest role authorization as per system role
 * configuration.
 *
 * Related operations include listing crawl attempts for a crawl job.
 *
 * Expected behavior is to return the crawl attempt resource or an error if not
 * found.
 *
 * @param props.connection
 * @param props.crawlJobId Unique identifier of the crawl job containing the
 *   attempt
 * @param props.id Unique identifier of the crawl attempt to retrieve
 * @path /politicalNewsCrawler/guest/crawlJobs/:crawlJobId/crawlAttempts/:id
 * @accessor api.functional.politicalNewsCrawler.guest.crawlJobs.crawlAttempts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the crawl job containing the attempt */
    crawlJobId: string & tags.Format<"uuid">;

    /** Unique identifier of the crawl attempt to retrieve */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IPoliticalNewsCrawlerCrawlAttempt;

  export const METADATA = {
    method: "GET",
    path: "/politicalNewsCrawler/guest/crawlJobs/:crawlJobId/crawlAttempts/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/politicalNewsCrawler/guest/crawlJobs/${encodeURIComponent(props.crawlJobId ?? "null")}/crawlAttempts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IPoliticalNewsCrawlerCrawlAttempt =>
    typia.random<IPoliticalNewsCrawlerCrawlAttempt>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("crawlJobId")(() => typia.assert(props.crawlJobId));
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details of a crawl attempt by ID under a given crawl job.
 *
 * Update details of an existing crawl attempt record associated with a
 * specified crawl job. This operation enables modification of crawl attempt
 * state, success indication, completion time, and error information.
 *
 * Security: Restricted to roles with permission to manage crawling tasks. This
 * operation enforces validation of both crawl job and crawl attempt
 * identifiers.
 *
 * The operation interacts with the political_news_crawler_crawl_attempts
 * database table, ensuring consistent updates to crawl execution logs.
 *
 * Completed timestamps must be later than the started timestamp. Error message
 * updates may be used for debugging failed attempts.
 *
 * This API is typically called by crawler system components upon completion or
 * error detection in crawling.
 *
 * @param props.connection
 * @param props.crawlJobId Unique identifier of the crawl job
 * @param props.id Unique identifier of the crawl attempt
 * @param props.body Updated crawl attempt information
 * @path /politicalNewsCrawler/guest/crawlJobs/:crawlJobId/crawlAttempts/:id
 * @accessor api.functional.politicalNewsCrawler.guest.crawlJobs.crawlAttempts.updateCrawlAttempt
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateCrawlAttempt(
  connection: IConnection,
  props: updateCrawlAttempt.Props,
): Promise<updateCrawlAttempt.Response> {
  return true === connection.simulate
    ? updateCrawlAttempt.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateCrawlAttempt.METADATA,
          path: updateCrawlAttempt.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateCrawlAttempt {
  export type Props = {
    /** Unique identifier of the crawl job */
    crawlJobId: string & tags.Format<"uuid">;

    /** Unique identifier of the crawl attempt */
    id: string & tags.Format<"uuid">;

    /** Updated crawl attempt information */
    body: IPoliticalNewsCrawlerCrawlAttempt.IUpdate;
  };
  export type Body = IPoliticalNewsCrawlerCrawlAttempt.IUpdate;
  export type Response = IPoliticalNewsCrawlerCrawlAttempt;

  export const METADATA = {
    method: "PUT",
    path: "/politicalNewsCrawler/guest/crawlJobs/:crawlJobId/crawlAttempts/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/politicalNewsCrawler/guest/crawlJobs/${encodeURIComponent(props.crawlJobId ?? "null")}/crawlAttempts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IPoliticalNewsCrawlerCrawlAttempt =>
    typia.random<IPoliticalNewsCrawlerCrawlAttempt>();
  export const simulate = (
    connection: IConnection,
    props: updateCrawlAttempt.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateCrawlAttempt.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("crawlJobId")(() => typia.assert(props.crawlJobId));
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a crawl attempt record by crawl job ID and crawl attempt ID.
 *
 * Permanently delete a crawl attempt record by specifying its crawl job ID and
 * crawl attempt ID.
 *
 * This is a hard delete operation with no support for soft deletion or
 * recovery.
 *
 * Access is restricted to users with administrative rights or system-level
 * permissions.
 *
 * The operation directly impacts the political_news_crawler_crawl_attempts
 * table.
 *
 * No response body is returned upon success.
 *
 * Use with caution due to permanent data removal.
 *
 * @param props.connection
 * @param props.crawlJobId Unique identifier of the crawl job
 * @param props.id Unique identifier of the crawl attempt
 * @path /politicalNewsCrawler/guest/crawlJobs/:crawlJobId/crawlAttempts/:id
 * @accessor api.functional.politicalNewsCrawler.guest.crawlJobs.crawlAttempts.eraseCrawlAttempt
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseCrawlAttempt(
  connection: IConnection,
  props: eraseCrawlAttempt.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseCrawlAttempt.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseCrawlAttempt.METADATA,
          path: eraseCrawlAttempt.path(props),
          status: null,
        },
      );
}
export namespace eraseCrawlAttempt {
  export type Props = {
    /** Unique identifier of the crawl job */
    crawlJobId: string & tags.Format<"uuid">;

    /** Unique identifier of the crawl attempt */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/politicalNewsCrawler/guest/crawlJobs/:crawlJobId/crawlAttempts/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/politicalNewsCrawler/guest/crawlJobs/${encodeURIComponent(props.crawlJobId ?? "null")}/crawlAttempts/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseCrawlAttempt.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseCrawlAttempt.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("crawlJobId")(() => typia.assert(props.crawlJobId));
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
