import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postrecipeSharingRegularUserTags } from "../../../../providers/postrecipeSharingRegularUserTags";
import { RegularuserAuth } from "../../../../decorators/RegularuserAuth";
import { RegularuserPayload } from "../../../../decorators/payload/RegularuserPayload";
import { patchrecipeSharingRegularUserTags } from "../../../../providers/patchrecipeSharingRegularUserTags";
import { getrecipeSharingRegularUserTagsTagId } from "../../../../providers/getrecipeSharingRegularUserTagsTagId";

import { IRecipeSharingTags } from "../../../../api/structures/IRecipeSharingTags";
import { IPageIRecipeSharingTags } from "../../../../api/structures/IPageIRecipeSharingTags";

@Controller("/recipeSharing/regularUser/tags")
export class RecipesharingRegularuserTagsController {
  /**
   * Create a new recipe tag with a unique name and optional description.
   *
   * The request must include a JSON body adhering to the
   * IRecipeSharingTags.ICreate schema.
   *
   * Authorization requires the user role.
   *
   * Handling duplicate names or validation failures returning error details is
   * expected.
   *
   * On success, the complete tag record is returned for confirmation and
   * further use.
   *
   * Related operations include listing tags and fetching individual tag
   * details.
   *
   * @param connection
   * @param body Data needed to create a new recipe tag
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedBody()
    body: IRecipeSharingTags.ICreate,
  ): Promise<IRecipeSharingTags> {
    try {
      return await postrecipeSharingRegularUserTags({
        regularUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve a list of recipe tags.
   *
   * Retrieve a filtered and paginated list of recipe tags.
   *
   * This endpoint allows searching among tags by name or description using
   * substring matching. Pagination and sorting options enable users to browse
   * the tag collection efficiently.
   *
   * Security considerations ensure only authenticated users can access this
   * endpoint.
   *
   * The response provides paged tag summary information suitable for listing
   * displays.
   *
   * Related endpoints include creating new tags and retrieving specific tag
   * details.
   *
   * Errors may arise from invalid filters or pagination parameters.
   *
   * Consumers should implement retry or fallback logic as needed.
   *
   * @param connection
   * @param body Search criteria and pagination parameters for tag filtering
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedBody()
    body: IRecipeSharingTags.IRequest,
  ): Promise<IPageIRecipeSharingTags.ISummary> {
    try {
      return await patchrecipeSharingRegularUserTags({
        regularUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get recipe tag details by ID.
   *
   * Fetch a recipe tag's full detail by its unique ID.
   *
   * This endpoint returns all stored information of a tag including name and
   * description fields.
   *
   * Authentication is required to access detailed tag data.
   *
   * Related endpoints include tag listing and creation.
   *
   * Client applications should gracefully handle cases where the tag ID does
   * not exist.
   *
   * @param connection
   * @param tagId Unique identifier of the recipe tag
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":tagId")
  public async at(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedParam("tagId")
    tagId: string & tags.Format<"uuid">,
  ): Promise<IRecipeSharingTags> {
    try {
      return await getrecipeSharingRegularUserTagsTagId({
        regularUser,
        tagId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
