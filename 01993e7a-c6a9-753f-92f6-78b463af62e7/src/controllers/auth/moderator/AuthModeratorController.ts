import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthModeratorJoin } from "../../../providers/postauthModeratorJoin";
import { ModeratorAuth } from "../../../decorators/ModeratorAuth";
import { ModeratorPayload } from "../../../decorators/payload/ModeratorPayload";
import { postauthModeratorLogin } from "../../../providers/postauthModeratorLogin";
import { postauthModeratorRefresh } from "../../../providers/postauthModeratorRefresh";

import { IRecipeSharingModerator } from "../../../api/structures/IRecipeSharingModerator";

@Controller("/auth/moderator")
export class AuthModeratorController {
  /**
   * Register a new moderator user in the recipe_sharing_moderators table and
   * issue JWT tokens upon success.
   *
   * This endpoint creates a new moderator user account in the Recipe Sharing
   * Backend system by inserting a new record into the recipe_sharing_moderators
   * table. It accepts the moderator's email, hashed password, and unique
   * username. Upon successful registration, the system issues JWT tokens to
   * enable authenticated session management. The operation ensures unique email
   * and username constraints while enabling soft delete via nullable
   * deleted_at. This registration flow is a crucial starting point for
   * moderators who manage flagged content, approve categories, and enforce
   * platform policies.
   *
   * @param connection
   * @param body Information needed to create a new moderator user account.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @ModeratorAuth()
    moderator: ModeratorPayload,
    @TypedBody()
    body: IRecipeSharingModerator.ICreate,
  ): Promise<IRecipeSharingModerator.IAuthorized> {
    try {
      return await postauthModeratorJoin({
        moderator,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate moderator user and issue JWT tokens upon successful login.
   *
   * This endpoint authenticates a moderator user with email and password
   * credential verification against stored hashed passwords in the
   * recipe_sharing_moderators table. It denies access for deleted accounts
   * (soft deleted via deleted_at). Upon successful login, it issues JWT tokens
   * representing the moderator's authenticated session state. This is a core
   * authentication operation allowing moderators to perform moderation actions
   * securely.
   *
   * @param connection
   * @param body Moderator login credentials including email and password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @ModeratorAuth()
    moderator: ModeratorPayload,
    @TypedBody()
    body: IRecipeSharingModerator.ILogin,
  ): Promise<IRecipeSharingModerator.IAuthorized> {
    try {
      return await postauthModeratorLogin({
        moderator,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh JWT tokens for the authenticated moderator user.
   *
   * This endpoint allows a moderator user to refresh their authentication
   * tokens using a valid refresh token. It verifies token validity, expiration,
   * and associated user permissions. Upon validation, it generates new JWT
   * tokens for the moderator to maintain an active session without re-login.
   * Token refresh operations are essential for security and usability in
   * managing session lifespan securely.
   *
   * @param connection
   * @param body Refresh token payload for moderator user.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @ModeratorAuth()
    moderator: ModeratorPayload,
    @TypedBody()
    body: IRecipeSharingModerator.IRefresh,
  ): Promise<IRecipeSharingModerator.IAuthorized> {
    try {
      return await postauthModeratorRefresh({
        moderator,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
