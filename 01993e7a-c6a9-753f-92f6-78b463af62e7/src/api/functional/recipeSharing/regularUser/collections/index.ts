import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRecipeSharingCollections } from "../../../../structures/IRecipeSharingCollections";
import { IPageIRecipeSharingCollections } from "../../../../structures/IPageIRecipeSharingCollections";

/**
 * Retrieve detailed recipe collection information by collectionId.
 *
 * Retrieve detailed information for a recipe collection using its unique
 * identifier (collectionId). The collection belongs to a user and includes
 * attributes such as name, optional description, creation and update
 * timestamps, and soft deletion timestamp if applicable.
 *
 * Security considerations require that only authenticated users with proper
 * permissions may access this endpoint to protect user data privacy and
 * integrity.
 *
 * The operation relates directly to the recipe_sharing_collections table, which
 * enforces unique collection names per user and supports soft deletion via the
 * deleted_at field.
 *
 * Validation ensures that collectionId is a valid UUID and the collection
 * exists. Proper error handling is expected for non-existent or unauthorized
 * access attempts.
 *
 * This GET endpoint complements collection management APIs, facilitating read
 * access to individual collections.
 *
 * @param props.connection
 * @param props.collectionId Unique identifier of the target recipe collection
 * @path /recipeSharing/regularUser/collections/:collectionId
 * @accessor api.functional.recipeSharing.regularUser.collections.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target recipe collection */
    collectionId: string & tags.Format<"uuid">;
  };
  export type Response = IRecipeSharingCollections;

  export const METADATA = {
    method: "GET",
    path: "/recipeSharing/regularUser/collections/:collectionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/regularUser/collections/${encodeURIComponent(props.collectionId ?? "null")}`;
  export const random = (): IRecipeSharingCollections =>
    typia.random<IRecipeSharingCollections>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("collectionId")(() => typia.assert(props.collectionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update existing collection by ID.
 *
 * Update an existing user collection in the Recipe Sharing backend system. The
 * collection must be identified by the collectionId parameter in the path.
 *
 * This operation allows changing the collection's name and description fields.
 * It verifies the userâ€™s ownership of the collection and ensures the collection
 * is not soft-deleted.
 *
 * The Recipe Sharing system stores collections in the
 * recipe_sharing_collections table, which contains fields such as owner_user_id
 * (linking to the user), name, and optional description. The created_at and
 * updated_at timestamps are managed internally by the system.
 *
 * Authorization is required to ensure only the owner can update their
 * collection.
 *
 * Errors occur if the collection does not exist, is soft-deleted, or the
 * requesting user lacks permission.
 *
 * Successful updates return the updated collection information.
 *
 * @param props.connection
 * @param props.collectionId Unique identifier of the target collection
 * @param props.body Update data for the collection
 * @path /recipeSharing/regularUser/collections/:collectionId
 * @accessor api.functional.recipeSharing.regularUser.collections.updateCollection
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateCollection(
  connection: IConnection,
  props: updateCollection.Props,
): Promise<updateCollection.Response> {
  return true === connection.simulate
    ? updateCollection.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateCollection.METADATA,
          path: updateCollection.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateCollection {
  export type Props = {
    /** Unique identifier of the target collection */
    collectionId: string & tags.Format<"uuid">;

    /** Update data for the collection */
    body: IRecipeSharingCollections.IUpdate;
  };
  export type Body = IRecipeSharingCollections.IUpdate;
  export type Response = IRecipeSharingCollections;

  export const METADATA = {
    method: "PUT",
    path: "/recipeSharing/regularUser/collections/:collectionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/regularUser/collections/${encodeURIComponent(props.collectionId ?? "null")}`;
  export const random = (): IRecipeSharingCollections =>
    typia.random<IRecipeSharingCollections>();
  export const simulate = (
    connection: IConnection,
    props: updateCollection.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateCollection.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("collectionId")(() => typia.assert(props.collectionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete user collection permanently.
 *
 * Permanently remove a user collection by its unique identifier. This operation
 * performs a hard delete on the collection record.
 *
 * Ownership verification is required to ensure only the owner user can delete
 * their collection.
 *
 * The system deletes the collection record and all associated references.
 *
 * This operation does not return a response body.
 *
 * Use with caution as deleted records cannot be recovered.
 *
 * @param props.connection
 * @param props.collectionId Unique identifier of the target collection
 * @path /recipeSharing/regularUser/collections/:collectionId
 * @accessor api.functional.recipeSharing.regularUser.collections.eraseCollection
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseCollection(
  connection: IConnection,
  props: eraseCollection.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseCollection.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseCollection.METADATA,
          path: eraseCollection.path(props),
          status: null,
        },
      );
}
export namespace eraseCollection {
  export type Props = {
    /** Unique identifier of the target collection */
    collectionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/recipeSharing/regularUser/collections/:collectionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/regularUser/collections/${encodeURIComponent(props.collectionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseCollection.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseCollection.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("collectionId")(() => typia.assert(props.collectionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a new recipe collection for user.
 *
 * Create a new recipe collection for the authenticated user. The creation
 * request body must provide the collection name, and optionally a description.
 *
 * Upon successful insertion, the system returns complete details of the created
 * collection, including timestamps and ownership identifiers.
 *
 * This POST operation enables users to organize recipes via collections to
 * enhance personalization and meal planning.
 *
 * The recipe_sharing_collections table supports soft deletion and enforces
 * unique collection names for each owner.
 *
 * Security ensures that only authenticated regular users may create collections
 * tied to their user ID.
 *
 * @param props.connection
 * @param props.body Payload data for creating a new recipe collection
 * @path /recipeSharing/regularUser/collections
 * @accessor api.functional.recipeSharing.regularUser.collections.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Payload data for creating a new recipe collection */
    body: IRecipeSharingCollections.ICreate;
  };
  export type Body = IRecipeSharingCollections.ICreate;
  export type Response = IRecipeSharingCollections;

  export const METADATA = {
    method: "POST",
    path: "/recipeSharing/regularUser/collections",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/recipeSharing/regularUser/collections";
  export const random = (): IRecipeSharingCollections =>
    typia.random<IRecipeSharingCollections>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated list of user recipe collections.
 *
 * Retrieve a paginated list of recipe collections with filtering, searching,
 * and sorting capabilities. Users may provide search criteria such as
 * collection name, creation date ranges, and other filters.
 *
 * Results include paginated collection summaries suitable for UI display.
 * Pagination supports page number, page size, and sorting.
 *
 * Security requires authenticated user access, ensuring only collections
 * belonging to the user are returned.
 *
 * This PATCH operation is crucial for building user interfaces that allow
 * efficient management of multiple recipe collections.
 *
 * The underlying database entity is recipe_sharing_collections, with uniqueness
 * constraints on collection names per user and support for soft deletes.
 *
 * @param props.connection
 * @param props.body Request body containing search filters and pagination
 *   parameters for collections
 * @path /recipeSharing/regularUser/collections
 * @accessor api.functional.recipeSharing.regularUser.collections.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Request body containing search filters and pagination parameters for
     * collections
     */
    body: IRecipeSharingCollections.IRequest;
  };
  export type Body = IRecipeSharingCollections.IRequest;
  export type Response = IPageIRecipeSharingCollections.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/recipeSharing/regularUser/collections",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/recipeSharing/regularUser/collections";
  export const random = (): IPageIRecipeSharingCollections.ISummary =>
    typia.random<IPageIRecipeSharingCollections.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
