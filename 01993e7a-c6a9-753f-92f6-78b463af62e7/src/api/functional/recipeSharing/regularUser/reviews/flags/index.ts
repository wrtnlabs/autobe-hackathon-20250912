import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRecipeSharingReviewFlag } from "../../../../../structures/IRecipeSharingReviewFlag";

/**
 * Create a new flag on a specified review for inappropriate content reporting.
 *
 * This API enables authenticated users to flag a specific review by providing a
 * reason such as spam or offensive content. The action is recorded in the
 * recipe_sharing_review_flags table, linking the flag to the user and the
 * review.
 *
 * Proper flagging assists moderators in maintaining content quality and
 * community standards by identifying problematic reviews for further review.
 *
 * Security considerations include verification of user credentials and ensuring
 * users cannot flag the same review multiple times for the same reason.
 *
 * The operation requires the review ID as a path parameter and expects a JSON
 * request body specifying the flag reason. The response returns the newly
 * created flag's details.
 *
 * This operation relates to the RatingsReviews schema, providing necessary CRUD
 * operations for user-submitted review flags. It complements moderation
 * workflows which handle flagged reviews.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the target review to be flagged
 * @param props.body Flag information including the reason for flagging
 * @path /recipeSharing/regularUser/reviews/:reviewId/flags
 * @accessor api.functional.recipeSharing.regularUser.reviews.flags.createFlag
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createFlag(
  connection: IConnection,
  props: createFlag.Props,
): Promise<createFlag.Response> {
  return true === connection.simulate
    ? createFlag.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createFlag.METADATA,
          path: createFlag.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createFlag {
  export type Props = {
    /** Unique identifier of the target review to be flagged */
    reviewId: string & tags.Format<"uuid">;

    /** Flag information including the reason for flagging */
    body: IRecipeSharingReviewFlag.ICreate;
  };
  export type Body = IRecipeSharingReviewFlag.ICreate;
  export type Response = IRecipeSharingReviewFlag;

  export const METADATA = {
    method: "POST",
    path: "/recipeSharing/regularUser/reviews/:reviewId/flags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/regularUser/reviews/${encodeURIComponent(props.reviewId ?? "null")}/flags`;
  export const random = (): IRecipeSharingReviewFlag =>
    typia.random<IRecipeSharingReviewFlag>();
  export const simulate = (
    connection: IConnection,
    props: createFlag.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createFlag.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update flag details on a specific review.
 *
 * Update an existing flag on a review to modify reason or status. Users can
 * correct or change their flags if needed.
 *
 * This supports accurate flag reporting and moderation workflows.
 *
 * Proper authentication and authorization checks must be in place to restrict
 * modifications to flag owners.
 *
 * The operation requires reviewId and flagId parameters and a JSON request body
 * with update information.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the review associated with the
 *   flag
 * @param props.flagId Unique identifier of the flag to update
 * @param props.body Updated flag information
 * @path /recipeSharing/regularUser/reviews/:reviewId/flags/:flagId
 * @accessor api.functional.recipeSharing.regularUser.reviews.flags.updateFlag
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateFlag(
  connection: IConnection,
  props: updateFlag.Props,
): Promise<updateFlag.Response> {
  return true === connection.simulate
    ? updateFlag.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateFlag.METADATA,
          path: updateFlag.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateFlag {
  export type Props = {
    /** Unique identifier of the review associated with the flag */
    reviewId: string & tags.Format<"uuid">;

    /** Unique identifier of the flag to update */
    flagId: string & tags.Format<"uuid">;

    /** Updated flag information */
    body: IRecipeSharingReviewFlag.IUpdate;
  };
  export type Body = IRecipeSharingReviewFlag.IUpdate;
  export type Response = IRecipeSharingReviewFlag;

  export const METADATA = {
    method: "PUT",
    path: "/recipeSharing/regularUser/reviews/:reviewId/flags/:flagId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/regularUser/reviews/${encodeURIComponent(props.reviewId ?? "null")}/flags/${encodeURIComponent(props.flagId ?? "null")}`;
  export const random = (): IRecipeSharingReviewFlag =>
    typia.random<IRecipeSharingReviewFlag>();
  export const simulate = (
    connection: IConnection,
    props: updateFlag.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateFlag.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("flagId")(() => typia.assert(props.flagId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a specific flag from a review.
 *
 * Delete a flag from a review. This operation permanently removes the flag
 * record from the database.
 *
 * Users can retract flags if they were created erroneously.
 *
 * Authorization ensures only flag owners or appropriate users can perform
 * deletion.
 *
 * The endpoint requires reviewId and flagId in the path and performs a hard
 * delete, removing all traces of the flag.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the review associated with the
 *   flag
 * @param props.flagId Unique identifier of the flag to delete
 * @path /recipeSharing/regularUser/reviews/:reviewId/flags/:flagId
 * @accessor api.functional.recipeSharing.regularUser.reviews.flags.eraseFlag
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseFlag(
  connection: IConnection,
  props: eraseFlag.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseFlag.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseFlag.METADATA,
          path: eraseFlag.path(props),
          status: null,
        },
      );
}
export namespace eraseFlag {
  export type Props = {
    /** Unique identifier of the review associated with the flag */
    reviewId: string & tags.Format<"uuid">;

    /** Unique identifier of the flag to delete */
    flagId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/recipeSharing/regularUser/reviews/:reviewId/flags/:flagId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/regularUser/reviews/${encodeURIComponent(props.reviewId ?? "null")}/flags/${encodeURIComponent(props.flagId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseFlag.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseFlag.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("flagId")(() => typia.assert(props.flagId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
