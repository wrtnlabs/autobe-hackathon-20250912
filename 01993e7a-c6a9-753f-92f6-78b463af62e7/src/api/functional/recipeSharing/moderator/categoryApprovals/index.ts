import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRecipeSharingCategoryApprovals } from "../../../../structures/IRecipeSharingCategoryApprovals";
import { IPageIRecipeSharingCategoryApprovals } from "../../../../structures/IPageIRecipeSharingCategoryApprovals";

/**
 * Search and list user-submitted category approvals.
 *
 * Retrieves a list of category approval submissions made by users that are
 * awaiting moderator approval or have been reviewed. This operation supports
 * filtering by category name, approval status (pending, approved, rejected),
 * and submission or review dates, allowing moderators or administrative users
 * to manage category approvals efficiently.
 *
 * Security is enforced by requiring moderator roles to access this data due to
 * its sensitive nature involving user-generated content and moderation
 * processes.
 *
 * This operation corresponds to the recipe_sharing_category_approvals table in
 * the database schema, which stores user-submitted categories or tags pending
 * approval, including submission timestamps and review status.
 *
 * The API supports comprehensive pagination and sorting to handle potentially
 * large numbers of submissions. Errors returned will inform on invalid
 * parameters or authorization issues.
 *
 * @param props.connection
 * @param props.body Search parameters for filtering category approvals
 * @path /recipeSharing/moderator/categoryApprovals
 * @accessor api.functional.recipeSharing.moderator.categoryApprovals.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search parameters for filtering category approvals */
    body: IRecipeSharingCategoryApprovals.IRequest;
  };
  export type Body = IRecipeSharingCategoryApprovals.IRequest;
  export type Response = IPageIRecipeSharingCategoryApprovals.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/recipeSharing/moderator/categoryApprovals",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/recipeSharing/moderator/categoryApprovals";
  export const random = (): IPageIRecipeSharingCategoryApprovals.ISummary =>
    typia.random<IPageIRecipeSharingCategoryApprovals.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a category approval.
 *
 * Fetches detailed data about a category approval request identified by the
 * provided ID. The response includes the category name, approval status,
 * submission timestamp, review timestamp if applicable, and audit metadata.
 * This detailed view enables moderators to assess the submission context and
 * make informed decisions.
 *
 * Access to this endpoint is restricted to users with moderator roles due to
 * the sensitive nature of moderation data.
 *
 * The operation maps to the recipe_sharing_category_approvals table in the
 * Prisma schema, which maintains the record of user-submitted categories
 * pending approval.
 *
 * Invalid IDs or unauthorized access attempts result in appropriate error
 * messages indicating the failure reason.
 *
 * @param props.connection
 * @param props.id Unique identifier of the category approval record
 * @path /recipeSharing/moderator/categoryApprovals/:id
 * @accessor api.functional.recipeSharing.moderator.categoryApprovals.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the category approval record */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRecipeSharingCategoryApprovals;

  export const METADATA = {
    method: "GET",
    path: "/recipeSharing/moderator/categoryApprovals/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/moderator/categoryApprovals/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IRecipeSharingCategoryApprovals =>
    typia.random<IRecipeSharingCategoryApprovals>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing category approval request.
 *
 * Allows moderators to modify an existing category approval entry identified by
 * its ID. This includes changing the approval status (pending, approved,
 * rejected), adding review timestamps, and updating any relevant metadata.
 *
 * This endpoint is restricted to moderator users given its critical role in
 * content curation and quality control.
 *
 * The operation corresponds to the recipe_sharing_category_approvals table,
 * updating records that represent user-submitted category suggestions.
 *
 * Inappropriate updates or unauthorized attempts return error messages
 * describing the issue.
 *
 * @param props.connection
 * @param props.id Unique identifier of the category approval record to update
 * @param props.body Updated category approval data
 * @path /recipeSharing/moderator/categoryApprovals/:id
 * @accessor api.functional.recipeSharing.moderator.categoryApprovals.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the category approval record to update */
    id: string & tags.Format<"uuid">;

    /** Updated category approval data */
    body: IRecipeSharingCategoryApprovals.IUpdate;
  };
  export type Body = IRecipeSharingCategoryApprovals.IUpdate;
  export type Response = IRecipeSharingCategoryApprovals;

  export const METADATA = {
    method: "PUT",
    path: "/recipeSharing/moderator/categoryApprovals/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/moderator/categoryApprovals/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IRecipeSharingCategoryApprovals =>
    typia.random<IRecipeSharingCategoryApprovals>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a category approval request by ID.
 *
 * This API operation permanently deletes a category approval request record
 * from the system by its unique identifier. The category approval record links
 * user-submitted category or tag suggestions pending moderator approval. By
 * calling this endpoint, the specified record is removed entirely from the
 * database and will no longer appear in moderation queues or logs.
 *
 * Only users with the correct authorization roles, such as moderators, should
 * be permitted to perform this deletion, protecting the moderation process's
 * integrity and auditability.
 *
 * The 'id' path parameter specifies the UUID of the target category approval
 * record. If the record does not exist, the server should respond with an
 * appropriate error code.
 *
 * This operation has no request body, and the response contains no content upon
 * successful deletion.
 *
 * This DELETE operation directly manipulates data in the
 * 'recipe_sharing_category_approvals' table from the Prisma schema.
 *
 * @param props.connection
 * @param props.id Target category approval request's unique UUID
 * @path /recipeSharing/moderator/categoryApprovals/:id
 * @accessor api.functional.recipeSharing.moderator.categoryApprovals.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target category approval request's unique UUID */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/recipeSharing/moderator/categoryApprovals/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/moderator/categoryApprovals/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
