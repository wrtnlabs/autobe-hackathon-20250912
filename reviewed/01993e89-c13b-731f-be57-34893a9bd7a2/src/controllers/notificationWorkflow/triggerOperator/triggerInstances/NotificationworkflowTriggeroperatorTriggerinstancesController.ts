import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postnotificationWorkflowTriggerOperatorTriggerInstances } from "../../../../providers/postnotificationWorkflowTriggerOperatorTriggerInstances";
import { TriggerOperatorAuth } from "../../../../decorators/TriggerOperatorAuth";
import { TriggerOperatorPayload } from "../../../../decorators/payload/TriggerOperatorPayload";
import { patchnotificationWorkflowTriggerOperatorTriggerInstances } from "../../../../providers/patchnotificationWorkflowTriggerOperatorTriggerInstances";
import { getnotificationWorkflowTriggerOperatorTriggerInstancesTriggerInstanceId } from "../../../../providers/getnotificationWorkflowTriggerOperatorTriggerInstancesTriggerInstanceId";
import { putnotificationWorkflowTriggerOperatorTriggerInstancesTriggerInstanceId } from "../../../../providers/putnotificationWorkflowTriggerOperatorTriggerInstancesTriggerInstanceId";
import { deletenotificationWorkflowTriggerOperatorTriggerInstancesTriggerInstanceId } from "../../../../providers/deletenotificationWorkflowTriggerOperatorTriggerInstancesTriggerInstanceId";

import { INotificationWorkflowTriggerInstance } from "../../../../api/structures/INotificationWorkflowTriggerInstance";
import { IPageINotificationWorkflowTriggerInstance } from "../../../../api/structures/IPageINotificationWorkflowTriggerInstance";

@Controller("/notificationWorkflow/triggerOperator/triggerInstances")
export class NotificationworkflowTriggeroperatorTriggerinstancesController {
  /**
   * Create a new TriggerInstance with idempotency enforcement.
   *
   * Create a new TriggerInstance for triggering a notification workflow. This
   * creation enforces idempotency on the combination of workflowId and
   * idempotencyKey. The operation initializes the trigger instance with
   * appropriate defaults to ensure proper processing lifecycle management by
   * workers.
   *
   * Security is restricted to roles authorized to initiate workflow triggers.
   *
   * The function interacts directly with the
   * notification_workflow_trigger_instances table.
   *
   * Upon creation, the trigger is set to 'enqueued' status with cursor pointing
   * to the workflow's entryNodeId, zero attempts, and availability set to
   * current time.
   *
   * If a duplicate request is detected, the existing trigger instance is
   * returned to prevent redundancy.
   *
   * @param connection
   * @param body Information required to create a TriggerInstance
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @TriggerOperatorAuth()
    triggerOperator: TriggerOperatorPayload,
    @TypedBody()
    body: INotificationWorkflowTriggerInstance.ICreate,
  ): Promise<INotificationWorkflowTriggerInstance> {
    try {
      return await postnotificationWorkflowTriggerOperatorTriggerInstances({
        triggerOperator,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List and search trigger instances with filters and pagination.
   *
   * Retrieve a filtered, sorted, and paginated list of trigger instances.
   *
   * Allows trigger operators and system administrators to query the lifecycle
   * state, idempotency keys, cursor position, and status of triggers.
   *
   * Supports pagination, filtering by workflow, status, and availability
   * timestamps.
   *
   * The response provides detailed summary information for each trigger
   * instance matching criteria.
   *
   * Related APIs include trigger creation, updating trigger statuses and logs.
   *
   * @param connection
   * @param body Filter, sort, and pagination options for trigger instances
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async searchTriggerInstances(
    @TriggerOperatorAuth()
    triggerOperator: TriggerOperatorPayload,
    @TypedBody()
    body: INotificationWorkflowTriggerInstance.IRequest,
  ): Promise<IPageINotificationWorkflowTriggerInstance.ISummary> {
    try {
      return await patchnotificationWorkflowTriggerOperatorTriggerInstances({
        triggerOperator,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get detailed information of a specific TriggerInstance by ID.
   *
   * Retrieve a specific TriggerInstance by its unique identifier from the
   * database. This allows users or systems to obtain all available information
   * including current status, cursor position, retry attempts, and payload
   * data.
   *
   * Security is enforced by requiring authorized roles who have permission to
   * view trigger instance data.
   *
   * The operation accesses the notification_workflow_trigger_instances table,
   * ensuring the returned data reflects the current state including workflow
   * association and execution readiness.
   *
   * This API operation provides a critical read-only function supporting
   * trigger monitoring, reporting, and troubleshooting without allowing any
   * modification of data.
   *
   * @param connection
   * @param triggerInstanceId Unique identifier of the target trigger instance
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":triggerInstanceId")
  public async at(
    @TriggerOperatorAuth()
    triggerOperator: TriggerOperatorPayload,
    @TypedParam("triggerInstanceId")
    triggerInstanceId: string & tags.Format<"uuid">,
  ): Promise<INotificationWorkflowTriggerInstance> {
    try {
      return await getnotificationWorkflowTriggerOperatorTriggerInstancesTriggerInstanceId(
        {
          triggerOperator,
          triggerInstanceId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing TriggerInstance by ID.
   *
   * Update specified fields of a TriggerInstance including status, cursor,
   * attempts, availability timing, and payload data. This enables refined
   * control over the trigger execution lifecycle.
   *
   * Access is restricted to authorized users with roles for trigger operation
   * management.
   *
   * The trigger instance identified by the path parameter is updated atomically
   * ensuring data consistency.
   *
   * This operation directly modifies rows in the
   * notification_workflow_trigger_instances database table.
   *
   * @param connection
   * @param triggerInstanceId Unique identifier of the target trigger instance
   *   to update
   * @param body Fields allowed to update in TriggerInstance
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":triggerInstanceId")
  public async update(
    @TriggerOperatorAuth()
    triggerOperator: TriggerOperatorPayload,
    @TypedParam("triggerInstanceId")
    triggerInstanceId: string & tags.Format<"uuid">,
    @TypedBody()
    body: INotificationWorkflowTriggerInstance.IUpdate,
  ): Promise<INotificationWorkflowTriggerInstance> {
    try {
      return await putnotificationWorkflowTriggerOperatorTriggerInstancesTriggerInstanceId(
        {
          triggerOperator,
          triggerInstanceId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete a TriggerInstance by ID permanently.
   *
   * Permanently delete a TriggerInstance from the database by its unique
   * identifier.
   *
   * Security is enforced restricting access to authorized roles.
   *
   * Execution is irreversible and removes all associated trigger instance data.
   *
   * The operation acts directly on the notification_workflow_trigger_instances
   * table to remove the record from the system.
   *
   * @param connection
   * @param triggerInstanceId Unique identifier of the target trigger instance
   *   to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":triggerInstanceId")
  public async erase(
    @TriggerOperatorAuth()
    triggerOperator: TriggerOperatorPayload,
    @TypedParam("triggerInstanceId")
    triggerInstanceId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletenotificationWorkflowTriggerOperatorTriggerInstancesTriggerInstanceId(
        {
          triggerOperator,
          triggerInstanceId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
