[{"id":"019948bf-6f3e-75f4-a0e2-5d050158d371","type":"userMessage","contents":[{"type":"text","text":"Create a simple Mood Diary application where users can log their daily moods (happy, sad, anxious, excited, etc.) with personal notes and timestamps. The app should allow users to view all their mood entries and generate weekly summaries showing how often they experienced each mood type.\n\nInclude these features:\n- Users can add up to 3 mood entries per day\n- Reject entries with future timestamps  \n- Archive entries older than 30 days (exclude from summaries)\n- Generate weekly mood statistics\n- No user authentication required\n- Keep the app simple and user-friendly"}],"created_at":"2025-09-14T15:02:09.470Z"},{"id":"019948bf-738e-75f9-8fc6-6b4773dec71b","type":"assistantMessage","text":"Thank you for describing your requirements for the Mood Diary application. Here’s a summary to confirm your needs and check for any missing details before moving to the next planning step:\n\n## Mood Diary App – Requirements Summary\n\n**Purpose:**  \nAllow users to log their daily moods (e.g., happy, sad, anxious, excited, etc.) with personal notes and timestamps, and view helpful mood statistics.\n\n### Core Features\n\n1. **Mood Logging**\n    - Users can add a new mood entry (mood type + note + timestamp)\n    - Maximum 3 entries per day per user\n    - Reject entries with timestamps set in the future\n\n2. **Viewing Entries**\n    - Users can see a list of all their mood entries\n\n3. **Archiving**\n    - Automatically archive entries older than 30 days (these will not appear in statistics or recent lists)\n\n4. **Weekly Statistics**\n    - App generates a simple summary for the past week (e.g., chart/table showing how often each mood was logged)\n    - Only entries from the past 7 days are considered in the summary\n\n5. **User Simplicity**\n    - No user authentication (all entries are under a single user, i.e., app-wide log, or per-device)\n    - User interface and API (if exposed) should be easy to use\n\n### Please Confirm or Clarify\n\n- Does each mood entry only have: mood type (choose from a few options), optional note, and timestamp?\n- What are the mood types? (e.g., happy, sad, anxious, excited — do you want to specify a fixed list, or should this be flexible?)\n- Should users be able to edit or delete old entries?\n- Is it acceptable that all data is stored without authentication, meaning anyone using the app can see/edit all mood entries?\n- May I assume the app runs online (web/mobile), or will this be used offline/local only? (Determines if you’d need multi-user support in future)\n- Would you like to see each archived entry anywhere (e.g., in a history list), or are they just hidden from all views and stats after 30 days?\n\nOnce you confirm or clarify the above, I can proceed to formalize the detailed specifications and start generating the backend plan.","created_at":"2025-09-14T15:02:10.574Z","completed_at":"2025-09-14T15:02:23.940Z"},{"id":"019948c0-deae-71bf-9ea7-74c4d0fe6570","type":"userMessage","contents":[{"type":"text","text":"Mood Entry Structure: Each mood entry should contain: mood type (from predefined list), optional note (text), and automatic timestamp when created. Mood Types: Use a fixed list of common moods: happy, sad, anxious, excited, angry, calm, stressed, tired. Keep it simple with 8 standard options. Edit/Delete Functionality: No editing or deleting of entries allowed. This keeps data integrity simple and prevents complex validation logic. Authentication/Privacy: No authentication required. Treat it as a single-user app where all entries belong to one user. This is acceptable for the testing scope. Online vs Offline: Design it as a web application that runs online. No need for offline functionality or multi-user support. Archived Entries: Archived entries (older than 30 days) should be completely hidden from all views and not accessible through any interface. They exist only for potential future data export."}],"created_at":"2025-09-14T15:03:43.534Z"},{"type":"analyze","id":"019948c4-1c65-7218-9077-1b716da7d558","reason":"The user has confirmed all features and clarified business logic, mood types, data structure, and constraints (single user, no edit/delete, fixed 8 moods, online web). Ready to generate the structured requirements specification for a simple, single-user Mood Diary app as described.","prefix":"moodDiary","roles":[{"name":"diaryUser","description":"A user of the Mood Diary application who can log up to 3 mood entries per day, add personal notes, view their entries and weekly mood summaries, but cannot edit or delete entries. No registration, all are treated as a single logical user. Role allows full access to mood logging and summary features via API.","kind":"member"}],"files":[{"reason":"To provide an organized reference for the Mood Diary app's backend planning documentation, ensuring all aspects can be found at a glance.","filename":"00-toc.md","documentType":"toc","outline":["Service Vision and Overview","Business Model","User Roles and Permissions","Functional Requirements","User Flows and Scenarios","Business Rules and Validation","Mood Entry Management","Mood Summary Generation","Archiving & Data Retention","Error Handling","Performance & UX Requirements","Security and Privacy Considerations"],"audience":"general","content":"# Functional Requirements for Mood Diary\n\n## Introduction\nThis document provides the comprehensive business requirements, logic, and detailed behaviors necessary for developing the core backend of the Mood Diary web application. It defines _what_ the system must do, not _how_ it is to be implemented. All technical implementation decisions—such as database design, API details, or programming language—are left to the development team. This document is written in accordance with best practices for backend requirement analysis and is intended for immediate use by backend developers.\n\n## 1. Mood Logging\n\n### Mood Entry Structure\n- THE moodDiary entry SHALL consist of the following properties:\n  - mood type (from a fixed set),\n  - optional note (arbitrary text),\n  - automatic timestamp when the entry is created (set by the system, not user-provided).\n- THE mood types SHALL be constrained to the following fixed list:\n  - happy\n  - sad\n  - anxious\n  - excited\n  - angry\n  - calm\n  - stressed\n  - tired\n- THE user SHALL NOT be able to choose any mood type outside this list.\n\n### Entry Creation\n- WHEN a diaryUser triggers creation of a mood entry, THE system SHALL automatically assign the current server-side timestamp (in the user's timezone) as the entry's timestamp.\n- THE system SHALL capture and store the provided optional note; this note MAY be blank.\n\n## 2. Entry Limitation (3 per day)\n- WHEN a diaryUser attempts to create a mood entry, THE system SHALL verify how many entries exist for that logical calendar day (using local date in \"Asia/Calcutta\" timezone).\n- IF there are fewer than 3 mood entries for that day, THEN THE system SHALL allow the new entry.\n- IF the diaryUser has already logged 3 mood entries for the day, THEN THE system SHALL reject further entry attempts for that day, returning an appropriate error message.\n- WHILE counting entries per day, THE system SHALL disregard archived entries (see Archiving Requirements).\n\n## 3. Timestamp Validation (No Future Timestamps)\n- THE system SHALL NOT allow manual entry of timestamps by users.\n- WHEN a mood entry is created, THE system SHALL set the timestamp to the current system/server time using the \"Asia/Calcutta\" timezone.\n- IF for any reason an entry is submitted with a timestamp in the future (after current server time), THEN THE system SHALL reject such an entry with a clear error message.\n- WHILE validating timestamps in all business logic, THE system SHALL use the official server time as authoritative.\n\n## 4. Entry Archiving\n- WHEN a mood entry becomes older than 30 days (calculated from the current server time in the user's timezone), THE system SHALL automatically archive it.\n- IF a mood entry is archived, THEN THE system SHALL ensure it is no longer available via standard retrieval or listing endpoints.\n- Archived entries SHALL BE excluded from all summaries, statistics, and counts in the app.\n- Archived entries SHALL be retained solely for possible future export and SHALL NOT be accessible to the user via the current app frontend or API.\n\n## 5. Weekly Summary Generation\n- THE system SHALL generate a weekly summary of the user's moods displaying, for each mood type, the number of times it was logged in the past 7 calendar days (excluding today).\n- THE weekly summary SHALL exclude archived entries entirely.\n- THE summary SHALL only count entries from the current logical week as per the user's timezone (Asia/Calcutta), mapping each entry to the correct day.\n- The summary SHALL display counts for all 8 mood types, defaulting to zero where there are no entries.\n\n### Weekly Summary Table Example\n| Mood Type | Count This Week |\n|-----------|----------------|\n| happy     | 3              |\n| sad       | 0              |\n| anxious   | 1              |\n| excited   | 5              |\n| angry     | 1              |\n| calm      | 2              |\n| stressed  | 0              |\n| tired     | 4              |\n\n## 6. Business Rules & Validation Logic\n\n### Mood Type Validation\n- IF the submitted mood type is not one of the fixed 8 supported types, THEN THE system SHALL reject the entry with an explicit error.\n\n### Entry Note Handling\n- THE note SHALL be optional and may be blank.\n- THE note SHALL support all Unicode characters and a minimum of 500 characters in length.\n\n### Daily Entry Limit Checking\n- WHEN a new entry is created, THE system SHALL count only non-archived entries when enforcing the 3-per-day maximum.\n\n### Archiving Enforcement\n- THE system SHALL evaluate entry age nightly (or periodically) to move entries greater than 30 days old to an archived state.\n- Archived entries SHALL NOT be visible or accessible via any user-facing API.\n\n### Weekly Summary Validation\n- THE system SHALL only use non-archived entries dated within the current week, and SHALL ignore all others (including archived or future-dated entries).\n\n## 7. Error Handling Expectations\n\n### Exceeding Daily Entry Limit\n- IF a diaryUser attempts to add more than 3 entries in a single day, THEN THE system SHALL return a specific error indicating the daily limit has been reached.\n\n### Invalid Mood Type\n- IF the mood type is not in the fixed list, THEN THE system SHALL return a validation error specifying valid options.\n\n### Future Timestamp Rejection\n- IF any entry has a timestamp that is later than the current server time, THEN THE system SHALL reject it and provide an appropriate error message.\n\n### Access to Archived Data\n- IF a diaryUser attempts to access an archived entry directly (by ID), THEN THE system SHALL return a not found or access denied error.\n\n## 8. Performance and User Experience Requirements\n- THE system SHALL respond to mood entry creation and retrieval requests within 2 seconds under normal load.\n- THE weekly summary generation SHALL produce results within 2 seconds for standard query sizes (7 days, <30 entries).\n- THE archiving process SHALL run as a background job and not impact user experience.\n\n## 9. Illustrative User Scenarios\n\n### Mermaid Flow Chart: Mood Logging and Limitation\n\n```mermaid\ngraph LR\n    A[\"Start Mood Entry Creation\"] --> B[\"Check Today's Entry Count (Non-Archived)\"]\n    B -->|\"Less than 3\"| C[\"Request Mood Type and Optional Note\"]\n    C --> D[\"System Sets Timestamp (Asia/Calcutta)\"]\n    D --> E{\"Is Mood Type in Allowed List?\"}\n    E -->|\"Yes\"| F{\"Is Timestamp > Server Time?\"}\n    F -->|\"No\"| G[\"Create Entry, Show Success\"]\n    F -->|\"Yes\"| H[\"Show Future Timestamp Error\"]\n    E -->|\"No\"| I[\"Show Invalid Mood Error\"]\n    B -->|\"3 or More\"| J[\"Reject: Daily Limit Reached Error\"]\n```\n\n### Mermaid Flow Chart: Weekly Summary Generation\n\n```mermaid\ngraph LR\n    A[\"User Requests Weekly Summary\"] --> B[\"Collect Non-Archived Entries from Last 7 Days\"]\n    B --> C[\"Aggregate by Mood Type and Day\"]\n    C --> D[\"Return Summary Table with Counts\"]\n```\n\n## 10. Success Criteria\n- The system SHALL enforce all entry and summary rules without manual intervention.\n- All error messages SHALL be explicit and actionable for the user.\n- Archived data SHALL be inaccessible through any user or admin interface, except for future data export features.\n- All backend processes SHALL operate within designated performance requirements.\n- EARS format is used for all critical business requirements.\n\n---\n\nThis document defines business requirements only. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team. The document describes WHAT the system should do, not HOW to build it."},{"reason":"To explain the overall mission, goals, and context for the Mood Diary service, including its simple, user-friendly approach and rationale for development.","filename":"01-service-overview.md","documentType":"service-overview","outline":["Service Vision","Target Audience","Core Goals","Key Features","Scope and Limitations"],"audience":"general","content":"# Functional Requirements for Mood Diary\n\n## Introduction\nThis document provides the comprehensive business requirements, logic, and detailed behaviors necessary for developing the core backend of the Mood Diary web application. It defines _what_ the system must do, not _how_ it is to be implemented. All technical implementation decisions—such as database design, API details, or programming language—are left to the development team. This document is written in accordance with best practices for backend requirement analysis and is intended for immediate use by backend developers.\n\n## 1. Mood Logging\n\n### Mood Entry Structure\n- THE moodDiary entry SHALL consist of the following properties:\n  - mood type (from a fixed set),\n  - optional note (arbitrary text),\n  - automatic timestamp when the entry is created (set by the system, not user-provided).\n- THE mood types SHALL be constrained to the following fixed list:\n  - happy\n  - sad\n  - anxious\n  - excited\n  - angry\n  - calm\n  - stressed\n  - tired\n- THE user SHALL NOT be able to choose any mood type outside this list.\n\n### Entry Creation\n- WHEN a diaryUser triggers creation of a mood entry, THE system SHALL automatically assign the current server-side timestamp (in the user's timezone) as the entry's timestamp.\n- THE system SHALL capture and store the provided optional note; this note MAY be blank.\n\n## 2. Entry Limitation (3 per day)\n- WHEN a diaryUser attempts to create a mood entry, THE system SHALL verify how many entries exist for that logical calendar day (using local date in \"Asia/Calcutta\" timezone).\n- IF there are fewer than 3 mood entries for that day, THEN THE system SHALL allow the new entry.\n- IF the diaryUser has already logged 3 mood entries for the day, THEN THE system SHALL reject further entry attempts for that day, returning an appropriate error message.\n- WHILE counting entries per day, THE system SHALL disregard archived entries (see Archiving Requirements).\n\n## 3. Timestamp Validation (No Future Timestamps)\n- THE system SHALL NOT allow manual entry of timestamps by users.\n- WHEN a mood entry is created, THE system SHALL set the timestamp to the current system/server time using the \"Asia/Calcutta\" timezone.\n- IF for any reason an entry is submitted with a timestamp in the future (after current server time), THEN THE system SHALL reject such an entry with a clear error message.\n- WHILE validating timestamps in all business logic, THE system SHALL use the official server time as authoritative.\n\n## 4. Entry Archiving\n- WHEN a mood entry becomes older than 30 days (calculated from the current server time in the user's timezone), THE system SHALL automatically archive it.\n- IF a mood entry is archived, THEN THE system SHALL ensure it is no longer available via standard retrieval or listing endpoints.\n- Archived entries SHALL BE excluded from all summaries, statistics, and counts in the app.\n- Archived entries SHALL be retained solely for possible future export and SHALL NOT be accessible to the user via the current app frontend or API.\n\n## 5. Weekly Summary Generation\n- THE system SHALL generate a weekly summary of the user's moods displaying, for each mood type, the number of times it was logged in the past 7 calendar days (excluding today).\n- THE weekly summary SHALL exclude archived entries entirely.\n- THE summary SHALL only count entries from the current logical week as per the user's timezone (Asia/Calcutta), mapping each entry to the correct day.\n- The summary SHALL display counts for all 8 mood types, defaulting to zero where there are no entries.\n\n### Weekly Summary Table Example\n| Mood Type | Count This Week |\n|-----------|----------------|\n| happy     | 3              |\n| sad       | 0              |\n| anxious   | 1              |\n| excited   | 5              |\n| angry     | 1              |\n| calm      | 2              |\n| stressed  | 0              |\n| tired     | 4              |\n\n## 6. Business Rules & Validation Logic\n\n### Mood Type Validation\n- IF the submitted mood type is not one of the fixed 8 supported types, THEN THE system SHALL reject the entry with an explicit error.\n\n### Entry Note Handling\n- THE note SHALL be optional and may be blank.\n- THE note SHALL support all Unicode characters and a minimum of 500 characters in length.\n\n### Daily Entry Limit Checking\n- WHEN a new entry is created, THE system SHALL count only non-archived entries when enforcing the 3-per-day maximum.\n\n### Archiving Enforcement\n- THE system SHALL evaluate entry age nightly (or periodically) to move entries greater than 30 days old to an archived state.\n- Archived entries SHALL NOT be visible or accessible via any user-facing API.\n\n### Weekly Summary Validation\n- THE system SHALL only use non-archived entries dated within the current week, and SHALL ignore all others (including archived or future-dated entries).\n\n## 7. Error Handling Expectations\n\n### Exceeding Daily Entry Limit\n- IF a diaryUser attempts to add more than 3 entries in a single day, THEN THE system SHALL return a specific error indicating the daily limit has been reached.\n\n### Invalid Mood Type\n- IF the mood type is not in the fixed list, THEN THE system SHALL return a validation error specifying valid options.\n\n### Future Timestamp Rejection\n- IF any entry has a timestamp that is later than the current server time, THEN THE system SHALL reject it and provide an appropriate error message.\n\n### Access to Archived Data\n- IF a diaryUser attempts to access an archived entry directly (by ID), THEN THE system SHALL return a not found or access denied error.\n\n## 8. Performance and User Experience Requirements\n- THE system SHALL respond to mood entry creation and retrieval requests within 2 seconds under normal load.\n- THE weekly summary generation SHALL produce results within 2 seconds for standard query sizes (7 days, <30 entries).\n- THE archiving process SHALL run as a background job and not impact user experience.\n\n## 9. Illustrative User Scenarios\n\n### Mermaid Flow Chart: Mood Logging and Limitation\n\n```mermaid\ngraph LR\n    A[\"Start Mood Entry Creation\"] --> B[\"Check Today's Entry Count (Non-Archived)\"]\n    B -->|\"Less than 3\"| C[\"Request Mood Type and Optional Note\"]\n    C --> D[\"System Sets Timestamp (Asia/Calcutta)\"]\n    D --> E{\"Is Mood Type in Allowed List?\"}\n    E -->|\"Yes\"| F{\"Is Timestamp > Server Time?\"}\n    F -->|\"No\"| G[\"Create Entry, Show Success\"]\n    F -->|\"Yes\"| H[\"Show Future Timestamp Error\"]\n    E -->|\"No\"| I[\"Show Invalid Mood Error\"]\n    B -->|\"3 or More\"| J[\"Reject: Daily Limit Reached Error\"]\n```\n\n### Mermaid Flow Chart: Weekly Summary Generation\n\n```mermaid\ngraph LR\n    A[\"User Requests Weekly Summary\"] --> B[\"Collect Non-Archived Entries from Last 7 Days\"]\n    B --> C[\"Aggregate by Mood Type and Day\"]\n    C --> D[\"Return Summary Table with Counts\"]\n```\n\n## 10. Success Criteria\n- The system SHALL enforce all entry and summary rules without manual intervention.\n- All error messages SHALL be explicit and actionable for the user.\n- Archived data SHALL be inaccessible through any user or admin interface, except for future data export features.\n- All backend processes SHALL operate within designated performance requirements.\n- EARS format is used for all critical business requirements.\n\n---\n\nThis document defines business requirements only. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team. The document describes WHAT the system should do, not HOW to build it."},{"reason":"To clarify the business model and justification for the Mood Diary app, even if non-commercial, including the value provided to users and long-term sustainability ideas.","filename":"02-business-model.md","documentType":"business-model","outline":["Why This Service Exists","Value Proposition","Revenue & Growth Strategies (if applicable)","Success Metrics"],"audience":"general","content":"# Requirement Analysis Report for Mood Diary Application Backend\n\n## Introduction\nThis document outlines the definitive business rules, validation logic, and constraints for the backend of the Mood Diary application. It serves as the authoritative source for all operating logic, ensuring unambiguous implementation and enforcement of application behavior in accordance with business goals and end-user requirements. All rules and requirements are specified using the EARS (Easy Approach to Requirements Syntax) format for clarity and testability.\n\n## Mood Types\n\nThe Mood Diary supports a fixed set of mood types. No custom mood types or additional values are allowed.\n\n**Supported Mood Types:**\n- happy\n- sad\n- anxious\n- excited\n- angry\n- calm\n- stressed\n- tired\n\nEARS Requirement:\n- THE moodDiary system SHALL restrict mood type input to the above list only.\n- IF a submitted mood type is not in the above list, THEN THE moodDiary system SHALL reject the entry with an error message indicating invalid mood type.\n\n## Entry Note Handling\n\nThe diary entry allows for an optional user note. \n\nEARS Requirements:\n- THE moodDiary system SHALL accept entry notes as freeform text fields accompanying each mood entry.\n- THE moodDiary system SHALL allow users to submit entries with or without a note.\n- WHERE a note is provided, THE moodDiary system SHALL limit note length to 500 characters.\n- IF a submitted note exceeds 500 characters, THEN THE moodDiary system SHALL reject the entry with a descriptive error message.\n- THE moodDiary system SHALL permit all Unicode characters in the note field, including emojis and symbols.\n\n## Timestamp Handling\n\nTimestamps are required for every mood entry. They must reflect the creation time and cannot be arbitrarily set by users.\n\nEARS Requirements:\n- WHEN a user submits a mood entry, THE moodDiary system SHALL generate and assign the current server timestamp to the entry.\n- THE moodDiary system SHALL disallow user-supplied timestamps.\n- IF an entry is attempted with a client-side or future timestamp, THEN THE moodDiary system SHALL reject the request with an error indicating that only current server timestamps are allowed.\n- THE moodDiary system SHALL store timestamps using ISO 8601 UTC format.\n\n## Entry Submission Logic\n\nThere are strict limits and requirements for mood entries per calendar day. All logic is enforced per user and per calendar day (midnight to 23:59:59, user’s timezone).\n\nEARS Requirements:\n- THE moodDiary system SHALL limit the number of mood entries to 3 per user per calendar day.\n- WHEN a user submits an entry and already has 3 entries for that day, THE moodDiary system SHALL reject the request with an error explaining the daily entry limit has been reached.\n- WHEN entries are being counted for the daily cap, THE moodDiary system SHALL only consider non-archived entries with server-side timestamps corresponding to the present local day.\n- THE moodDiary system SHALL ensure that successful entries always belong to the chronological calendar day associated with their creation timestamp (user’s local timezone).\n\n## Archiving Logic\n\nMood entries older than 30 days must be archived and excluded from standard user-facing views and summary calculations.\n\nEARS Requirements:\n- WHEN an entry becomes more than 30 full days old (calculated using server date and entry timestamp), THE moodDiary system SHALL mark that entry as archived.\n- THE moodDiary system SHALL exclude archived entries from all usual data views, lists, and summary/statistics generation functions.\n- THE moodDiary system SHALL ensure archived entries are not accessible to users via any current API endpoints except for future explicit data export.\n- THE moodDiary system SHALL provide internal mechanisms for future export of archived entries, while keeping them hidden from normal operation.\n\n## Cross-Section Business Rules\n\n- THE moodDiary system SHALL treat all operations as occurring under a single logical user context, with no authentication or differentiation between users.\n- THE moodDiary system SHALL prevent editing or deleting mood entries after they are created.\n- THE moodDiary system SHALL guarantee all mood entry data (type, note, timestamp) is immutable after creation.\n\n## Error Handling Scenarios\n\n- IF a user attempts to create a mood entry with a non-permitted mood type, THEN THE moodDiary system SHALL return an error clearly stating \"Invalid mood type.\"\n- IF a user submits a note longer than 500 characters, THEN THE moodDiary system SHALL return an error stating \"Note exceeds maximum allowed length.\"\n- IF a user attempts to add an entry after reaching the daily limit, THEN THE moodDiary system SHALL return an error indicating \"Daily mood entry limit reached.\"\n- IF a user attempts to submit a future-dated entry, THEN THE moodDiary system SHALL return an error stating \"Entry timestamp cannot be in the future.\"\n\n## Performance & User Experience Requirements\n\n- THE moodDiary system SHALL respond to all valid entry submissions, summary fetches, and listing requests within 2 seconds under normal load.\n- THE moodDiary system SHALL provide descriptive error messages for all failed validations as per above scenarios.\n\n## Mermaid Diagram: Mood Entry Submission Business Logic\n\n```mermaid\ngraph LR\n    A[\"Submit Mood Entry\"] --> B{\"Is mood type valid?\"}\n    B -->|\"No\"| H[\"Reject: Invalid mood type\"]\n    B -->|\"Yes\"| C{\"Is note <= 500 characters?\"}\n    C -->|\"No\"| I[\"Reject: Note too long\"]\n    C -->|\"Yes\"| D{\"Is daily entry cap reached?\"}\n    D -->|\"Yes\"| J[\"Reject: Daily limit reached\"]\n    D -->|\"No\"| E{\"Is submission in future?\"}\n    E -->|\"Yes\"| K[\"Reject: Future date not allowed\"]\n    E -->|\"No\"| F[\"Create entry with server timestamp\"]\n    F --> G[\"Save entry (immutable)\"]\n```\n\n# END OF DOCUMENT\n"},{"reason":"To define the user roles for the system, especially the single diaryUser role, and outline API access permissions and limitations.","filename":"03-user-roles-and-permissions.md","documentType":"requirement","outline":["Role Definition","Access Rights","Actions Allowed and Denied","Role Limitations"],"audience":"backend developers","content":"# User Roles and Permissions for Mood Diary\n\n## Role Definition\n\nThere is a single user role in the system:\n\n### diaryUser\nThe \"diaryUser\" role represents the only user type in the Mood Diary application. All users interacting with the app are treated as a single logical entity with no authentication, registration, or individual accounts. Actions are performed as a global diary owner on their device/browser (for web application scope), with no role separation or administrative privilege.\n\n## Access Rights\n\nThe \"diaryUser\" role is granted the following permissions:\n\n- Add a new mood entry (up to 3 per calendar day)\n- View the complete list of their mood entries (excluding archived ones)\n- View weekly mood summaries/statistics for the past week (excluding archived entries)\n\nThe \"diaryUser\" has unrestricted access to all functional features that do not violate business rules (e.g. entry limit, archiving rules). There are no permissions for editing or deleting existing data.\n\n## Actions Allowed and Denied\n\nThe following table outlines which actions the diaryUser is allowed or denied:\n\n| Action                                   | Allowed | Denied |\n|------------------------------------------|:-------:|:------:|\n| Add mood entry (if under daily limit)     |   ✅    |        |\n| Add mood entry (over daily limit)         |         |   ❌   |\n| Add mood entry with future timestamp      |         |   ❌   |\n| View mood entries (not archived)          |   ✅    |        |\n| View archived mood entries                |         |   ❌   |\n| View weekly mood summary                  |   ✅    |        |\n| Edit any mood entry                       |         |   ❌   |\n| Delete any mood entry                     |         |   ❌   |\n| Manage users/roles (admin features)       |         |   ❌   |\n| Access underlying database or logs        |         |   ❌   |\n\n## Role Limitations\n\n- Only one logical user exists; all data is stored and retrieved as the system's single diary user.\n- No authentication or user switching is supported; every feature is globally accessible.\n- The user is never allowed to edit or delete existing mood entries; all entries are immutable after creation.\n- The user is limited to three (3) new mood entries per calendar day. Attempts to add more are rejected.\n- The user cannot add mood entries with a future timestamp. Such requests are always rejected.\n- Entries older than 30 days are automatically archived; they are inaccessible and excluded from all lists and summaries.\n- Archived entries are only retained for backend export and are otherwise invisible and inaccessible through the UI or API.\n\n## Formal Requirements (EARS Format)\n\n- THE diaryUser SHALL be able to add a mood entry IF the number of entries for the calendar day is less than 3.\n- THE diaryUser SHALL NOT be able to add a mood entry IF the current day's entry limit has been reached.\n- IF a mood entry is submitted with a timestamp in the future, THEN THE system SHALL reject it and provide an appropriate error message.\n- THE diaryUser SHALL be able to view only their non-archived mood entries (entries from the last 30 days).\n- THE diaryUser SHALL be able to view a summary of mood types for the past week.\n- THE diaryUser SHALL NOT be able to edit any mood entry after submission.\n- THE diaryUser SHALL NOT be able to delete any mood entry after submission.\n- THE diaryUser SHALL have no access to features beyond adding/viewing entries and viewing summaries (e.g., no admin, export, or system management features through the main UI/API).\n\n## Permissions Matrix (Summary)\n\n| Feature                       | diaryUser |\n|-------------------------------|:---------:|\n| Add mood entry                |    ✅     |\n| View mood entries             |    ✅     |\n| View weekly mood summary      |    ✅     |\n| Edit/delete mood entry        |    ❌     |\n| View archived mood entries    |    ❌     |\n| User management               |    ❌     |\n\n## Sequence Diagram (Mermaid)\n\n```mermaid\nsequenceDiagram\n    participant U as \"Diary User\"\n    participant S as \"System\"\n    U->>S: Add mood entry\n    alt Under daily limit and valid timestamp\n        S-->>U: Store entry, success response\n    else Over daily limit or future timestamp\n        S-->>U: Reject entry, error response\n    end\n    U->>S: View mood entries\n    S-->>U: Return non-archived entries\n    U->>S: View weekly summary\n    S-->>U: Return stats for past week (excluding archived)\n```\n\n## Edge Case Handling\n\nWHEN a diaryUser attempts to:\n- Add more than 3 entries in one day, THE system SHALL reject the action and show a clear error message.\n- Add an entry with a future timestamp, THE system SHALL reject the action and show a relevant error message.\n- View archived entries or request summaries for older dates, THE system SHALL return no results and present no access to such data.\n- Edit or delete any mood entry, THE system SHALL deny the request and show an appropriate error response.\n\n## Performance Requirements\n- THE diaryUser SHALL receive confirmation or error response within 2 seconds for all add, list, and summary actions, under normal operating circumstances.\n\n---\n\nFor detailed functional requirements, please see the [Functional Requirements for Mood Diary](./04-functional-requirements.md).\nBusiness validation logic is described in the [Business Rules and Validation](./06-business-rules-and-validation.md).\nMood entry management details can be found in the [Mood Entry Management Specifications](./07-mood-entry-management.md).\n"},{"reason":"To specify all core functional requirements for logging moods, weekly summaries, entry management, and statistics generation in the Mood Diary.","filename":"04-functional-requirements.md","documentType":"requirement","outline":["Mood Logging","Entry Limitation (3 per day)","Timestamp Validation","Entry Archiving","Weekly Summary Generation"],"audience":"backend developers","content":"# Functional Requirements for Mood Diary\n\n## Introduction\nThis document provides the comprehensive business requirements, logic, and detailed behaviors necessary for developing the core backend of the Mood Diary web application. It defines _what_ the system must do, not _how_ it is to be implemented. All technical implementation decisions—such as database design, API details, or programming language—are left to the development team. This document is written in accordance with best practices for backend requirement analysis and is intended for immediate use by backend developers.\n\n## 1. Mood Logging\n\n### Mood Entry Structure\n- THE moodDiary entry SHALL consist of the following properties:\n  - mood type (from a fixed set),\n  - optional note (arbitrary text),\n  - automatic timestamp when the entry is created (set by the system, not user-provided).\n- THE mood types SHALL be constrained to the following fixed list:\n  - happy\n  - sad\n  - anxious\n  - excited\n  - angry\n  - calm\n  - stressed\n  - tired\n- THE user SHALL NOT be able to choose any mood type outside this list.\n\n### Entry Creation\n- WHEN a diaryUser triggers creation of a mood entry, THE system SHALL automatically assign the current server-side timestamp (in the user's timezone) as the entry's timestamp.\n- THE system SHALL capture and store the provided optional note; this note MAY be blank.\n\n## 2. Entry Limitation (3 per day)\n- WHEN a diaryUser attempts to create a mood entry, THE system SHALL verify how many entries exist for that logical calendar day (using local date in \"Asia/Calcutta\" timezone).\n- IF there are fewer than 3 mood entries for that day, THEN THE system SHALL allow the new entry.\n- IF the diaryUser has already logged 3 mood entries for the day, THEN THE system SHALL reject further entry attempts for that day, returning an appropriate error message.\n- WHILE counting entries per day, THE system SHALL disregard archived entries (see Archiving Requirements).\n\n## 3. Timestamp Validation (No Future Timestamps)\n- THE system SHALL NOT allow manual entry of timestamps by users.\n- WHEN a mood entry is created, THE system SHALL set the timestamp to the current system/server time using the \"Asia/Calcutta\" timezone.\n- IF for any reason an entry is submitted with a timestamp in the future (after current server time), THEN THE system SHALL reject such an entry with a clear error message.\n- WHILE validating timestamps in all business logic, THE system SHALL use the official server time as authoritative.\n\n## 4. Entry Archiving\n- WHEN a mood entry becomes older than 30 days (calculated from the current server time in the user's timezone), THE system SHALL automatically archive it.\n- IF a mood entry is archived, THEN THE system SHALL ensure it is no longer available via standard retrieval or listing endpoints.\n- Archived entries SHALL BE excluded from all summaries, statistics, and counts in the app.\n- Archived entries SHALL be retained solely for possible future export and SHALL NOT be accessible to the user via the current app frontend or API.\n\n## 5. Weekly Summary Generation\n- THE system SHALL generate a weekly summary of the user's moods displaying, for each mood type, the number of times it was logged in the past 7 calendar days (excluding today).\n- THE weekly summary SHALL exclude archived entries entirely.\n- THE summary SHALL only count entries from the current logical week as per the user's timezone (Asia/Calcutta), mapping each entry to the correct day.\n- The summary SHALL display counts for all 8 mood types, defaulting to zero where there are no entries.\n\n### Weekly Summary Table Example\n| Mood Type | Count This Week |\n|-----------|----------------|\n| happy     | 3              |\n| sad       | 0              |\n| anxious   | 1              |\n| excited   | 5              |\n| angry     | 1              |\n| calm      | 2              |\n| stressed  | 0              |\n| tired     | 4              |\n\n## 6. Business Rules & Validation Logic\n\n### Mood Type Validation\n- IF the submitted mood type is not one of the fixed 8 supported types, THEN THE system SHALL reject the entry with an explicit error.\n\n### Entry Note Handling\n- THE note SHALL be optional and may be blank.\n- THE note SHALL support all Unicode characters and a minimum of 500 characters in length.\n\n### Daily Entry Limit Checking\n- WHEN a new entry is created, THE system SHALL count only non-archived entries when enforcing the 3-per-day maximum.\n\n### Archiving Enforcement\n- THE system SHALL evaluate entry age nightly (or periodically) to move entries greater than 30 days old to an archived state.\n- Archived entries SHALL NOT be visible or accessible via any user-facing API.\n\n### Weekly Summary Validation\n- THE system SHALL only use non-archived entries dated within the current week, and SHALL ignore all others (including archived or future-dated entries).\n\n## 7. Error Handling Expectations\n\n### Exceeding Daily Entry Limit\n- IF a diaryUser attempts to add more than 3 entries in a single day, THEN THE system SHALL return a specific error indicating the daily limit has been reached.\n\n### Invalid Mood Type\n- IF the mood type is not in the fixed list, THEN THE system SHALL return a validation error specifying valid options.\n\n### Future Timestamp Rejection\n- IF any entry has a timestamp that is later than the current server time, THEN THE system SHALL reject it and provide an appropriate error message.\n\n### Access to Archived Data\n- IF a diaryUser attempts to access an archived entry directly (by ID), THEN THE system SHALL return a not found or access denied error.\n\n## 8. Performance and User Experience Requirements\n- THE system SHALL respond to mood entry creation and retrieval requests within 2 seconds under normal load.\n- THE weekly summary generation SHALL produce results within 2 seconds for standard query sizes (7 days, <30 entries).\n- THE archiving process SHALL run as a background job and not impact user experience.\n\n## 9. Illustrative User Scenarios\n\n### Mermaid Flow Chart: Mood Logging and Limitation\n\n```mermaid\ngraph LR\n    A[\"Start Mood Entry Creation\"] --> B[\"Check Today's Entry Count (Non-Archived)\"]\n    B -->|\"Less than 3\"| C[\"Request Mood Type and Optional Note\"]\n    C --> D[\"System Sets Timestamp (Asia/Calcutta)\"]\n    D --> E{\"Is Mood Type in Allowed List?\"}\n    E -->|\"Yes\"| F{\"Is Timestamp > Server Time?\"}\n    F -->|\"No\"| G[\"Create Entry, Show Success\"]\n    F -->|\"Yes\"| H[\"Show Future Timestamp Error\"]\n    E -->|\"No\"| I[\"Show Invalid Mood Error\"]\n    B -->|\"3 or More\"| J[\"Reject: Daily Limit Reached Error\"]\n```\n\n### Mermaid Flow Chart: Weekly Summary Generation\n\n```mermaid\ngraph LR\n    A[\"User Requests Weekly Summary\"] --> B[\"Collect Non-Archived Entries from Last 7 Days\"]\n    B --> C[\"Aggregate by Mood Type and Day\"]\n    C --> D[\"Return Summary Table with Counts\"]\n```\n\n## 10. Success Criteria\n- The system SHALL enforce all entry and summary rules without manual intervention.\n- All error messages SHALL be explicit and actionable for the user.\n- Archived data SHALL be inaccessible through any user or admin interface, except for future data export features.\n- All backend processes SHALL operate within designated performance requirements.\n- EARS format is used for all critical business requirements.\n\n---\n\nThis document defines business requirements only. All technical implementations (architecture, APIs, database design, etc.) are at the discretion of the development team. The document describes WHAT the system should do, not HOW to build it."},{"reason":"To describe the user journey through the app, step-by-step, for mood entry, review, weekly summaries, and archiving behaviors.","filename":"05-user-flows-and-scenarios.md","documentType":"user-flow","outline":["Adding an Entry","Rejected Entry Cases","Weekly Summary View","Archived Entries Lifecycle"],"audience":"backend developers","content":"# User Flows and Scenarios for Mood Diary Application\n\n## Introduction\nThis document describes in detail the user flows and business scenarios for the Mood Diary application. It is designed for backend developers who need an unambiguous, comprehensive understanding of how users interact with the system and how the system must respond according to business rules and requirements. All requirements leverage EARS (Easy Approach to Requirements Syntax) methodology for clarity.\n\n---\n\n## 1. Adding an Entry\n\n### Standard Flow\n- User accesses the app and is presented with the option to add a new mood entry.\n- User selects a mood from the fixed list: happy, sad, anxious, excited, angry, calm, stressed, tired.\n- User optionally writes a personal note (plain text, no length restriction unless otherwise stated by business rules).\n- User submits the entry. The system records an automatic timestamp reflecting the exact time of receipt (according to server clock).\n\n#### EARS Requirements\n- WHEN a user submits a new mood entry, THE system SHALL record the mood type, note, and current timestamp.\n- THE system SHALL allow a maximum of 3 mood entries per calendar day.\n- THE system SHALL assign a timestamp to each entry based on server receipt time.\n\n#### Flow Example (Standard Add)\n```mermaid\ngraph LR\n  A[\"User opens app\"] --> B[\"Selects mood type\"]\n  B --> C[\"Adds optional note\"]\n  C --> D[\"Submits entry\"]\n  D --> E[\"System validates count and timestamp\"]\n  E --> F[\"Entry accepted and saved\"]\n```\n\n### Post-Submission\n- The user is returned either a success response or a detailed error in case the entry is rejected (see next section).\n- Accepted entries are immediately visible in the user's current list.\n\n---\n\n## 2. Rejected Entry Cases\n\n### Rejection on Entry Limit\n- WHEN a user submits a mood entry and 3 entries for that day already exist, THE system SHALL reject the new entry and return an error indicating the daily limit has been reached.\n\n### Rejection on Future Timestamp\n- WHEN a user attempts to submit a mood entry containing a timestamp set in the future (any time after the current server time), THE system SHALL reject the entry and return an error stating that future timestamps are not allowed.\n\n#### Other Rejections\n- IF any submission does not specify one of the 8 standard mood types, THEN THE system SHALL reject the entry and return an error describing the required mood standards.\n- IF the note field is not valid text (e.g., binary, injection attempt), THEN THE system SHALL reject the entry and inform the user.\n\n#### EARS Summary Table\n| Scenario                                 | Action                                                               |\n|------------------------------------------|---------------------------------------------------------------------|\n| More than 3 entries today                | Reject; return daily limit error                                    |\n| Timestamp is in the future               | Reject; return future timestamp error                               |\n| Invalid mood type not in standard set    | Reject; return mood type error                                      |\n| Note field invalid                       | Reject; return note field error                                     |\n\n#### Flow Example (Rejection)\n```mermaid\ngraph LR\n  A[\"User attempts entry\"] --> B[\"System checks count and timestamp\"]\n  B -->|\"Entry count exceeded\"| C[\"Reject: Daily limit error\"]\n  B -->|\"Future timestamp\"| D[\"Reject: Future timestamp error\"]\n  B -->|\"Invalid mood/note\"| E[\"Reject: Validation error\"]\n```\n\n---\n\n## 3. Weekly Summary View\n\n### Overview\n- User accesses the summary section to see mood statistics for the past week.\n- The system aggregates all mood entries from the last 7 calendar days, excluding entries that have been archived (older than 30 days).\n- The statistics display how many times each of the 8 mood types was recorded during the week.\n\n#### EARS Requirements\n- WHEN a user requests the weekly summary, THE system SHALL aggregate all non-archived entries from the past 7 days.\n- THE system SHALL count and display the frequency for each mood type individually.\n- IF no entries exist for a given week, THEN THE system SHALL display a zero count for each mood type.\n\n#### Flow Example (Weekly Summary Generation)\n```mermaid\ngraph LR\n  A[\"User requests weekly summary\"] --> B[\"System retrieves entries (last 7 days, not archived)\"]\n  B --> C[\"System tallies moods by type\"]\n  C --> D[\"Summary with counts per mood type is returned\"]\n```\n\n### Example Output Table\n| Mood Type | Logged Count |\n|-----------|--------------|\n| Happy     | 5            |\n| Sad       | 2            |\n| Anxious   | 1            |\n| Excited   | 4            |\n| Angry     | 0            |\n| Calm      | 3            |\n| Stressed  | 0            |\n| Tired     | 2            |\n\n---\n\n## 4. Archived Entries Lifecycle\n\n### Timeline and Transition\n- WHEN a mood entry becomes older than 30 days from its creation timestamp, THE system SHALL mark the entry as archived.\n- Archived entries SHALL be excluded from all current views, listings, and statistic calculations.\n- Entries that are archived SHALL not be visible to the user in any interface and do not contribute to weekly summaries.\n- The system SHALL retain archived entries solely for the purposes of potential future data export (not accessible through standard app features).\n\n#### EARS Requirements\n- WHEN an entry reaches 30 days of age, THE system SHALL remove it from active listings and summaries.\n- THE system SHALL not allow users to access, edit, or delete archived entries.\n\n#### Flow Example (Archiving)\n```mermaid\ngraph LR\n  A[\"Entry created\"] --> B[\"Entry ages\"]\n  B -->|\"30 days pass\"| C[\"System archives the entry\"]\n  C --> D[\"Entry hidden from user and stats\"]\n```\n\n---\n\n## Notes on User Experience and Data Integrity\n- Editing or deleting mood entries is not permitted under business rules; all logged entries are immutable once accepted.\n- All users are treated as a single logical user; privacy and authentication are not implemented in this version.\n- The system is expected to respond to user actions with clear outcomes (success or error) within 2 seconds of submission for an optimal experience.\n- All data validation, archiving checks, and error messaging are governed by backend business rules outlined here and in related requirement documents.\n\n---\n\n## Summary\nThis document provides all necessary user flows and scenario specifications for backend implementation of the Mood Diary application's logging, validation, summary, and archiving features. For technical and business logic details, see also:\n- [Functional Requirements Document](./04-functional-requirements.md)\n- [Business Rules and Validation](./06-business-rules-and-validation.md)\n- [Mood Entry Management](./07-mood-entry-management.md)\n- [Mood Summary Generation](./08-mood-summary-generation.md)\n- [Archiving and Data Retention](./09-archiving-and-data-retention.md)\n"},{"reason":"To consolidate all key business logic, data validation rules, and constraints clearly for backend enforcement, ensuring unambiguous system behavior.","filename":"06-business-rules-and-validation.md","documentType":"requirement","outline":["Mood Types","Entry Note Handling","Timestamp Handling","Entry Submission Logic","Archiving Logic"],"audience":"backend developers","content":"# Requirement Analysis Report for Mood Diary Application Backend\n\n## Introduction\nThis document outlines the definitive business rules, validation logic, and constraints for the backend of the Mood Diary application. It serves as the authoritative source for all operating logic, ensuring unambiguous implementation and enforcement of application behavior in accordance with business goals and end-user requirements. All rules and requirements are specified using the EARS (Easy Approach to Requirements Syntax) format for clarity and testability.\n\n## Mood Types\n\nThe Mood Diary supports a fixed set of mood types. No custom mood types or additional values are allowed.\n\n**Supported Mood Types:**\n- happy\n- sad\n- anxious\n- excited\n- angry\n- calm\n- stressed\n- tired\n\nEARS Requirement:\n- THE moodDiary system SHALL restrict mood type input to the above list only.\n- IF a submitted mood type is not in the above list, THEN THE moodDiary system SHALL reject the entry with an error message indicating invalid mood type.\n\n## Entry Note Handling\n\nThe diary entry allows for an optional user note. \n\nEARS Requirements:\n- THE moodDiary system SHALL accept entry notes as freeform text fields accompanying each mood entry.\n- THE moodDiary system SHALL allow users to submit entries with or without a note.\n- WHERE a note is provided, THE moodDiary system SHALL limit note length to 500 characters.\n- IF a submitted note exceeds 500 characters, THEN THE moodDiary system SHALL reject the entry with a descriptive error message.\n- THE moodDiary system SHALL permit all Unicode characters in the note field, including emojis and symbols.\n\n## Timestamp Handling\n\nTimestamps are required for every mood entry. They must reflect the creation time and cannot be arbitrarily set by users.\n\nEARS Requirements:\n- WHEN a user submits a mood entry, THE moodDiary system SHALL generate and assign the current server timestamp to the entry.\n- THE moodDiary system SHALL disallow user-supplied timestamps.\n- IF an entry is attempted with a client-side or future timestamp, THEN THE moodDiary system SHALL reject the request with an error indicating that only current server timestamps are allowed.\n- THE moodDiary system SHALL store timestamps using ISO 8601 UTC format.\n\n## Entry Submission Logic\n\nThere are strict limits and requirements for mood entries per calendar day. All logic is enforced per user and per calendar day (midnight to 23:59:59, user’s timezone).\n\nEARS Requirements:\n- THE moodDiary system SHALL limit the number of mood entries to 3 per user per calendar day.\n- WHEN a user submits an entry and already has 3 entries for that day, THE moodDiary system SHALL reject the request with an error explaining the daily entry limit has been reached.\n- WHEN entries are being counted for the daily cap, THE moodDiary system SHALL only consider non-archived entries with server-side timestamps corresponding to the present local day.\n- THE moodDiary system SHALL ensure that successful entries always belong to the chronological calendar day associated with their creation timestamp (user’s local timezone).\n\n## Archiving Logic\n\nMood entries older than 30 days must be archived and excluded from standard user-facing views and summary calculations.\n\nEARS Requirements:\n- WHEN an entry becomes more than 30 full days old (calculated using server date and entry timestamp), THE moodDiary system SHALL mark that entry as archived.\n- THE moodDiary system SHALL exclude archived entries from all usual data views, lists, and summary/statistics generation functions.\n- THE moodDiary system SHALL ensure archived entries are not accessible to users via any current API endpoints except for future explicit data export.\n- THE moodDiary system SHALL provide internal mechanisms for future export of archived entries, while keeping them hidden from normal operation.\n\n## Cross-Section Business Rules\n\n- THE moodDiary system SHALL treat all operations as occurring under a single logical user context, with no authentication or differentiation between users.\n- THE moodDiary system SHALL prevent editing or deleting mood entries after they are created.\n- THE moodDiary system SHALL guarantee all mood entry data (type, note, timestamp) is immutable after creation.\n\n## Error Handling Scenarios\n\n- IF a user attempts to create a mood entry with a non-permitted mood type, THEN THE moodDiary system SHALL return an error clearly stating \"Invalid mood type.\"\n- IF a user submits a note longer than 500 characters, THEN THE moodDiary system SHALL return an error stating \"Note exceeds maximum allowed length.\"\n- IF a user attempts to add an entry after reaching the daily limit, THEN THE moodDiary system SHALL return an error indicating \"Daily mood entry limit reached.\"\n- IF a user attempts to submit a future-dated entry, THEN THE moodDiary system SHALL return an error stating \"Entry timestamp cannot be in the future.\"\n\n## Performance & User Experience Requirements\n\n- THE moodDiary system SHALL respond to all valid entry submissions, summary fetches, and listing requests within 2 seconds under normal load.\n- THE moodDiary system SHALL provide descriptive error messages for all failed validations as per above scenarios.\n\n## Mermaid Diagram: Mood Entry Submission Business Logic\n\n```mermaid\ngraph LR\n    A[\"Submit Mood Entry\"] --> B{\"Is mood type valid?\"}\n    B -->|\"No\"| H[\"Reject: Invalid mood type\"]\n    B -->|\"Yes\"| C{\"Is note <= 500 characters?\"}\n    C -->|\"No\"| I[\"Reject: Note too long\"]\n    C -->|\"Yes\"| D{\"Is daily entry cap reached?\"}\n    D -->|\"Yes\"| J[\"Reject: Daily limit reached\"]\n    D -->|\"No\"| E{\"Is submission in future?\"}\n    E -->|\"Yes\"| K[\"Reject: Future date not allowed\"]\n    E -->|\"No\"| F[\"Create entry with server timestamp\"]\n    F --> G[\"Save entry (immutable)\"]\n```\n\n# END OF DOCUMENT\n"},{"reason":"To dive deeper into how mood entry creation, retrieval, weekly stat generation, and archiving operate, including sequence and process requirements.","filename":"07-mood-entry-management.md","documentType":"requirement","outline":["Entry Creation","Entry Listing","Entry Limitation Enforcement","Entry Archiving Process"],"audience":"backend developers","content":"# Mood Diary Application – Mood Entry Management Requirements\n\n## Introduction\nThis document provides complete business logic and process requirements for the core mood entry management of the Mood Diary web application. It is aimed at backend developers, describing exactly how entries are to be handled, listed, constrained, and archived according to business rules, with all requirements presented in clear, testable EARS format.\n\n### Context\nThe Mood Diary app provides a simple, single-user experience for daily mood journaling and self-tracking. Each entry records a mood type (from a standard set), an optional note, and a timestamp (automatically generated at creation). Users may add up to 3 entries per day. No editing or deleting is permitted. Entries older than 30 days are archived and hidden. Weekly mood statistics are calculated only from non-archived entries. No authentication or privacy segregation exists: all data is managed under a single logical user.\n\n## Entry Creation\n### Entry Structure\n- THE \"mood entry\" SHALL consist of:\n    - A mood type selected from a fixed set: happy, sad, anxious, excited, angry, calm, stressed, tired.\n    - An optional user note (string, max 1,000 characters recommended for usability).\n    - An automatic timestamp in ISO 8601 format, recorded precisely at the time of creation by the backend (user-provided timestamps are disallowed).\n\n| Field      | Type   | Description                                  |\n|------------|--------|----------------------------------------------|\n| moodType   | enum   | One of the 8 fixed moods                     |\n| note       | string | Optional, up to 1,000 characters             |\n| timestamp  | string | ISO 8601 datetime, generated by system       |\n\n### Creation Process and Validation\n- THE backend SHALL generate the creation timestamp at the precise moment the mood entry is accepted and saved.\n- WHEN a mood entry is submitted, THE system SHALL verify all fields meet structural and business rules before saving.\n- IF the submission is missing the mood type, THEN THE system SHALL reject the entry with an appropriate error.\n- IF the user-provided note exceeds 1,000 characters, THEN THE system SHALL reject the entry with an appropriate error.\n- IF an attempt is made to set the timestamp manually, THEN THE system SHALL ignore the value and use system time.\n- IF the user attempts to select a mood type not in the fixed set, THEN THE system SHALL reject the entry with an appropriate error.\n- IF the entry is being submitted for a date in the future, THEN THE system SHALL reject the entry with an appropriate error message.\n\n## Entry Listing\n- THE system SHALL provide a way to list all non-archived mood entries in time order, newest first.\n- WHEN displaying or exporting entries, THE system SHALL omit all archived (older than 30 days) entries.\n- THE returned list SHALL include: mood type, note, timestamp for each mood entry.\n- THE list of entries SHALL be limited to entries made in the past 30 days, ordered from most recent to oldest.\n\n## Entry Limitation Enforcement\n- THE system SHALL restrict mood entries to a maximum of 3 per day (local calendar day).\n- WHEN a user attempts to submit a fourth entry on the same day, THE system SHALL reject the request, presenting an error that the daily limit has been reached.\n- THE counting of entries per day SHALL be based on the date portion (as per Asia/Calcutta timezone) of each entry's system-generated timestamp.\n- WHEN counting entries, THE system SHALL consider only non-archived entries.\n\n## Entry Archiving Process\n- THE system SHALL automatically archive mood entries older than 30 days (calculated from their timestamp relative to the current date in Asia/Calcutta timezone).\n- WHEN an entry becomes archived, THE system SHALL exclude it from listing, weekly summaries, and all user-facing statistics.\n- Archived entries SHALL be retained in storage for possible future export but SHALL NOT be accessible or visible via the normal user interface or API for listing or statistics.\n\n## Process Flow Diagrams\n\n### Mood Entry Lifecycle (Creation to Archiving)\n```mermaid\ngraph LR\n  A[\"User Submits Mood Entry (via UI)\"] --> B[\"Validate: Mood Type in Fixed Set?\"]\n  B -->|\"Yes\"| C[\"Validate: Note Length <= 1,000?\"]\n  B -->|\"No\"| G[\"Reject: Invalid Mood Type\"]\n  C -->|\"Yes\"| D[\"Validate: Daily Entry Limit Not Exceeded?\"]\n  C -->|\"No\"| H[\"Reject: Note too long\"]\n  D -->|\"Yes\"| E[\"Generate Timestamp (System Time)\"]\n  D -->|\"No\"| I[\"Reject: Exceeds 3 entries/day\"]\n  E --> F[\"Store Entry\"]\n  F --> J[\"Entry Appears In Listings\"]\n  J --> K[\"Entry Age Passes 30 Days\"]\n  K --> L[\"Archive Entry (Hidden from user & statistics)\"]\n```\n\n## Compliance with Business Rules\n- THE system SHALL not allow any editing or deletion of previously created entries.\n- WHEN retrieving, summarizing, or exporting mood data, THE system SHALL always operate on non-archived entries only, unless explicit export/archive access logic is required (future extension).\n- All business rules defined in [Business Rules and Validation Requirements](./06-business-rules-and-validation.md) and [Archiving and Data Retention](./09-archiving-and-data-retention.md) SHALL be fully enforced.\n\n## Summary Table: Allowed Operations\n\n| Operation         | Requirement |\n|-------------------|-------------|\n| Add Entry         | Up to 3/day, must use fixed mood type, system timestamp, note optional |\n| List Entries      | Only non-archived entries (last 30 days), ordered by newest |\n| Archive Old Entry | Older than 30 days; hidden from all user access and stats |\n| Edit/Delete       | Not permitted |\n\n## Error and Constraint Scenarios\n- IF a mood entry is submitted with a future timestamp, invalid mood type, missing required field, or if the daily entry limit is exceeded, THEN THE system SHALL return a clear error message specifying the failing condition.\n- IF a request is made for archived or out-of-date entries, THEN THE system SHALL return an empty list or a relevant error (as per API design), confirming visibility rules.\n\n## Locale, Timezone, and Date Handling\n- THE system SHALL enforce business rules based on the Asia/Calcutta timezone.\n- All date and time calculations (for entry counts, archiving, etc.) SHALL use the local calendar day definitions per this timezone.\n\n## Performance Requirements\n- WHEN creating or listing entries, THE system SHALL respond within 2 seconds for all typical operations (under 1,000 entries in 30-day list).\n\n---\nThis document provides the exhaustive business logic and requirement analysis for mood entry management in the Mood Diary application. All technical implementation, API, and storage decisions are at the sole discretion of the backend development team."},{"reason":"To provide comprehensive, non-technical requirements and logic for generating weekly summaries and handling statistics over mood types.","filename":"08-mood-summary-generation.md","documentType":"requirement","outline":["Summary Time Window","Mood Type Counting","Exclusion of Archived Entries","Display Requirements"],"audience":"backend developers","content":"# Mood Diary: Weekly Mood Summary Generation Requirements\n\n## 1. Introduction\nThis requirements document provides a thorough description of the business rules, logic, and output standards for generating weekly mood summaries and statistics within the Mood Diary service. The scope includes time window selection, mood counting, handling of archived records, and user-facing output requirements. The requirements are written exclusively in business terms and use EARS (Easy Approach to Requirements Syntax) wherever possible.\n\n## 2. Weekly Summary Time Window\n- THE summary SHALL represent data for exactly the most recent 7-day period, inclusive of today (based on system/application timezone, or user's local time if timezone support is added). The time zone standard SHALL be consistent across all summary calculations (default: server or application timezone, \"Asia/Calcutta\").\n- WHEN a user requests the weekly summary, THE system SHALL aggregate entries from the 7-day window ending on the current day (00:00:00 to 23:59:59 of each day within that window).\n- IF the current day contains no entries, THEN THE system SHALL still include that day as part of the 7-day window with a count of zero entries.\n- WHEN no mood entries exist for the current 7-day period, THE system SHALL return a summary with zero counts for every mood type.\n\n## 3. Mood Type Counting Logic\n- THE system SHALL count occurrences of each mood type per entry within the weekly window. The recognized mood types are:\n    1. happy\n    2. sad\n    3. anxious\n    4. excited\n    5. angry\n    6. calm\n    7. stressed\n    8. tired\n- WHEN a summary is generated, THE system SHALL calculate the total number of entries for each mood type across the 7-day window.\n- WHERE multiple entries occur on a single day, THE system SHALL include all valid entries (up to maximum 3 per day; see business rules in [Business Rules and Validation Documentation](./06-business-rules-and-validation.md)).\n- WHEN summarizing moods, THE system SHALL use only the mood type from each entry for counting statistics; notes are not included in summary metrics.\n\n## 4. Exclusion of Archived Entries\n- WHEN generating weekly summaries, THE system SHALL exclude all entries with timestamps older than 30 days from the time of summary generation.\n- WHEN an entry becomes older than 30 days, THE system SHALL immediately cease including it in any summaries or mood counts.\n- IF the 7-day window partially overlaps the 30-day archive threshold, THEN THE system SHALL only consider non-archived entries within the valid window; older entries SHALL not be counted for any day.\n\n## 5. Display and Output Requirements\n- WHEN the weekly mood summary is requested, THE system SHALL return for each of the 8 standard mood types:\n    - Mood type (enumerated value, see above)\n    - Total count for the week\n    - Count per day (array or structure with counts indexed by each day within the 7-day window, in chronological order)\n- WHERE no entries exist for a given mood type, THE system SHALL report zero for that mood type.\n- THE summary SHALL clearly indicate the date range (start and end ISO dates) used for the aggregation.\n- THE summary output SHALL NEVER include any data about archived entries.\n- IF entries for a particular day are missing, THEN THE daily mood counts for that day SHALL be zero for all mood types.\n\n### Output Structure (Business Rules Only, Not Technical Schema)\n- List of 8 mood types (labels: happy, sad, anxious, excited, angry, calm, stressed, tired)\n- For each mood type: total count this week, array of 7 daily counts (beginning of week to today)\n- Date range shown as ISO start date and end date\n\n## 6. Edge Cases & Error Handling\n- IF less than 7 unarchived days exist before today, THEN THE system SHALL use as many days as possible up to 7 (e.g., if database only has data for the most recent 3 days, summary covers those 3 days plus today, remainder of days are counted as zeros).\n- IF no valid mood data exists in the specified 7-day window, THEN THE system SHALL produce a summary response showing all mood types with weekly and daily counts of zero.\n- IF errors occur during summary generation (e.g., no entries in database, internal processing failure), THEN THE system SHALL return a standardized error message as specified in [Error Handling Documentation](./10-error-handling-and-performance.md).\n\n## 7. Performance Requirements\n- WHEN a summary is requested, THE system SHALL return the response within 2 seconds for normal data volumes (assumed: up to 21 entries per week, since the app is limited to 3 per day).\n- WHERE summary generation logic involves filtering by date and archival status, THE system SHALL process only unarchived entries to minimize unnecessary computation.\n\n## 8. Example Scenarios\n### Example 1: Normal Week\n- User enters 2 moods/day for 7 days: summary shows counts aggregated per mood/day.\n### Example 2: Overlap with 30-Day Archive\n- If entry on day 1 is now >30 days old but all others are recent, only recent entries are included; counts for the archived day's moods are zero.\n### Example 3: Sparse Data\n- User enters moods only on Mondays and Fridays. Summary shows nonzero counts for those days, zeroes for all other days/moods.\n### Example 4: No Data for the Week\n- User requests summary but has no entries at all or all are archived: summary is all zeros.\n\n## 9. Mermaid Diagram: Weekly Mood Summary Logic\n```mermaid\ngraph LR\n    subgraph \"Summary Generation\"\n      A[\"Request Weekly Summary\"] --> B[\"Determine 7-Day Window\"]\n      B --> C[\"Query Unarchived Mood Entries\"]\n      C --> D[\"Group Entries By Day and Mood Type\"]\n      D --> E[\"Count Entries per Mood Type and Day\"]\n      E --> F[\"Generate Output Structure\"]\n    end\n\n    subgraph \"Archiving Logic\"\n      G[\"Entry Timestamp > 30 Days Ago?\"]\n      G -->|\"Yes\"| H[\"Mark as Archived, Exclude from Query\"]\n      G -->|\"No\"| C\n    end\n\n    A --> B\n    B --> G\n```\n\n## 10. EARS-Formatted Requirement Summary Table\n| ID | Requirement (EARS) |\n|----|--------------------|\n| 1 | THE system SHALL generate weekly mood summaries for the most recent 7-day window. |\n| 2 | THE system SHALL count each mood type's occurrence using only unarchived entries. |\n| 3 | WHEN a summary is generated, THE system SHALL output counts per mood type and per day for the time window. |\n| 4 | IF an entry is older than 30 days, THEN THE system SHALL exclude it from all summary results. |\n| 5 | IF no entries are present for the week, THEN THE system SHALL show all mood types with zero counts. |\n| 6 | THE system SHALL indicate the start and end ISO dates used in the summary. |\n| 7 | WHEN a summary is requested, THE system SHALL provide all results within 2 seconds. |\n| 8 | WHERE days in the window lack any mood entry, THE system SHALL set all mood counts for that day to zero. |\n\n---\n\nThis document provides business requirements only. All technical implementation decisions belong to developers. Developers have full autonomy over architecture, APIs, and database design. The document describes WHAT the system should do, not HOW to build it."},{"reason":"To clarify rules and procedures for archiving entries and ensuring old data is neither shown nor used in statistics, but available for future export.","filename":"09-archiving-and-data-retention.md","documentType":"requirement","outline":["30-Day Archiving Rule","Visibility Rules","Impact on Summaries","Export Considerations"],"audience":"backend developers","content":"# Archiving and Data Retention Requirements for Mood Diary\n\n## 1. 30-Day Archiving Rule\n\nAll mood entries transition through a staged lifecycle based on their creation timestamp. To promote simplicity, privacy, and manageable statistics, the Mood Diary application maintains a strict 30-day retention policy for active entries.\n\n- THE system SHALL automatically archive any mood entry **once its creation timestamp exceeds 30 calendar days past the moment of entry creation** (measured in UTC).\n- WHEN an entry is archived, THE system SHALL immediately remove it from all user-facing lists, statistics, and summaries within the app.\n- THE entry's archived status SHALL be determined by comparing its timestamp with the current server UTC date; if the difference is 30 days or more, archiving triggers at the next system check or user interaction.\n\n### Implementation Considerations\n- Archiving logic should be executed at least daily and whenever user-facing actions might reveal new data.\n- Archiving SHALL NOT rely solely on user actions; background or scheduled processes should ensure compliance with the 30-day rule.\n\n## 2. Visibility Rules\n\n### Policy for Archived Entries\n\n- IF a mood entry is archived, THEN THE system SHALL ensure it is completely hidden from all standard application interfaces.\n- Archived entries SHALL NOT appear in any mood entry listings, weekly summaries, mood statistics, or graphs.\n- There SHALL be no option for the user to view, restore, or interact with archived entries via the standard user interface.\n\n### User Experience and Frontend Behavior\n- Archived entries are invisible and inaccessible in the app. The user will not be notified when entries are archived.\n- THE system SHALL guarantee the integrity and security of archiving, such that the user cannot circumvent the retention policy or reveal archived data via unintended means.\n\n## 3. Impact on Summaries and Statistics\n\n- THE system SHALL generate all mood summaries and mood-type statistics using **ONLY active entries from the previous 7 days** (unarchived entries).\n- WHEN generating weekly summaries, THE system SHALL exclude all entries that are archived (i.e., older than 30 days).\n- IF archival logic triggers during summary generation, THEN THE system SHALL update the in-memory or temporary dataset to reflect newly archived entries, ensuring summaries are recalculated as needed.\n- THE system SHALL never count archived entries in any calculation, total, or aggregate metric within the user-facing app.\n\n## 4. Export Considerations for Archived Data\n\n- THE system SHALL retain archived entries solely for the purpose of potential future export functionality.\n- Archived entries SHALL NOT be exposed, listed, or downloadable through any standard app workflow.\n- WHEN an explicit, backend-authorized export feature is developed (future scope), THE system MAY include archived entries in the exported dataset, per business policy and legal requirements.\n- Until such a feature exists, archived entries are effectively inaccessible and unreferenced by all user-accessible endpoints.\n\n## 5. Mermaid Diagram: Mood Entry Lifecycle (Archiving)\n\n```mermaid\ngraph LR\n    A[\"Mood Entry Created\"] --> B[\"Is entry less than 30 days old?\"]\n    B -->|\"Yes\"| C[\"Entry is Active\"]\n    B -->|\"No\"| D[\"Archive Entry\"]\n    C --> E[\"Visible in App and Summaries\"]\n    D --> F[\"Hidden from App and Stats\"]\n    F --> G[\"Retained for Future Export Only\"]\n```\n\n## 6. Business Rules and Validation (EARS Format)\n\n### Archiving Policy\n- THE system SHALL archive each mood entry **after 30 days** from its creation timestamp.\n- WHEN an entry enters the archive state, THE system SHALL immediately ensure it is not shown or included in any user interface, summary, or statistic.\n\n### Visibility Rules\n- IF a mood entry is archived, THEN THE system SHALL block all attempts to access, view, or process its data through normal app operations.\n- WHILE an entry is in the archived state, THE system SHALL not reference it outside backend-export operations.\n\n### Statistics Exclusion\n- WHEN computing mood statistics or weekly summaries, THE system SHALL consider only entries that are active (less than 30 days old).\n- IF a summary query would select both active and archived entries, THEN THE system SHALL filter out archived entries before aggregating or counting.\n\n### Export Constraint\n- WHERE a backend export operation for data is explicitly authorized, THE system SHALL include archived entries in the export dataset per business policy.\n\n## 7. Error Scenarios and Handling\n\n- IF an API or process attempts to access an archived entry for view/list/statistic purposes, THEN THE system SHALL return a not found or forbidden error, as appropriate to the endpoint contract.\n- IF an export request is made without explicit authorization, THEN THE system SHALL deny the request and log a security event.\n\n## 8. Performance and Data Integrity Expectations\n\n- THE system SHALL process archiving and entry filtering in a way that ensures instant user queries and statistics (results within 1 second for typical datasets).\n- THE archiving process SHALL NOT introduce lag or visible delay to the user during normal app usage.\n\n## Summary Table: Archiving Rules & Impacts\n\n| Rule                          | Applies To           | Result/Effect                                     |\n|-------------------------------|---------------------|---------------------------------------------------|\n| Auto-archive after 30 days    | All mood entries    | Entry is removed from lists, stats, and summaries |\n| Archived entries hidden       | Archived entries    | Never visible on frontend                        |\n| Excluded from statistics      | Archived entries    | Not used in weekly summary or mood counts         |\n| Retained only for export      | Archived entries    | Not accessible unless future export is enabled    |\n\n---\nFor other policies and requirements, see the [Functional Requirements Document](./04-functional-requirements.md) and [Business Rules and Validation](./06-business-rules-and-validation.md).\n"},{"reason":"To specify clear user-facing and system-level error scenarios, recovery procedures, and success/failure response patterns for all core operations.","filename":"10-error-handling-and-performance.md","documentType":"requirement","outline":["Add Entry Failures","Exceeding Entry Limit","Future Timestamp Rejection","Performance and Response Expectations"],"audience":"backend developers","content":"# Error Handling and Performance Requirements for Mood Diary\n\n## Introduction\nThis document details the business requirements for error handling, user-facing and system response behaviors, and performance expectations for the Mood Diary application backend. The objective is to establish unambiguous rules for how the system must react to invalid input, business rule violations, and internal exceptions, ensuring both data integrity and a user-friendly experience.\n\n## Add Entry Failures\n\n### Invalid Data Submissions\n- WHEN a user submits a mood entry with a missing or empty mood type, THEN THE system SHALL reject the entry and respond with an error message indicating that a valid mood type is required.\n- WHEN a user submits a mood entry with a mood type not in the fixed list [happy, sad, anxious, excited, angry, calm, stressed, tired], THEN THE system SHALL reject the entry with a specific message stating the allowed mood types.\n- WHEN a user provides a note that exceeds the maximum note length allowed by the system (e.g., 500 characters), THEN THE system SHALL reject the entry and return an error explaining the length restriction.\n- WHEN a user attempts to submit a note containing prohibited characters or formats, THEN THE system SHALL reject the entry and provide a relevant error message.\n- WHEN a user attempts to submit an entry with a malformed or missing timestamp, THEN THE system SHALL reject the entry and return an error message specifying the expected timestamp format.\n\n### System Unavailability or Internal Failure\n- IF the backend or database is unavailable, THEN THE system SHALL return a generic error indicating that the service is temporarily inaccessible and advise the user to try again later.\n- IF an unexpected internal error occurs during a request, THEN THE system SHALL return a standardized internal error message and log detailed diagnostic information for troubleshooting.\n\n## Exceeding Entry Limit\n- WHEN a user attempts to add more than 3 mood entries for a single calendar day, THEN THE system SHALL reject the submission and return an error message specifying that the daily limit has been reached.\n- WHEN the daily entry limit is reached, THE system SHALL prevent further submission attempts for that day for all users.\n\n## Future Timestamp Rejection\n- WHEN a user submits a mood entry with a timestamp later than the current server time, THEN THE system SHALL reject the entry and return an error stating that future times are not allowed.\n- WHEN a user attempts to manipulate client time to submit a future-dated entry, THE system SHALL always validate against server-side current time before accepting.\n\n## Performance and Response Expectations\n- THE system SHALL respond to mood entry submissions within 1 second under normal operating conditions.\n- THE system SHALL return any error or success message to users within 2 seconds, including clear guidance if the action failed.\n- THE system SHALL generate and return weekly mood summary statistics within 2 seconds in 95% of cases, and never longer than 5 seconds in extreme load scenarios.\n- THE system SHALL support concurrent processing for up to 100 simultaneous requests without performance degradation for normal operations.\n- WHEN a performance or capacity threshold is approached or exceeded, THEN THE system SHALL log this event and issue an appropriate alert for operations monitoring (does not affect user-facing flows but is mandatory for supportability).\n\n## Error and Success Messaging Patterns\n- THE system SHALL provide user-facing error messages that are clear, specific, and actionable in natural language (e.g., “You have reached your daily entry limit of 3 moods” or “Only select from the standard mood types”).\n- THE system SHALL avoid exposing internal database or infrastructure details in any user-facing message; log technical details for internal support only.\n- THE system SHALL respond to successful operations with confirmation messages, including record of what was accepted, relevant timestamps, and mood types.\n- THE system SHALL deliver a consistent and predictable structure for all API responses, using a standardized field for message, details, and error codes for client handling.\n\n## Error Scenario Flow Example\n\n```mermaid\ngraph LR\n  A[\"User Submits Mood Entry\"] --> B{\"All Business Rules/Validation Passed?\"}\n  B -->|\"Yes\"| C[\"Entry Saved; Success Response Returned in < 1s\"]\n  B -->|\"No\"| D{\"Which Rule Failed?\"}\n  D -->|\"Invalid Mood Type\"| E[\"Return Specific Error: Invalid Mood Type\"]\n  D -->|\"Entry Limit Exceeded\"| F[\"Return Error: Daily Entry Limit Reached\"]\n  D -->|\"Future Timestamp\"| G[\"Return Error: Future Timestamps Not Allowed\"]\n  D -->|\"System/Internal Error\"| H[\"Return Standardized System Error\"]\n```\n\n## Summary\nThis document specifies response and error handling business requirements and performance guarantees for all main Mood Diary backend actions. Backend development teams must ensure every listed scenario is covered, messages are clear and user-centric, and system performance meets specified SLAs under expected loads."}],"created_at":"2025-09-14T15:03:45.500Z","completed_at":"2025-09-14T15:07:15.941Z","step":0},{"id":"019948c5-2e7d-71ef-840a-5dd5a6e0a5df","type":"userMessage","contents":[{"type":"text","text":"Now go with Database Design"}],"created_at":"2025-09-14T15:08:26.109Z"},{"type":"prisma","id":"019948c6-8940-7477-8c50-ede23e5049f8","reason":"The requirements specification for the Mood Diary web application is complete and clear. Proceeding to generate the database schema and ERD documentation to model mood entries with constraints for fixed mood types, timestamps, and archiving logic.","schemas":{"schema-01-actors.prisma":"/// Represents the logical owner/actor of the Mood Diary. This model\n/// currently supports a single diary user, matching the app's business logic\n/// of a single-user system. It is the reference point for all mood entries\n/// via foreign keys and ensures the actor boundary is clear. By\n/// encapsulating user context here, future expansion to a multi-user\n/// scenario or advanced metadata storage is simplified. Fields are minimized\n/// as only a logical system user is required.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel mood_diary_diaryusers {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Timestamp indicating when the diary user was (theoretically) created.\n  /// Used for future extensibility and auditability, even if only a single\n  /// logical user exists.\n  created_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  mood_diary_mood_entries mood_diary_mood_entries[]\n  \n  @@index([created_at])\n}","schema-02-diaries.prisma":"/// This table stores each mood diary entry, representing the core journaling\n/// activity in the Mood Diary application. Each entry records a mood\n/// selected from a fixed set of 8 types, an optional note (up to 500 Unicode\n/// characters), an automatic creation timestamp, and an \"archived\" status\n/// indicating if the entry is older than 30 days (and therefore excluded\n/// from listings and summaries). Entries are immutable: once created, they\n/// cannot be edited or deleted. Each entry references the logical diary user\n/// in the system ({@link mood_diary_diaryusers}), supporting future\n/// extensibility for multi-user scenarios. All mood and archiving business\n/// rules are strictly enforced in application logic.\n///\n/// @namespace Diaries\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel mood_diary_mood_entries {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// References the logical mood diary user. {@link mood_diary_diaryusers.id}.\n  mood_diary_diaryuser_id String @db.Uuid\n  \n  /// Mood type selected for this entry, must be one of: happy, sad, anxious,\n  /// excited, angry, calm, stressed, tired. Enforced via application logic.\n  mood_type String\n  \n  /// Optional freeform note for this entry, max 500 Unicode characters. May be\n  /// blank or null.\n  note String?\n  \n  /// Timestamp when this entry was created (auto-set, UTC, immutable, used for\n  /// archiving and queries).\n  created_at DateTime @db.Timestamptz\n  \n  /// Indicates if this entry has been archived (i.e., older than 30 days, as\n  /// determined by background process). Archived entries are hidden from\n  /// listings/statistics.\n  archived Boolean\n  \n  //----\n  // RELATIONS\n  //----\n  diaryUser mood_diary_diaryusers @relation(fields: [mood_diary_diaryuser_id], references: [id], onDelete: Cascade)\n  \n  @@index([mood_diary_diaryuser_id])\n  \n  @@index([mood_type])\n  @@index([created_at])\n  @@index([archived])\n  @@index([note(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n  binaryTargets   = [\"native\"]\n}\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}"},"result":{"success":true,"data":{"files":[{"filename":"schema-01-actors.prisma","namespace":"Actors","models":[{"name":"mood_diary_diaryusers","description":"Represents the logical owner/actor of the Mood Diary. This model currently supports a single diary user, matching the app's business logic of a single-user system. It is the reference point for all mood entries via foreign keys and ensures the actor boundary is clear. By encapsulating user context here, future expansion to a multi-user scenario or advanced metadata storage is simplified. Fields are minimized as only a logical system user is required.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"created_at","type":"datetime","description":"Timestamp indicating when the diary user was (theoretically) created. Used for future extensibility and auditability, even if only a single logical user exists.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]}]},{"filename":"schema-02-diaries.prisma","namespace":"Diaries","models":[{"name":"mood_diary_mood_entries","description":"This table stores each mood diary entry, representing the core journaling activity in the Mood Diary application. Each entry records a mood selected from a fixed set of 8 types, an optional note (up to 500 Unicode characters), an automatic creation timestamp, and an \"archived\" status indicating if the entry is older than 30 days (and therefore excluded from listings and summaries). Entries are immutable: once created, they cannot be edited or deleted. Each entry references the logical diary user in the system ({@link mood_diary_diaryusers}), supporting future extensibility for multi-user scenarios. All mood and archiving business rules are strictly enforced in application logic.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"mood_diary_diaryuser_id","type":"uuid","description":"References the logical mood diary user. {@link mood_diary_diaryusers.id}.","relation":{"name":"diaryUser","targetModel":"mood_diary_diaryusers"},"unique":false,"nullable":false}],"plainFields":[{"name":"mood_type","type":"string","description":"Mood type selected for this entry, must be one of: happy, sad, anxious, excited, angry, calm, stressed, tired. Enforced via application logic.","nullable":false},{"name":"note","type":"string","description":"Optional freeform note for this entry, max 500 Unicode characters. May be blank or null.","nullable":true},{"name":"created_at","type":"datetime","description":"Timestamp when this entry was created (auto-set, UTC, immutable, used for archiving and queries).","nullable":false},{"name":"archived","type":"boolean","description":"Indicates if this entry has been archived (i.e., older than 30 days, as determined by background process). Archived entries are hidden from listings/statistics.","nullable":false}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["mood_type"]},{"fieldNames":["created_at"]},{"fieldNames":["archived"]}],"ginIndexes":[{"fieldName":"note"}]}]}]}},"compiled":{"type":"success","schemas":{"schema-01-actors.prisma":"/// Represents the logical owner/actor of the Mood Diary. This model\n/// currently supports a single diary user, matching the app's business logic\n/// of a single-user system. It is the reference point for all mood entries\n/// via foreign keys and ensures the actor boundary is clear. By\n/// encapsulating user context here, future expansion to a multi-user\n/// scenario or advanced metadata storage is simplified. Fields are minimized\n/// as only a logical system user is required.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel mood_diary_diaryusers {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Timestamp indicating when the diary user was (theoretically) created.\n  /// Used for future extensibility and auditability, even if only a single\n  /// logical user exists.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  mood_diary_mood_entries mood_diary_mood_entries[]\n\n  @@index([created_at])\n}\n","schema-02-diaries.prisma":"/// This table stores each mood diary entry, representing the core journaling\n/// activity in the Mood Diary application. Each entry records a mood\n/// selected from a fixed set of 8 types, an optional note (up to 500 Unicode\n/// characters), an automatic creation timestamp, and an \"archived\" status\n/// indicating if the entry is older than 30 days (and therefore excluded\n/// from listings and summaries). Entries are immutable: once created, they\n/// cannot be edited or deleted. Each entry references the logical diary user\n/// in the system ({@link mood_diary_diaryusers}), supporting future\n/// extensibility for multi-user scenarios. All mood and archiving business\n/// rules are strictly enforced in application logic.\n///\n/// @namespace Diaries\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel mood_diary_mood_entries {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// References the logical mood diary user. {@link mood_diary_diaryusers.id}.\n  mood_diary_diaryuser_id String @db.Uuid\n\n  /// Mood type selected for this entry, must be one of: happy, sad, anxious,\n  /// excited, angry, calm, stressed, tired. Enforced via application logic.\n  mood_type String\n\n  /// Optional freeform note for this entry, max 500 Unicode characters. May be\n  /// blank or null.\n  note String?\n\n  /// Timestamp when this entry was created (auto-set, UTC, immutable, used for\n  /// archiving and queries).\n  created_at DateTime @db.Timestamptz\n\n  /// Indicates if this entry has been archived (i.e., older than 30 days, as\n  /// determined by background process). Archived entries are hidden from\n  /// listings/statistics.\n  archived Boolean\n\n  //----\n  // RELATIONS\n  //----\n  diaryUser mood_diary_diaryusers @relation(fields: [mood_diary_diaryuser_id], references: [id], onDelete: Cascade)\n\n  @@index([mood_diary_diaryuser_id])\n  @@index([mood_type])\n  @@index([created_at])\n  @@index([archived])\n  @@index([note(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n  binaryTargets   = [\"native\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}\n"},"nodeModules":{"node_modules/.prisma/client/client.d.ts":"export * from \"./index\"","node_modules/.prisma/client/default.d.ts":"export * from \"./index\"","node_modules/.prisma/client/edge.d.ts":"export * from \"./default\"","node_modules/.prisma/client/index.d.ts":"\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/library.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model mood_diary_diaryusers\n * Represents the logical owner/actor of the Mood Diary. This model\n * currently supports a single diary user, matching the app's business logic\n * of a single-user system. It is the reference point for all mood entries\n * via foreign keys and ensures the actor boundary is clear. By\n * encapsulating user context here, future expansion to a multi-user\n * scenario or advanced metadata storage is simplified. Fields are minimized\n * as only a logical system user is required.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type mood_diary_diaryusers = $Result.DefaultSelection<Prisma.$mood_diary_diaryusersPayload>\n/**\n * Model mood_diary_mood_entries\n * This table stores each mood diary entry, representing the core journaling\n * activity in the Mood Diary application. Each entry records a mood\n * selected from a fixed set of 8 types, an optional note (up to 500 Unicode\n * characters), an automatic creation timestamp, and an \"archived\" status\n * indicating if the entry is older than 30 days (and therefore excluded\n * from listings and summaries). Entries are immutable: once created, they\n * cannot be edited or deleted. Each entry references the logical diary user\n * in the system ({@link mood_diary_diaryusers}), supporting future\n * extensibility for multi-user scenarios. All mood and archiving business\n * rules are strictly enforced in application logic.\n * \n * @namespace Diaries\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type mood_diary_mood_entries = $Result.DefaultSelection<Prisma.$mood_diary_mood_entriesPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Mood_diary_diaryusers\n * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Mood_diary_diaryusers\n   * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.mood_diary_diaryusers`: Exposes CRUD operations for the **mood_diary_diaryusers** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Mood_diary_diaryusers\n    * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.findMany()\n    * ```\n    */\n  get mood_diary_diaryusers(): Prisma.mood_diary_diaryusersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.mood_diary_mood_entries`: Exposes CRUD operations for the **mood_diary_mood_entries** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Mood_diary_mood_entries\n    * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.findMany()\n    * ```\n    */\n  get mood_diary_mood_entries(): Prisma.mood_diary_mood_entriesDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    mood_diary_diaryusers: 'mood_diary_diaryusers',\n    mood_diary_mood_entries: 'mood_diary_mood_entries'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"mood_diary_diaryusers\" | \"mood_diary_mood_entries\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      mood_diary_diaryusers: {\n        payload: Prisma.$mood_diary_diaryusersPayload<ExtArgs>\n        fields: Prisma.mood_diary_diaryusersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.mood_diary_diaryusersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.mood_diary_diaryusersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload>\n          }\n          findFirst: {\n            args: Prisma.mood_diary_diaryusersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.mood_diary_diaryusersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload>\n          }\n          findMany: {\n            args: Prisma.mood_diary_diaryusersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload>[]\n          }\n          create: {\n            args: Prisma.mood_diary_diaryusersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload>\n          }\n          createMany: {\n            args: Prisma.mood_diary_diaryusersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.mood_diary_diaryusersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload>[]\n          }\n          delete: {\n            args: Prisma.mood_diary_diaryusersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload>\n          }\n          update: {\n            args: Prisma.mood_diary_diaryusersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload>\n          }\n          deleteMany: {\n            args: Prisma.mood_diary_diaryusersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.mood_diary_diaryusersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.mood_diary_diaryusersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload>[]\n          }\n          upsert: {\n            args: Prisma.mood_diary_diaryusersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_diaryusersPayload>\n          }\n          aggregate: {\n            args: Prisma.Mood_diary_diaryusersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateMood_diary_diaryusers>\n          }\n          groupBy: {\n            args: Prisma.mood_diary_diaryusersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Mood_diary_diaryusersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.mood_diary_diaryusersCountArgs<ExtArgs>\n            result: $Utils.Optional<Mood_diary_diaryusersCountAggregateOutputType> | number\n          }\n        }\n      }\n      mood_diary_mood_entries: {\n        payload: Prisma.$mood_diary_mood_entriesPayload<ExtArgs>\n        fields: Prisma.mood_diary_mood_entriesFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.mood_diary_mood_entriesFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.mood_diary_mood_entriesFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload>\n          }\n          findFirst: {\n            args: Prisma.mood_diary_mood_entriesFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.mood_diary_mood_entriesFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload>\n          }\n          findMany: {\n            args: Prisma.mood_diary_mood_entriesFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload>[]\n          }\n          create: {\n            args: Prisma.mood_diary_mood_entriesCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload>\n          }\n          createMany: {\n            args: Prisma.mood_diary_mood_entriesCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.mood_diary_mood_entriesCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload>[]\n          }\n          delete: {\n            args: Prisma.mood_diary_mood_entriesDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload>\n          }\n          update: {\n            args: Prisma.mood_diary_mood_entriesUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload>\n          }\n          deleteMany: {\n            args: Prisma.mood_diary_mood_entriesDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.mood_diary_mood_entriesUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.mood_diary_mood_entriesUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload>[]\n          }\n          upsert: {\n            args: Prisma.mood_diary_mood_entriesUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$mood_diary_mood_entriesPayload>\n          }\n          aggregate: {\n            args: Prisma.Mood_diary_mood_entriesAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateMood_diary_mood_entries>\n          }\n          groupBy: {\n            args: Prisma.mood_diary_mood_entriesGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Mood_diary_mood_entriesGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.mood_diary_mood_entriesCountArgs<ExtArgs>\n            result: $Utils.Optional<Mood_diary_mood_entriesCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Shorthand for `emit: 'stdout'`\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events only\n     * log: [\n     *   { emit: 'event', level: 'query' },\n     *   { emit: 'event', level: 'info' },\n     *   { emit: 'event', level: 'warn' }\n     *   { emit: 'event', level: 'error' }\n     * ]\n     * \n     * / Emit as events and log to stdout\n     * og: [\n     *  { emit: 'stdout', level: 'query' },\n     *  { emit: 'stdout', level: 'info' },\n     *  { emit: 'stdout', level: 'warn' }\n     *  { emit: 'stdout', level: 'error' }\n     * \n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    mood_diary_diaryusers?: mood_diary_diaryusersOmit\n    mood_diary_mood_entries?: mood_diary_mood_entriesOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\n  export type GetLogType<T> = CheckIsLogLevel<\n    T extends LogDefinition ? T['level'] : T\n  >;\n\n  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n    ? GetLogType<T[number]>\n    : never;\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type Mood_diary_diaryusersCountOutputType\n   */\n\n  export type Mood_diary_diaryusersCountOutputType = {\n    mood_diary_mood_entries: number\n  }\n\n  export type Mood_diary_diaryusersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    mood_diary_mood_entries?: boolean | Mood_diary_diaryusersCountOutputTypeCountMood_diary_mood_entriesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Mood_diary_diaryusersCountOutputType without action\n   */\n  export type Mood_diary_diaryusersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Mood_diary_diaryusersCountOutputType\n     */\n    select?: Mood_diary_diaryusersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Mood_diary_diaryusersCountOutputType without action\n   */\n  export type Mood_diary_diaryusersCountOutputTypeCountMood_diary_mood_entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: mood_diary_mood_entriesWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model mood_diary_diaryusers\n   */\n\n  export type AggregateMood_diary_diaryusers = {\n    _count: Mood_diary_diaryusersCountAggregateOutputType | null\n    _min: Mood_diary_diaryusersMinAggregateOutputType | null\n    _max: Mood_diary_diaryusersMaxAggregateOutputType | null\n  }\n\n  export type Mood_diary_diaryusersMinAggregateOutputType = {\n    id: string | null\n    created_at: Date | null\n  }\n\n  export type Mood_diary_diaryusersMaxAggregateOutputType = {\n    id: string | null\n    created_at: Date | null\n  }\n\n  export type Mood_diary_diaryusersCountAggregateOutputType = {\n    id: number\n    created_at: number\n    _all: number\n  }\n\n\n  export type Mood_diary_diaryusersMinAggregateInputType = {\n    id?: true\n    created_at?: true\n  }\n\n  export type Mood_diary_diaryusersMaxAggregateInputType = {\n    id?: true\n    created_at?: true\n  }\n\n  export type Mood_diary_diaryusersCountAggregateInputType = {\n    id?: true\n    created_at?: true\n    _all?: true\n  }\n\n  export type Mood_diary_diaryusersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which mood_diary_diaryusers to aggregate.\n     */\n    where?: mood_diary_diaryusersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of mood_diary_diaryusers to fetch.\n     */\n    orderBy?: mood_diary_diaryusersOrderByWithRelationInput | mood_diary_diaryusersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: mood_diary_diaryusersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` mood_diary_diaryusers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` mood_diary_diaryusers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned mood_diary_diaryusers\n    **/\n    _count?: true | Mood_diary_diaryusersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Mood_diary_diaryusersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Mood_diary_diaryusersMaxAggregateInputType\n  }\n\n  export type GetMood_diary_diaryusersAggregateType<T extends Mood_diary_diaryusersAggregateArgs> = {\n        [P in keyof T & keyof AggregateMood_diary_diaryusers]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateMood_diary_diaryusers[P]>\n      : GetScalarType<T[P], AggregateMood_diary_diaryusers[P]>\n  }\n\n\n\n\n  export type mood_diary_diaryusersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: mood_diary_diaryusersWhereInput\n    orderBy?: mood_diary_diaryusersOrderByWithAggregationInput | mood_diary_diaryusersOrderByWithAggregationInput[]\n    by: Mood_diary_diaryusersScalarFieldEnum[] | Mood_diary_diaryusersScalarFieldEnum\n    having?: mood_diary_diaryusersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Mood_diary_diaryusersCountAggregateInputType | true\n    _min?: Mood_diary_diaryusersMinAggregateInputType\n    _max?: Mood_diary_diaryusersMaxAggregateInputType\n  }\n\n  export type Mood_diary_diaryusersGroupByOutputType = {\n    id: string\n    created_at: Date\n    _count: Mood_diary_diaryusersCountAggregateOutputType | null\n    _min: Mood_diary_diaryusersMinAggregateOutputType | null\n    _max: Mood_diary_diaryusersMaxAggregateOutputType | null\n  }\n\n  type GetMood_diary_diaryusersGroupByPayload<T extends mood_diary_diaryusersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Mood_diary_diaryusersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Mood_diary_diaryusersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Mood_diary_diaryusersGroupByOutputType[P]>\n            : GetScalarType<T[P], Mood_diary_diaryusersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type mood_diary_diaryusersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    created_at?: boolean\n    mood_diary_mood_entries?: boolean | mood_diary_diaryusers$mood_diary_mood_entriesArgs<ExtArgs>\n    _count?: boolean | Mood_diary_diaryusersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"mood_diary_diaryusers\"]>\n\n  export type mood_diary_diaryusersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    created_at?: boolean\n  }, ExtArgs[\"result\"][\"mood_diary_diaryusers\"]>\n\n  export type mood_diary_diaryusersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    created_at?: boolean\n  }, ExtArgs[\"result\"][\"mood_diary_diaryusers\"]>\n\n  export type mood_diary_diaryusersSelectScalar = {\n    id?: boolean\n    created_at?: boolean\n  }\n\n  export type mood_diary_diaryusersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"created_at\", ExtArgs[\"result\"][\"mood_diary_diaryusers\"]>\n  export type mood_diary_diaryusersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    mood_diary_mood_entries?: boolean | mood_diary_diaryusers$mood_diary_mood_entriesArgs<ExtArgs>\n    _count?: boolean | Mood_diary_diaryusersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type mood_diary_diaryusersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type mood_diary_diaryusersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $mood_diary_diaryusersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"mood_diary_diaryusers\"\n    objects: {\n      mood_diary_mood_entries: Prisma.$mood_diary_mood_entriesPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Timestamp indicating when the diary user was (theoretically) created.\n       * Used for future extensibility and auditability, even if only a single\n       * logical user exists.\n       */\n      created_at: Date\n    }, ExtArgs[\"result\"][\"mood_diary_diaryusers\"]>\n    composites: {}\n  }\n\n  type mood_diary_diaryusersGetPayload<S extends boolean | null | undefined | mood_diary_diaryusersDefaultArgs> = $Result.GetResult<Prisma.$mood_diary_diaryusersPayload, S>\n\n  type mood_diary_diaryusersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<mood_diary_diaryusersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Mood_diary_diaryusersCountAggregateInputType | true\n    }\n\n  export interface mood_diary_diaryusersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mood_diary_diaryusers'], meta: { name: 'mood_diary_diaryusers' } }\n    /**\n     * Find zero or one Mood_diary_diaryusers that matches the filter.\n     * @param {mood_diary_diaryusersFindUniqueArgs} args - Arguments to find a Mood_diary_diaryusers\n     * @example\n     * // Get one Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends mood_diary_diaryusersFindUniqueArgs>(args: SelectSubset<T, mood_diary_diaryusersFindUniqueArgs<ExtArgs>>): Prisma__mood_diary_diaryusersClient<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Mood_diary_diaryusers that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {mood_diary_diaryusersFindUniqueOrThrowArgs} args - Arguments to find a Mood_diary_diaryusers\n     * @example\n     * // Get one Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends mood_diary_diaryusersFindUniqueOrThrowArgs>(args: SelectSubset<T, mood_diary_diaryusersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mood_diary_diaryusersClient<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Mood_diary_diaryusers that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_diaryusersFindFirstArgs} args - Arguments to find a Mood_diary_diaryusers\n     * @example\n     * // Get one Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends mood_diary_diaryusersFindFirstArgs>(args?: SelectSubset<T, mood_diary_diaryusersFindFirstArgs<ExtArgs>>): Prisma__mood_diary_diaryusersClient<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Mood_diary_diaryusers that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_diaryusersFindFirstOrThrowArgs} args - Arguments to find a Mood_diary_diaryusers\n     * @example\n     * // Get one Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends mood_diary_diaryusersFindFirstOrThrowArgs>(args?: SelectSubset<T, mood_diary_diaryusersFindFirstOrThrowArgs<ExtArgs>>): Prisma__mood_diary_diaryusersClient<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Mood_diary_diaryusers that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_diaryusersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.findMany()\n     * \n     * // Get first 10 Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const mood_diary_diaryusersWithIdOnly = await prisma.mood_diary_diaryusers.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends mood_diary_diaryusersFindManyArgs>(args?: SelectSubset<T, mood_diary_diaryusersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Mood_diary_diaryusers.\n     * @param {mood_diary_diaryusersCreateArgs} args - Arguments to create a Mood_diary_diaryusers.\n     * @example\n     * // Create one Mood_diary_diaryusers\n     * const Mood_diary_diaryusers = await prisma.mood_diary_diaryusers.create({\n     *   data: {\n     *     // ... data to create a Mood_diary_diaryusers\n     *   }\n     * })\n     * \n     */\n    create<T extends mood_diary_diaryusersCreateArgs>(args: SelectSubset<T, mood_diary_diaryusersCreateArgs<ExtArgs>>): Prisma__mood_diary_diaryusersClient<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Mood_diary_diaryusers.\n     * @param {mood_diary_diaryusersCreateManyArgs} args - Arguments to create many Mood_diary_diaryusers.\n     * @example\n     * // Create many Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends mood_diary_diaryusersCreateManyArgs>(args?: SelectSubset<T, mood_diary_diaryusersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Mood_diary_diaryusers and returns the data saved in the database.\n     * @param {mood_diary_diaryusersCreateManyAndReturnArgs} args - Arguments to create many Mood_diary_diaryusers.\n     * @example\n     * // Create many Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Mood_diary_diaryusers and only return the `id`\n     * const mood_diary_diaryusersWithIdOnly = await prisma.mood_diary_diaryusers.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends mood_diary_diaryusersCreateManyAndReturnArgs>(args?: SelectSubset<T, mood_diary_diaryusersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Mood_diary_diaryusers.\n     * @param {mood_diary_diaryusersDeleteArgs} args - Arguments to delete one Mood_diary_diaryusers.\n     * @example\n     * // Delete one Mood_diary_diaryusers\n     * const Mood_diary_diaryusers = await prisma.mood_diary_diaryusers.delete({\n     *   where: {\n     *     // ... filter to delete one Mood_diary_diaryusers\n     *   }\n     * })\n     * \n     */\n    delete<T extends mood_diary_diaryusersDeleteArgs>(args: SelectSubset<T, mood_diary_diaryusersDeleteArgs<ExtArgs>>): Prisma__mood_diary_diaryusersClient<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Mood_diary_diaryusers.\n     * @param {mood_diary_diaryusersUpdateArgs} args - Arguments to update one Mood_diary_diaryusers.\n     * @example\n     * // Update one Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends mood_diary_diaryusersUpdateArgs>(args: SelectSubset<T, mood_diary_diaryusersUpdateArgs<ExtArgs>>): Prisma__mood_diary_diaryusersClient<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Mood_diary_diaryusers.\n     * @param {mood_diary_diaryusersDeleteManyArgs} args - Arguments to filter Mood_diary_diaryusers to delete.\n     * @example\n     * // Delete a few Mood_diary_diaryusers\n     * const { count } = await prisma.mood_diary_diaryusers.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends mood_diary_diaryusersDeleteManyArgs>(args?: SelectSubset<T, mood_diary_diaryusersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Mood_diary_diaryusers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_diaryusersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends mood_diary_diaryusersUpdateManyArgs>(args: SelectSubset<T, mood_diary_diaryusersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Mood_diary_diaryusers and returns the data updated in the database.\n     * @param {mood_diary_diaryusersUpdateManyAndReturnArgs} args - Arguments to update many Mood_diary_diaryusers.\n     * @example\n     * // Update many Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Mood_diary_diaryusers and only return the `id`\n     * const mood_diary_diaryusersWithIdOnly = await prisma.mood_diary_diaryusers.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends mood_diary_diaryusersUpdateManyAndReturnArgs>(args: SelectSubset<T, mood_diary_diaryusersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Mood_diary_diaryusers.\n     * @param {mood_diary_diaryusersUpsertArgs} args - Arguments to update or create a Mood_diary_diaryusers.\n     * @example\n     * // Update or create a Mood_diary_diaryusers\n     * const mood_diary_diaryusers = await prisma.mood_diary_diaryusers.upsert({\n     *   create: {\n     *     // ... data to create a Mood_diary_diaryusers\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Mood_diary_diaryusers we want to update\n     *   }\n     * })\n     */\n    upsert<T extends mood_diary_diaryusersUpsertArgs>(args: SelectSubset<T, mood_diary_diaryusersUpsertArgs<ExtArgs>>): Prisma__mood_diary_diaryusersClient<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Mood_diary_diaryusers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_diaryusersCountArgs} args - Arguments to filter Mood_diary_diaryusers to count.\n     * @example\n     * // Count the number of Mood_diary_diaryusers\n     * const count = await prisma.mood_diary_diaryusers.count({\n     *   where: {\n     *     // ... the filter for the Mood_diary_diaryusers we want to count\n     *   }\n     * })\n    **/\n    count<T extends mood_diary_diaryusersCountArgs>(\n      args?: Subset<T, mood_diary_diaryusersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Mood_diary_diaryusersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Mood_diary_diaryusers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Mood_diary_diaryusersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Mood_diary_diaryusersAggregateArgs>(args: Subset<T, Mood_diary_diaryusersAggregateArgs>): Prisma.PrismaPromise<GetMood_diary_diaryusersAggregateType<T>>\n\n    /**\n     * Group by Mood_diary_diaryusers.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_diaryusersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends mood_diary_diaryusersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: mood_diary_diaryusersGroupByArgs['orderBy'] }\n        : { orderBy?: mood_diary_diaryusersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, mood_diary_diaryusersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMood_diary_diaryusersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the mood_diary_diaryusers model\n   */\n  readonly fields: mood_diary_diaryusersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for mood_diary_diaryusers.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__mood_diary_diaryusersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    mood_diary_mood_entries<T extends mood_diary_diaryusers$mood_diary_mood_entriesArgs<ExtArgs> = {}>(args?: Subset<T, mood_diary_diaryusers$mood_diary_mood_entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the mood_diary_diaryusers model\n   */\n  interface mood_diary_diaryusersFieldRefs {\n    readonly id: FieldRef<\"mood_diary_diaryusers\", 'String'>\n    readonly created_at: FieldRef<\"mood_diary_diaryusers\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * mood_diary_diaryusers findUnique\n   */\n  export type mood_diary_diaryusersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_diaryusersInclude<ExtArgs> | null\n    /**\n     * Filter, which mood_diary_diaryusers to fetch.\n     */\n    where: mood_diary_diaryusersWhereUniqueInput\n  }\n\n  /**\n   * mood_diary_diaryusers findUniqueOrThrow\n   */\n  export type mood_diary_diaryusersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_diaryusersInclude<ExtArgs> | null\n    /**\n     * Filter, which mood_diary_diaryusers to fetch.\n     */\n    where: mood_diary_diaryusersWhereUniqueInput\n  }\n\n  /**\n   * mood_diary_diaryusers findFirst\n   */\n  export type mood_diary_diaryusersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_diaryusersInclude<ExtArgs> | null\n    /**\n     * Filter, which mood_diary_diaryusers to fetch.\n     */\n    where?: mood_diary_diaryusersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of mood_diary_diaryusers to fetch.\n     */\n    orderBy?: mood_diary_diaryusersOrderByWithRelationInput | mood_diary_diaryusersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for mood_diary_diaryusers.\n     */\n    cursor?: mood_diary_diaryusersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` mood_diary_diaryusers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` mood_diary_diaryusers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of mood_diary_diaryusers.\n     */\n    distinct?: Mood_diary_diaryusersScalarFieldEnum | Mood_diary_diaryusersScalarFieldEnum[]\n  }\n\n  /**\n   * mood_diary_diaryusers findFirstOrThrow\n   */\n  export type mood_diary_diaryusersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_diaryusersInclude<ExtArgs> | null\n    /**\n     * Filter, which mood_diary_diaryusers to fetch.\n     */\n    where?: mood_diary_diaryusersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of mood_diary_diaryusers to fetch.\n     */\n    orderBy?: mood_diary_diaryusersOrderByWithRelationInput | mood_diary_diaryusersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for mood_diary_diaryusers.\n     */\n    cursor?: mood_diary_diaryusersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` mood_diary_diaryusers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` mood_diary_diaryusers.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of mood_diary_diaryusers.\n     */\n    distinct?: Mood_diary_diaryusersScalarFieldEnum | Mood_diary_diaryusersScalarFieldEnum[]\n  }\n\n  /**\n   * mood_diary_diaryusers findMany\n   */\n  export type mood_diary_diaryusersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_diaryusersInclude<ExtArgs> | null\n    /**\n     * Filter, which mood_diary_diaryusers to fetch.\n     */\n    where?: mood_diary_diaryusersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of mood_diary_diaryusers to fetch.\n     */\n    orderBy?: mood_diary_diaryusersOrderByWithRelationInput | mood_diary_diaryusersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing mood_diary_diaryusers.\n     */\n    cursor?: mood_diary_diaryusersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` mood_diary_diaryusers from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` mood_diary_diaryusers.\n     */\n    skip?: number\n    distinct?: Mood_diary_diaryusersScalarFieldEnum | Mood_diary_diaryusersScalarFieldEnum[]\n  }\n\n  /**\n   * mood_diary_diaryusers create\n   */\n  export type mood_diary_diaryusersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_diaryusersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a mood_diary_diaryusers.\n     */\n    data: XOR<mood_diary_diaryusersCreateInput, mood_diary_diaryusersUncheckedCreateInput>\n  }\n\n  /**\n   * mood_diary_diaryusers createMany\n   */\n  export type mood_diary_diaryusersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many mood_diary_diaryusers.\n     */\n    data: mood_diary_diaryusersCreateManyInput | mood_diary_diaryusersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * mood_diary_diaryusers createManyAndReturn\n   */\n  export type mood_diary_diaryusersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * The data used to create many mood_diary_diaryusers.\n     */\n    data: mood_diary_diaryusersCreateManyInput | mood_diary_diaryusersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * mood_diary_diaryusers update\n   */\n  export type mood_diary_diaryusersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_diaryusersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a mood_diary_diaryusers.\n     */\n    data: XOR<mood_diary_diaryusersUpdateInput, mood_diary_diaryusersUncheckedUpdateInput>\n    /**\n     * Choose, which mood_diary_diaryusers to update.\n     */\n    where: mood_diary_diaryusersWhereUniqueInput\n  }\n\n  /**\n   * mood_diary_diaryusers updateMany\n   */\n  export type mood_diary_diaryusersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update mood_diary_diaryusers.\n     */\n    data: XOR<mood_diary_diaryusersUpdateManyMutationInput, mood_diary_diaryusersUncheckedUpdateManyInput>\n    /**\n     * Filter which mood_diary_diaryusers to update\n     */\n    where?: mood_diary_diaryusersWhereInput\n    /**\n     * Limit how many mood_diary_diaryusers to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * mood_diary_diaryusers updateManyAndReturn\n   */\n  export type mood_diary_diaryusersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * The data used to update mood_diary_diaryusers.\n     */\n    data: XOR<mood_diary_diaryusersUpdateManyMutationInput, mood_diary_diaryusersUncheckedUpdateManyInput>\n    /**\n     * Filter which mood_diary_diaryusers to update\n     */\n    where?: mood_diary_diaryusersWhereInput\n    /**\n     * Limit how many mood_diary_diaryusers to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * mood_diary_diaryusers upsert\n   */\n  export type mood_diary_diaryusersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_diaryusersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the mood_diary_diaryusers to update in case it exists.\n     */\n    where: mood_diary_diaryusersWhereUniqueInput\n    /**\n     * In case the mood_diary_diaryusers found by the `where` argument doesn't exist, create a new mood_diary_diaryusers with this data.\n     */\n    create: XOR<mood_diary_diaryusersCreateInput, mood_diary_diaryusersUncheckedCreateInput>\n    /**\n     * In case the mood_diary_diaryusers was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<mood_diary_diaryusersUpdateInput, mood_diary_diaryusersUncheckedUpdateInput>\n  }\n\n  /**\n   * mood_diary_diaryusers delete\n   */\n  export type mood_diary_diaryusersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_diaryusersInclude<ExtArgs> | null\n    /**\n     * Filter which mood_diary_diaryusers to delete.\n     */\n    where: mood_diary_diaryusersWhereUniqueInput\n  }\n\n  /**\n   * mood_diary_diaryusers deleteMany\n   */\n  export type mood_diary_diaryusersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which mood_diary_diaryusers to delete\n     */\n    where?: mood_diary_diaryusersWhereInput\n    /**\n     * Limit how many mood_diary_diaryusers to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * mood_diary_diaryusers.mood_diary_mood_entries\n   */\n  export type mood_diary_diaryusers$mood_diary_mood_entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n    where?: mood_diary_mood_entriesWhereInput\n    orderBy?: mood_diary_mood_entriesOrderByWithRelationInput | mood_diary_mood_entriesOrderByWithRelationInput[]\n    cursor?: mood_diary_mood_entriesWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Mood_diary_mood_entriesScalarFieldEnum | Mood_diary_mood_entriesScalarFieldEnum[]\n  }\n\n  /**\n   * mood_diary_diaryusers without action\n   */\n  export type mood_diary_diaryusersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_diaryusers\n     */\n    select?: mood_diary_diaryusersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_diaryusers\n     */\n    omit?: mood_diary_diaryusersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_diaryusersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model mood_diary_mood_entries\n   */\n\n  export type AggregateMood_diary_mood_entries = {\n    _count: Mood_diary_mood_entriesCountAggregateOutputType | null\n    _min: Mood_diary_mood_entriesMinAggregateOutputType | null\n    _max: Mood_diary_mood_entriesMaxAggregateOutputType | null\n  }\n\n  export type Mood_diary_mood_entriesMinAggregateOutputType = {\n    id: string | null\n    mood_diary_diaryuser_id: string | null\n    mood_type: string | null\n    note: string | null\n    created_at: Date | null\n    archived: boolean | null\n  }\n\n  export type Mood_diary_mood_entriesMaxAggregateOutputType = {\n    id: string | null\n    mood_diary_diaryuser_id: string | null\n    mood_type: string | null\n    note: string | null\n    created_at: Date | null\n    archived: boolean | null\n  }\n\n  export type Mood_diary_mood_entriesCountAggregateOutputType = {\n    id: number\n    mood_diary_diaryuser_id: number\n    mood_type: number\n    note: number\n    created_at: number\n    archived: number\n    _all: number\n  }\n\n\n  export type Mood_diary_mood_entriesMinAggregateInputType = {\n    id?: true\n    mood_diary_diaryuser_id?: true\n    mood_type?: true\n    note?: true\n    created_at?: true\n    archived?: true\n  }\n\n  export type Mood_diary_mood_entriesMaxAggregateInputType = {\n    id?: true\n    mood_diary_diaryuser_id?: true\n    mood_type?: true\n    note?: true\n    created_at?: true\n    archived?: true\n  }\n\n  export type Mood_diary_mood_entriesCountAggregateInputType = {\n    id?: true\n    mood_diary_diaryuser_id?: true\n    mood_type?: true\n    note?: true\n    created_at?: true\n    archived?: true\n    _all?: true\n  }\n\n  export type Mood_diary_mood_entriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which mood_diary_mood_entries to aggregate.\n     */\n    where?: mood_diary_mood_entriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of mood_diary_mood_entries to fetch.\n     */\n    orderBy?: mood_diary_mood_entriesOrderByWithRelationInput | mood_diary_mood_entriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: mood_diary_mood_entriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` mood_diary_mood_entries from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` mood_diary_mood_entries.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned mood_diary_mood_entries\n    **/\n    _count?: true | Mood_diary_mood_entriesCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Mood_diary_mood_entriesMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Mood_diary_mood_entriesMaxAggregateInputType\n  }\n\n  export type GetMood_diary_mood_entriesAggregateType<T extends Mood_diary_mood_entriesAggregateArgs> = {\n        [P in keyof T & keyof AggregateMood_diary_mood_entries]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateMood_diary_mood_entries[P]>\n      : GetScalarType<T[P], AggregateMood_diary_mood_entries[P]>\n  }\n\n\n\n\n  export type mood_diary_mood_entriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: mood_diary_mood_entriesWhereInput\n    orderBy?: mood_diary_mood_entriesOrderByWithAggregationInput | mood_diary_mood_entriesOrderByWithAggregationInput[]\n    by: Mood_diary_mood_entriesScalarFieldEnum[] | Mood_diary_mood_entriesScalarFieldEnum\n    having?: mood_diary_mood_entriesScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Mood_diary_mood_entriesCountAggregateInputType | true\n    _min?: Mood_diary_mood_entriesMinAggregateInputType\n    _max?: Mood_diary_mood_entriesMaxAggregateInputType\n  }\n\n  export type Mood_diary_mood_entriesGroupByOutputType = {\n    id: string\n    mood_diary_diaryuser_id: string\n    mood_type: string\n    note: string | null\n    created_at: Date\n    archived: boolean\n    _count: Mood_diary_mood_entriesCountAggregateOutputType | null\n    _min: Mood_diary_mood_entriesMinAggregateOutputType | null\n    _max: Mood_diary_mood_entriesMaxAggregateOutputType | null\n  }\n\n  type GetMood_diary_mood_entriesGroupByPayload<T extends mood_diary_mood_entriesGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Mood_diary_mood_entriesGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Mood_diary_mood_entriesGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Mood_diary_mood_entriesGroupByOutputType[P]>\n            : GetScalarType<T[P], Mood_diary_mood_entriesGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type mood_diary_mood_entriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    mood_diary_diaryuser_id?: boolean\n    mood_type?: boolean\n    note?: boolean\n    created_at?: boolean\n    archived?: boolean\n    diaryUser?: boolean | mood_diary_diaryusersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"mood_diary_mood_entries\"]>\n\n  export type mood_diary_mood_entriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    mood_diary_diaryuser_id?: boolean\n    mood_type?: boolean\n    note?: boolean\n    created_at?: boolean\n    archived?: boolean\n    diaryUser?: boolean | mood_diary_diaryusersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"mood_diary_mood_entries\"]>\n\n  export type mood_diary_mood_entriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    mood_diary_diaryuser_id?: boolean\n    mood_type?: boolean\n    note?: boolean\n    created_at?: boolean\n    archived?: boolean\n    diaryUser?: boolean | mood_diary_diaryusersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"mood_diary_mood_entries\"]>\n\n  export type mood_diary_mood_entriesSelectScalar = {\n    id?: boolean\n    mood_diary_diaryuser_id?: boolean\n    mood_type?: boolean\n    note?: boolean\n    created_at?: boolean\n    archived?: boolean\n  }\n\n  export type mood_diary_mood_entriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"mood_diary_diaryuser_id\" | \"mood_type\" | \"note\" | \"created_at\" | \"archived\", ExtArgs[\"result\"][\"mood_diary_mood_entries\"]>\n  export type mood_diary_mood_entriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    diaryUser?: boolean | mood_diary_diaryusersDefaultArgs<ExtArgs>\n  }\n  export type mood_diary_mood_entriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    diaryUser?: boolean | mood_diary_diaryusersDefaultArgs<ExtArgs>\n  }\n  export type mood_diary_mood_entriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    diaryUser?: boolean | mood_diary_diaryusersDefaultArgs<ExtArgs>\n  }\n\n  export type $mood_diary_mood_entriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"mood_diary_mood_entries\"\n    objects: {\n      diaryUser: Prisma.$mood_diary_diaryusersPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * References the logical mood diary user. {@link mood_diary_diaryusers.id}.\n       */\n      mood_diary_diaryuser_id: string\n      /**\n       * Mood type selected for this entry, must be one of: happy, sad, anxious,\n       * excited, angry, calm, stressed, tired. Enforced via application logic.\n       */\n      mood_type: string\n      /**\n       * Optional freeform note for this entry, max 500 Unicode characters. May be\n       * blank or null.\n       */\n      note: string | null\n      /**\n       * Timestamp when this entry was created (auto-set, UTC, immutable, used for\n       * archiving and queries).\n       */\n      created_at: Date\n      /**\n       * Indicates if this entry has been archived (i.e., older than 30 days, as\n       * determined by background process). Archived entries are hidden from\n       * listings/statistics.\n       */\n      archived: boolean\n    }, ExtArgs[\"result\"][\"mood_diary_mood_entries\"]>\n    composites: {}\n  }\n\n  type mood_diary_mood_entriesGetPayload<S extends boolean | null | undefined | mood_diary_mood_entriesDefaultArgs> = $Result.GetResult<Prisma.$mood_diary_mood_entriesPayload, S>\n\n  type mood_diary_mood_entriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<mood_diary_mood_entriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Mood_diary_mood_entriesCountAggregateInputType | true\n    }\n\n  export interface mood_diary_mood_entriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mood_diary_mood_entries'], meta: { name: 'mood_diary_mood_entries' } }\n    /**\n     * Find zero or one Mood_diary_mood_entries that matches the filter.\n     * @param {mood_diary_mood_entriesFindUniqueArgs} args - Arguments to find a Mood_diary_mood_entries\n     * @example\n     * // Get one Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends mood_diary_mood_entriesFindUniqueArgs>(args: SelectSubset<T, mood_diary_mood_entriesFindUniqueArgs<ExtArgs>>): Prisma__mood_diary_mood_entriesClient<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Mood_diary_mood_entries that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {mood_diary_mood_entriesFindUniqueOrThrowArgs} args - Arguments to find a Mood_diary_mood_entries\n     * @example\n     * // Get one Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends mood_diary_mood_entriesFindUniqueOrThrowArgs>(args: SelectSubset<T, mood_diary_mood_entriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mood_diary_mood_entriesClient<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Mood_diary_mood_entries that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_mood_entriesFindFirstArgs} args - Arguments to find a Mood_diary_mood_entries\n     * @example\n     * // Get one Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends mood_diary_mood_entriesFindFirstArgs>(args?: SelectSubset<T, mood_diary_mood_entriesFindFirstArgs<ExtArgs>>): Prisma__mood_diary_mood_entriesClient<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Mood_diary_mood_entries that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_mood_entriesFindFirstOrThrowArgs} args - Arguments to find a Mood_diary_mood_entries\n     * @example\n     * // Get one Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends mood_diary_mood_entriesFindFirstOrThrowArgs>(args?: SelectSubset<T, mood_diary_mood_entriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__mood_diary_mood_entriesClient<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Mood_diary_mood_entries that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_mood_entriesFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.findMany()\n     * \n     * // Get first 10 Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const mood_diary_mood_entriesWithIdOnly = await prisma.mood_diary_mood_entries.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends mood_diary_mood_entriesFindManyArgs>(args?: SelectSubset<T, mood_diary_mood_entriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Mood_diary_mood_entries.\n     * @param {mood_diary_mood_entriesCreateArgs} args - Arguments to create a Mood_diary_mood_entries.\n     * @example\n     * // Create one Mood_diary_mood_entries\n     * const Mood_diary_mood_entries = await prisma.mood_diary_mood_entries.create({\n     *   data: {\n     *     // ... data to create a Mood_diary_mood_entries\n     *   }\n     * })\n     * \n     */\n    create<T extends mood_diary_mood_entriesCreateArgs>(args: SelectSubset<T, mood_diary_mood_entriesCreateArgs<ExtArgs>>): Prisma__mood_diary_mood_entriesClient<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Mood_diary_mood_entries.\n     * @param {mood_diary_mood_entriesCreateManyArgs} args - Arguments to create many Mood_diary_mood_entries.\n     * @example\n     * // Create many Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends mood_diary_mood_entriesCreateManyArgs>(args?: SelectSubset<T, mood_diary_mood_entriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Mood_diary_mood_entries and returns the data saved in the database.\n     * @param {mood_diary_mood_entriesCreateManyAndReturnArgs} args - Arguments to create many Mood_diary_mood_entries.\n     * @example\n     * // Create many Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Mood_diary_mood_entries and only return the `id`\n     * const mood_diary_mood_entriesWithIdOnly = await prisma.mood_diary_mood_entries.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends mood_diary_mood_entriesCreateManyAndReturnArgs>(args?: SelectSubset<T, mood_diary_mood_entriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Mood_diary_mood_entries.\n     * @param {mood_diary_mood_entriesDeleteArgs} args - Arguments to delete one Mood_diary_mood_entries.\n     * @example\n     * // Delete one Mood_diary_mood_entries\n     * const Mood_diary_mood_entries = await prisma.mood_diary_mood_entries.delete({\n     *   where: {\n     *     // ... filter to delete one Mood_diary_mood_entries\n     *   }\n     * })\n     * \n     */\n    delete<T extends mood_diary_mood_entriesDeleteArgs>(args: SelectSubset<T, mood_diary_mood_entriesDeleteArgs<ExtArgs>>): Prisma__mood_diary_mood_entriesClient<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Mood_diary_mood_entries.\n     * @param {mood_diary_mood_entriesUpdateArgs} args - Arguments to update one Mood_diary_mood_entries.\n     * @example\n     * // Update one Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends mood_diary_mood_entriesUpdateArgs>(args: SelectSubset<T, mood_diary_mood_entriesUpdateArgs<ExtArgs>>): Prisma__mood_diary_mood_entriesClient<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Mood_diary_mood_entries.\n     * @param {mood_diary_mood_entriesDeleteManyArgs} args - Arguments to filter Mood_diary_mood_entries to delete.\n     * @example\n     * // Delete a few Mood_diary_mood_entries\n     * const { count } = await prisma.mood_diary_mood_entries.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends mood_diary_mood_entriesDeleteManyArgs>(args?: SelectSubset<T, mood_diary_mood_entriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Mood_diary_mood_entries.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_mood_entriesUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends mood_diary_mood_entriesUpdateManyArgs>(args: SelectSubset<T, mood_diary_mood_entriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Mood_diary_mood_entries and returns the data updated in the database.\n     * @param {mood_diary_mood_entriesUpdateManyAndReturnArgs} args - Arguments to update many Mood_diary_mood_entries.\n     * @example\n     * // Update many Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Mood_diary_mood_entries and only return the `id`\n     * const mood_diary_mood_entriesWithIdOnly = await prisma.mood_diary_mood_entries.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends mood_diary_mood_entriesUpdateManyAndReturnArgs>(args: SelectSubset<T, mood_diary_mood_entriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Mood_diary_mood_entries.\n     * @param {mood_diary_mood_entriesUpsertArgs} args - Arguments to update or create a Mood_diary_mood_entries.\n     * @example\n     * // Update or create a Mood_diary_mood_entries\n     * const mood_diary_mood_entries = await prisma.mood_diary_mood_entries.upsert({\n     *   create: {\n     *     // ... data to create a Mood_diary_mood_entries\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Mood_diary_mood_entries we want to update\n     *   }\n     * })\n     */\n    upsert<T extends mood_diary_mood_entriesUpsertArgs>(args: SelectSubset<T, mood_diary_mood_entriesUpsertArgs<ExtArgs>>): Prisma__mood_diary_mood_entriesClient<$Result.GetResult<Prisma.$mood_diary_mood_entriesPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Mood_diary_mood_entries.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_mood_entriesCountArgs} args - Arguments to filter Mood_diary_mood_entries to count.\n     * @example\n     * // Count the number of Mood_diary_mood_entries\n     * const count = await prisma.mood_diary_mood_entries.count({\n     *   where: {\n     *     // ... the filter for the Mood_diary_mood_entries we want to count\n     *   }\n     * })\n    **/\n    count<T extends mood_diary_mood_entriesCountArgs>(\n      args?: Subset<T, mood_diary_mood_entriesCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Mood_diary_mood_entriesCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Mood_diary_mood_entries.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Mood_diary_mood_entriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Mood_diary_mood_entriesAggregateArgs>(args: Subset<T, Mood_diary_mood_entriesAggregateArgs>): Prisma.PrismaPromise<GetMood_diary_mood_entriesAggregateType<T>>\n\n    /**\n     * Group by Mood_diary_mood_entries.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {mood_diary_mood_entriesGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends mood_diary_mood_entriesGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: mood_diary_mood_entriesGroupByArgs['orderBy'] }\n        : { orderBy?: mood_diary_mood_entriesGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, mood_diary_mood_entriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMood_diary_mood_entriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the mood_diary_mood_entries model\n   */\n  readonly fields: mood_diary_mood_entriesFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for mood_diary_mood_entries.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__mood_diary_mood_entriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    diaryUser<T extends mood_diary_diaryusersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, mood_diary_diaryusersDefaultArgs<ExtArgs>>): Prisma__mood_diary_diaryusersClient<$Result.GetResult<Prisma.$mood_diary_diaryusersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the mood_diary_mood_entries model\n   */\n  interface mood_diary_mood_entriesFieldRefs {\n    readonly id: FieldRef<\"mood_diary_mood_entries\", 'String'>\n    readonly mood_diary_diaryuser_id: FieldRef<\"mood_diary_mood_entries\", 'String'>\n    readonly mood_type: FieldRef<\"mood_diary_mood_entries\", 'String'>\n    readonly note: FieldRef<\"mood_diary_mood_entries\", 'String'>\n    readonly created_at: FieldRef<\"mood_diary_mood_entries\", 'DateTime'>\n    readonly archived: FieldRef<\"mood_diary_mood_entries\", 'Boolean'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * mood_diary_mood_entries findUnique\n   */\n  export type mood_diary_mood_entriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n    /**\n     * Filter, which mood_diary_mood_entries to fetch.\n     */\n    where: mood_diary_mood_entriesWhereUniqueInput\n  }\n\n  /**\n   * mood_diary_mood_entries findUniqueOrThrow\n   */\n  export type mood_diary_mood_entriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n    /**\n     * Filter, which mood_diary_mood_entries to fetch.\n     */\n    where: mood_diary_mood_entriesWhereUniqueInput\n  }\n\n  /**\n   * mood_diary_mood_entries findFirst\n   */\n  export type mood_diary_mood_entriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n    /**\n     * Filter, which mood_diary_mood_entries to fetch.\n     */\n    where?: mood_diary_mood_entriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of mood_diary_mood_entries to fetch.\n     */\n    orderBy?: mood_diary_mood_entriesOrderByWithRelationInput | mood_diary_mood_entriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for mood_diary_mood_entries.\n     */\n    cursor?: mood_diary_mood_entriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` mood_diary_mood_entries from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` mood_diary_mood_entries.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of mood_diary_mood_entries.\n     */\n    distinct?: Mood_diary_mood_entriesScalarFieldEnum | Mood_diary_mood_entriesScalarFieldEnum[]\n  }\n\n  /**\n   * mood_diary_mood_entries findFirstOrThrow\n   */\n  export type mood_diary_mood_entriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n    /**\n     * Filter, which mood_diary_mood_entries to fetch.\n     */\n    where?: mood_diary_mood_entriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of mood_diary_mood_entries to fetch.\n     */\n    orderBy?: mood_diary_mood_entriesOrderByWithRelationInput | mood_diary_mood_entriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for mood_diary_mood_entries.\n     */\n    cursor?: mood_diary_mood_entriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` mood_diary_mood_entries from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` mood_diary_mood_entries.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of mood_diary_mood_entries.\n     */\n    distinct?: Mood_diary_mood_entriesScalarFieldEnum | Mood_diary_mood_entriesScalarFieldEnum[]\n  }\n\n  /**\n   * mood_diary_mood_entries findMany\n   */\n  export type mood_diary_mood_entriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n    /**\n     * Filter, which mood_diary_mood_entries to fetch.\n     */\n    where?: mood_diary_mood_entriesWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of mood_diary_mood_entries to fetch.\n     */\n    orderBy?: mood_diary_mood_entriesOrderByWithRelationInput | mood_diary_mood_entriesOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing mood_diary_mood_entries.\n     */\n    cursor?: mood_diary_mood_entriesWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` mood_diary_mood_entries from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` mood_diary_mood_entries.\n     */\n    skip?: number\n    distinct?: Mood_diary_mood_entriesScalarFieldEnum | Mood_diary_mood_entriesScalarFieldEnum[]\n  }\n\n  /**\n   * mood_diary_mood_entries create\n   */\n  export type mood_diary_mood_entriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n    /**\n     * The data needed to create a mood_diary_mood_entries.\n     */\n    data: XOR<mood_diary_mood_entriesCreateInput, mood_diary_mood_entriesUncheckedCreateInput>\n  }\n\n  /**\n   * mood_diary_mood_entries createMany\n   */\n  export type mood_diary_mood_entriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many mood_diary_mood_entries.\n     */\n    data: mood_diary_mood_entriesCreateManyInput | mood_diary_mood_entriesCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * mood_diary_mood_entries createManyAndReturn\n   */\n  export type mood_diary_mood_entriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * The data used to create many mood_diary_mood_entries.\n     */\n    data: mood_diary_mood_entriesCreateManyInput | mood_diary_mood_entriesCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * mood_diary_mood_entries update\n   */\n  export type mood_diary_mood_entriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n    /**\n     * The data needed to update a mood_diary_mood_entries.\n     */\n    data: XOR<mood_diary_mood_entriesUpdateInput, mood_diary_mood_entriesUncheckedUpdateInput>\n    /**\n     * Choose, which mood_diary_mood_entries to update.\n     */\n    where: mood_diary_mood_entriesWhereUniqueInput\n  }\n\n  /**\n   * mood_diary_mood_entries updateMany\n   */\n  export type mood_diary_mood_entriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update mood_diary_mood_entries.\n     */\n    data: XOR<mood_diary_mood_entriesUpdateManyMutationInput, mood_diary_mood_entriesUncheckedUpdateManyInput>\n    /**\n     * Filter which mood_diary_mood_entries to update\n     */\n    where?: mood_diary_mood_entriesWhereInput\n    /**\n     * Limit how many mood_diary_mood_entries to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * mood_diary_mood_entries updateManyAndReturn\n   */\n  export type mood_diary_mood_entriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * The data used to update mood_diary_mood_entries.\n     */\n    data: XOR<mood_diary_mood_entriesUpdateManyMutationInput, mood_diary_mood_entriesUncheckedUpdateManyInput>\n    /**\n     * Filter which mood_diary_mood_entries to update\n     */\n    where?: mood_diary_mood_entriesWhereInput\n    /**\n     * Limit how many mood_diary_mood_entries to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * mood_diary_mood_entries upsert\n   */\n  export type mood_diary_mood_entriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n    /**\n     * The filter to search for the mood_diary_mood_entries to update in case it exists.\n     */\n    where: mood_diary_mood_entriesWhereUniqueInput\n    /**\n     * In case the mood_diary_mood_entries found by the `where` argument doesn't exist, create a new mood_diary_mood_entries with this data.\n     */\n    create: XOR<mood_diary_mood_entriesCreateInput, mood_diary_mood_entriesUncheckedCreateInput>\n    /**\n     * In case the mood_diary_mood_entries was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<mood_diary_mood_entriesUpdateInput, mood_diary_mood_entriesUncheckedUpdateInput>\n  }\n\n  /**\n   * mood_diary_mood_entries delete\n   */\n  export type mood_diary_mood_entriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n    /**\n     * Filter which mood_diary_mood_entries to delete.\n     */\n    where: mood_diary_mood_entriesWhereUniqueInput\n  }\n\n  /**\n   * mood_diary_mood_entries deleteMany\n   */\n  export type mood_diary_mood_entriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which mood_diary_mood_entries to delete\n     */\n    where?: mood_diary_mood_entriesWhereInput\n    /**\n     * Limit how many mood_diary_mood_entries to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * mood_diary_mood_entries without action\n   */\n  export type mood_diary_mood_entriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the mood_diary_mood_entries\n     */\n    select?: mood_diary_mood_entriesSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the mood_diary_mood_entries\n     */\n    omit?: mood_diary_mood_entriesOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: mood_diary_mood_entriesInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const Mood_diary_diaryusersScalarFieldEnum: {\n    id: 'id',\n    created_at: 'created_at'\n  };\n\n  export type Mood_diary_diaryusersScalarFieldEnum = (typeof Mood_diary_diaryusersScalarFieldEnum)[keyof typeof Mood_diary_diaryusersScalarFieldEnum]\n\n\n  export const Mood_diary_mood_entriesScalarFieldEnum: {\n    id: 'id',\n    mood_diary_diaryuser_id: 'mood_diary_diaryuser_id',\n    mood_type: 'mood_type',\n    note: 'note',\n    created_at: 'created_at',\n    archived: 'archived'\n  };\n\n  export type Mood_diary_mood_entriesScalarFieldEnum = (typeof Mood_diary_mood_entriesScalarFieldEnum)[keyof typeof Mood_diary_mood_entriesScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Boolean'\n   */\n  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type mood_diary_diaryusersWhereInput = {\n    AND?: mood_diary_diaryusersWhereInput | mood_diary_diaryusersWhereInput[]\n    OR?: mood_diary_diaryusersWhereInput[]\n    NOT?: mood_diary_diaryusersWhereInput | mood_diary_diaryusersWhereInput[]\n    id?: UuidFilter<\"mood_diary_diaryusers\"> | string\n    created_at?: DateTimeFilter<\"mood_diary_diaryusers\"> | Date | string\n    mood_diary_mood_entries?: Mood_diary_mood_entriesListRelationFilter\n  }\n\n  export type mood_diary_diaryusersOrderByWithRelationInput = {\n    id?: SortOrder\n    created_at?: SortOrder\n    mood_diary_mood_entries?: mood_diary_mood_entriesOrderByRelationAggregateInput\n  }\n\n  export type mood_diary_diaryusersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: mood_diary_diaryusersWhereInput | mood_diary_diaryusersWhereInput[]\n    OR?: mood_diary_diaryusersWhereInput[]\n    NOT?: mood_diary_diaryusersWhereInput | mood_diary_diaryusersWhereInput[]\n    created_at?: DateTimeFilter<\"mood_diary_diaryusers\"> | Date | string\n    mood_diary_mood_entries?: Mood_diary_mood_entriesListRelationFilter\n  }, \"id\">\n\n  export type mood_diary_diaryusersOrderByWithAggregationInput = {\n    id?: SortOrder\n    created_at?: SortOrder\n    _count?: mood_diary_diaryusersCountOrderByAggregateInput\n    _max?: mood_diary_diaryusersMaxOrderByAggregateInput\n    _min?: mood_diary_diaryusersMinOrderByAggregateInput\n  }\n\n  export type mood_diary_diaryusersScalarWhereWithAggregatesInput = {\n    AND?: mood_diary_diaryusersScalarWhereWithAggregatesInput | mood_diary_diaryusersScalarWhereWithAggregatesInput[]\n    OR?: mood_diary_diaryusersScalarWhereWithAggregatesInput[]\n    NOT?: mood_diary_diaryusersScalarWhereWithAggregatesInput | mood_diary_diaryusersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"mood_diary_diaryusers\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"mood_diary_diaryusers\"> | Date | string\n  }\n\n  export type mood_diary_mood_entriesWhereInput = {\n    AND?: mood_diary_mood_entriesWhereInput | mood_diary_mood_entriesWhereInput[]\n    OR?: mood_diary_mood_entriesWhereInput[]\n    NOT?: mood_diary_mood_entriesWhereInput | mood_diary_mood_entriesWhereInput[]\n    id?: UuidFilter<\"mood_diary_mood_entries\"> | string\n    mood_diary_diaryuser_id?: UuidFilter<\"mood_diary_mood_entries\"> | string\n    mood_type?: StringFilter<\"mood_diary_mood_entries\"> | string\n    note?: StringNullableFilter<\"mood_diary_mood_entries\"> | string | null\n    created_at?: DateTimeFilter<\"mood_diary_mood_entries\"> | Date | string\n    archived?: BoolFilter<\"mood_diary_mood_entries\"> | boolean\n    diaryUser?: XOR<Mood_diary_diaryusersScalarRelationFilter, mood_diary_diaryusersWhereInput>\n  }\n\n  export type mood_diary_mood_entriesOrderByWithRelationInput = {\n    id?: SortOrder\n    mood_diary_diaryuser_id?: SortOrder\n    mood_type?: SortOrder\n    note?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    archived?: SortOrder\n    diaryUser?: mood_diary_diaryusersOrderByWithRelationInput\n  }\n\n  export type mood_diary_mood_entriesWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: mood_diary_mood_entriesWhereInput | mood_diary_mood_entriesWhereInput[]\n    OR?: mood_diary_mood_entriesWhereInput[]\n    NOT?: mood_diary_mood_entriesWhereInput | mood_diary_mood_entriesWhereInput[]\n    mood_diary_diaryuser_id?: UuidFilter<\"mood_diary_mood_entries\"> | string\n    mood_type?: StringFilter<\"mood_diary_mood_entries\"> | string\n    note?: StringNullableFilter<\"mood_diary_mood_entries\"> | string | null\n    created_at?: DateTimeFilter<\"mood_diary_mood_entries\"> | Date | string\n    archived?: BoolFilter<\"mood_diary_mood_entries\"> | boolean\n    diaryUser?: XOR<Mood_diary_diaryusersScalarRelationFilter, mood_diary_diaryusersWhereInput>\n  }, \"id\">\n\n  export type mood_diary_mood_entriesOrderByWithAggregationInput = {\n    id?: SortOrder\n    mood_diary_diaryuser_id?: SortOrder\n    mood_type?: SortOrder\n    note?: SortOrderInput | SortOrder\n    created_at?: SortOrder\n    archived?: SortOrder\n    _count?: mood_diary_mood_entriesCountOrderByAggregateInput\n    _max?: mood_diary_mood_entriesMaxOrderByAggregateInput\n    _min?: mood_diary_mood_entriesMinOrderByAggregateInput\n  }\n\n  export type mood_diary_mood_entriesScalarWhereWithAggregatesInput = {\n    AND?: mood_diary_mood_entriesScalarWhereWithAggregatesInput | mood_diary_mood_entriesScalarWhereWithAggregatesInput[]\n    OR?: mood_diary_mood_entriesScalarWhereWithAggregatesInput[]\n    NOT?: mood_diary_mood_entriesScalarWhereWithAggregatesInput | mood_diary_mood_entriesScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"mood_diary_mood_entries\"> | string\n    mood_diary_diaryuser_id?: UuidWithAggregatesFilter<\"mood_diary_mood_entries\"> | string\n    mood_type?: StringWithAggregatesFilter<\"mood_diary_mood_entries\"> | string\n    note?: StringNullableWithAggregatesFilter<\"mood_diary_mood_entries\"> | string | null\n    created_at?: DateTimeWithAggregatesFilter<\"mood_diary_mood_entries\"> | Date | string\n    archived?: BoolWithAggregatesFilter<\"mood_diary_mood_entries\"> | boolean\n  }\n\n  export type mood_diary_diaryusersCreateInput = {\n    id: string\n    created_at: Date | string\n    mood_diary_mood_entries?: mood_diary_mood_entriesCreateNestedManyWithoutDiaryUserInput\n  }\n\n  export type mood_diary_diaryusersUncheckedCreateInput = {\n    id: string\n    created_at: Date | string\n    mood_diary_mood_entries?: mood_diary_mood_entriesUncheckedCreateNestedManyWithoutDiaryUserInput\n  }\n\n  export type mood_diary_diaryusersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    mood_diary_mood_entries?: mood_diary_mood_entriesUpdateManyWithoutDiaryUserNestedInput\n  }\n\n  export type mood_diary_diaryusersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    mood_diary_mood_entries?: mood_diary_mood_entriesUncheckedUpdateManyWithoutDiaryUserNestedInput\n  }\n\n  export type mood_diary_diaryusersCreateManyInput = {\n    id: string\n    created_at: Date | string\n  }\n\n  export type mood_diary_diaryusersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type mood_diary_diaryusersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type mood_diary_mood_entriesCreateInput = {\n    id: string\n    mood_type: string\n    note?: string | null\n    created_at: Date | string\n    archived: boolean\n    diaryUser: mood_diary_diaryusersCreateNestedOneWithoutMood_diary_mood_entriesInput\n  }\n\n  export type mood_diary_mood_entriesUncheckedCreateInput = {\n    id: string\n    mood_diary_diaryuser_id: string\n    mood_type: string\n    note?: string | null\n    created_at: Date | string\n    archived: boolean\n  }\n\n  export type mood_diary_mood_entriesUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    mood_type?: StringFieldUpdateOperationsInput | string\n    note?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    archived?: BoolFieldUpdateOperationsInput | boolean\n    diaryUser?: mood_diary_diaryusersUpdateOneRequiredWithoutMood_diary_mood_entriesNestedInput\n  }\n\n  export type mood_diary_mood_entriesUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    mood_diary_diaryuser_id?: StringFieldUpdateOperationsInput | string\n    mood_type?: StringFieldUpdateOperationsInput | string\n    note?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    archived?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type mood_diary_mood_entriesCreateManyInput = {\n    id: string\n    mood_diary_diaryuser_id: string\n    mood_type: string\n    note?: string | null\n    created_at: Date | string\n    archived: boolean\n  }\n\n  export type mood_diary_mood_entriesUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    mood_type?: StringFieldUpdateOperationsInput | string\n    note?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    archived?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type mood_diary_mood_entriesUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    mood_diary_diaryuser_id?: StringFieldUpdateOperationsInput | string\n    mood_type?: StringFieldUpdateOperationsInput | string\n    note?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    archived?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type Mood_diary_mood_entriesListRelationFilter = {\n    every?: mood_diary_mood_entriesWhereInput\n    some?: mood_diary_mood_entriesWhereInput\n    none?: mood_diary_mood_entriesWhereInput\n  }\n\n  export type mood_diary_mood_entriesOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type mood_diary_diaryusersCountOrderByAggregateInput = {\n    id?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type mood_diary_diaryusersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type mood_diary_diaryusersMinOrderByAggregateInput = {\n    id?: SortOrder\n    created_at?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type StringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type BoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type Mood_diary_diaryusersScalarRelationFilter = {\n    is?: mood_diary_diaryusersWhereInput\n    isNot?: mood_diary_diaryusersWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type mood_diary_mood_entriesCountOrderByAggregateInput = {\n    id?: SortOrder\n    mood_diary_diaryuser_id?: SortOrder\n    mood_type?: SortOrder\n    note?: SortOrder\n    created_at?: SortOrder\n    archived?: SortOrder\n  }\n\n  export type mood_diary_mood_entriesMaxOrderByAggregateInput = {\n    id?: SortOrder\n    mood_diary_diaryuser_id?: SortOrder\n    mood_type?: SortOrder\n    note?: SortOrder\n    created_at?: SortOrder\n    archived?: SortOrder\n  }\n\n  export type mood_diary_mood_entriesMinOrderByAggregateInput = {\n    id?: SortOrder\n    mood_diary_diaryuser_id?: SortOrder\n    mood_type?: SortOrder\n    note?: SortOrder\n    created_at?: SortOrder\n    archived?: SortOrder\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type BoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type mood_diary_mood_entriesCreateNestedManyWithoutDiaryUserInput = {\n    create?: XOR<mood_diary_mood_entriesCreateWithoutDiaryUserInput, mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput> | mood_diary_mood_entriesCreateWithoutDiaryUserInput[] | mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput[]\n    connectOrCreate?: mood_diary_mood_entriesCreateOrConnectWithoutDiaryUserInput | mood_diary_mood_entriesCreateOrConnectWithoutDiaryUserInput[]\n    createMany?: mood_diary_mood_entriesCreateManyDiaryUserInputEnvelope\n    connect?: mood_diary_mood_entriesWhereUniqueInput | mood_diary_mood_entriesWhereUniqueInput[]\n  }\n\n  export type mood_diary_mood_entriesUncheckedCreateNestedManyWithoutDiaryUserInput = {\n    create?: XOR<mood_diary_mood_entriesCreateWithoutDiaryUserInput, mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput> | mood_diary_mood_entriesCreateWithoutDiaryUserInput[] | mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput[]\n    connectOrCreate?: mood_diary_mood_entriesCreateOrConnectWithoutDiaryUserInput | mood_diary_mood_entriesCreateOrConnectWithoutDiaryUserInput[]\n    createMany?: mood_diary_mood_entriesCreateManyDiaryUserInputEnvelope\n    connect?: mood_diary_mood_entriesWhereUniqueInput | mood_diary_mood_entriesWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type mood_diary_mood_entriesUpdateManyWithoutDiaryUserNestedInput = {\n    create?: XOR<mood_diary_mood_entriesCreateWithoutDiaryUserInput, mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput> | mood_diary_mood_entriesCreateWithoutDiaryUserInput[] | mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput[]\n    connectOrCreate?: mood_diary_mood_entriesCreateOrConnectWithoutDiaryUserInput | mood_diary_mood_entriesCreateOrConnectWithoutDiaryUserInput[]\n    upsert?: mood_diary_mood_entriesUpsertWithWhereUniqueWithoutDiaryUserInput | mood_diary_mood_entriesUpsertWithWhereUniqueWithoutDiaryUserInput[]\n    createMany?: mood_diary_mood_entriesCreateManyDiaryUserInputEnvelope\n    set?: mood_diary_mood_entriesWhereUniqueInput | mood_diary_mood_entriesWhereUniqueInput[]\n    disconnect?: mood_diary_mood_entriesWhereUniqueInput | mood_diary_mood_entriesWhereUniqueInput[]\n    delete?: mood_diary_mood_entriesWhereUniqueInput | mood_diary_mood_entriesWhereUniqueInput[]\n    connect?: mood_diary_mood_entriesWhereUniqueInput | mood_diary_mood_entriesWhereUniqueInput[]\n    update?: mood_diary_mood_entriesUpdateWithWhereUniqueWithoutDiaryUserInput | mood_diary_mood_entriesUpdateWithWhereUniqueWithoutDiaryUserInput[]\n    updateMany?: mood_diary_mood_entriesUpdateManyWithWhereWithoutDiaryUserInput | mood_diary_mood_entriesUpdateManyWithWhereWithoutDiaryUserInput[]\n    deleteMany?: mood_diary_mood_entriesScalarWhereInput | mood_diary_mood_entriesScalarWhereInput[]\n  }\n\n  export type mood_diary_mood_entriesUncheckedUpdateManyWithoutDiaryUserNestedInput = {\n    create?: XOR<mood_diary_mood_entriesCreateWithoutDiaryUserInput, mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput> | mood_diary_mood_entriesCreateWithoutDiaryUserInput[] | mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput[]\n    connectOrCreate?: mood_diary_mood_entriesCreateOrConnectWithoutDiaryUserInput | mood_diary_mood_entriesCreateOrConnectWithoutDiaryUserInput[]\n    upsert?: mood_diary_mood_entriesUpsertWithWhereUniqueWithoutDiaryUserInput | mood_diary_mood_entriesUpsertWithWhereUniqueWithoutDiaryUserInput[]\n    createMany?: mood_diary_mood_entriesCreateManyDiaryUserInputEnvelope\n    set?: mood_diary_mood_entriesWhereUniqueInput | mood_diary_mood_entriesWhereUniqueInput[]\n    disconnect?: mood_diary_mood_entriesWhereUniqueInput | mood_diary_mood_entriesWhereUniqueInput[]\n    delete?: mood_diary_mood_entriesWhereUniqueInput | mood_diary_mood_entriesWhereUniqueInput[]\n    connect?: mood_diary_mood_entriesWhereUniqueInput | mood_diary_mood_entriesWhereUniqueInput[]\n    update?: mood_diary_mood_entriesUpdateWithWhereUniqueWithoutDiaryUserInput | mood_diary_mood_entriesUpdateWithWhereUniqueWithoutDiaryUserInput[]\n    updateMany?: mood_diary_mood_entriesUpdateManyWithWhereWithoutDiaryUserInput | mood_diary_mood_entriesUpdateManyWithWhereWithoutDiaryUserInput[]\n    deleteMany?: mood_diary_mood_entriesScalarWhereInput | mood_diary_mood_entriesScalarWhereInput[]\n  }\n\n  export type mood_diary_diaryusersCreateNestedOneWithoutMood_diary_mood_entriesInput = {\n    create?: XOR<mood_diary_diaryusersCreateWithoutMood_diary_mood_entriesInput, mood_diary_diaryusersUncheckedCreateWithoutMood_diary_mood_entriesInput>\n    connectOrCreate?: mood_diary_diaryusersCreateOrConnectWithoutMood_diary_mood_entriesInput\n    connect?: mood_diary_diaryusersWhereUniqueInput\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type BoolFieldUpdateOperationsInput = {\n    set?: boolean\n  }\n\n  export type mood_diary_diaryusersUpdateOneRequiredWithoutMood_diary_mood_entriesNestedInput = {\n    create?: XOR<mood_diary_diaryusersCreateWithoutMood_diary_mood_entriesInput, mood_diary_diaryusersUncheckedCreateWithoutMood_diary_mood_entriesInput>\n    connectOrCreate?: mood_diary_diaryusersCreateOrConnectWithoutMood_diary_mood_entriesInput\n    upsert?: mood_diary_diaryusersUpsertWithoutMood_diary_mood_entriesInput\n    connect?: mood_diary_diaryusersWhereUniqueInput\n    update?: XOR<XOR<mood_diary_diaryusersUpdateToOneWithWhereWithoutMood_diary_mood_entriesInput, mood_diary_diaryusersUpdateWithoutMood_diary_mood_entriesInput>, mood_diary_diaryusersUncheckedUpdateWithoutMood_diary_mood_entriesInput>\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedStringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedBoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type mood_diary_mood_entriesCreateWithoutDiaryUserInput = {\n    id: string\n    mood_type: string\n    note?: string | null\n    created_at: Date | string\n    archived: boolean\n  }\n\n  export type mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput = {\n    id: string\n    mood_type: string\n    note?: string | null\n    created_at: Date | string\n    archived: boolean\n  }\n\n  export type mood_diary_mood_entriesCreateOrConnectWithoutDiaryUserInput = {\n    where: mood_diary_mood_entriesWhereUniqueInput\n    create: XOR<mood_diary_mood_entriesCreateWithoutDiaryUserInput, mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput>\n  }\n\n  export type mood_diary_mood_entriesCreateManyDiaryUserInputEnvelope = {\n    data: mood_diary_mood_entriesCreateManyDiaryUserInput | mood_diary_mood_entriesCreateManyDiaryUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type mood_diary_mood_entriesUpsertWithWhereUniqueWithoutDiaryUserInput = {\n    where: mood_diary_mood_entriesWhereUniqueInput\n    update: XOR<mood_diary_mood_entriesUpdateWithoutDiaryUserInput, mood_diary_mood_entriesUncheckedUpdateWithoutDiaryUserInput>\n    create: XOR<mood_diary_mood_entriesCreateWithoutDiaryUserInput, mood_diary_mood_entriesUncheckedCreateWithoutDiaryUserInput>\n  }\n\n  export type mood_diary_mood_entriesUpdateWithWhereUniqueWithoutDiaryUserInput = {\n    where: mood_diary_mood_entriesWhereUniqueInput\n    data: XOR<mood_diary_mood_entriesUpdateWithoutDiaryUserInput, mood_diary_mood_entriesUncheckedUpdateWithoutDiaryUserInput>\n  }\n\n  export type mood_diary_mood_entriesUpdateManyWithWhereWithoutDiaryUserInput = {\n    where: mood_diary_mood_entriesScalarWhereInput\n    data: XOR<mood_diary_mood_entriesUpdateManyMutationInput, mood_diary_mood_entriesUncheckedUpdateManyWithoutDiaryUserInput>\n  }\n\n  export type mood_diary_mood_entriesScalarWhereInput = {\n    AND?: mood_diary_mood_entriesScalarWhereInput | mood_diary_mood_entriesScalarWhereInput[]\n    OR?: mood_diary_mood_entriesScalarWhereInput[]\n    NOT?: mood_diary_mood_entriesScalarWhereInput | mood_diary_mood_entriesScalarWhereInput[]\n    id?: UuidFilter<\"mood_diary_mood_entries\"> | string\n    mood_diary_diaryuser_id?: UuidFilter<\"mood_diary_mood_entries\"> | string\n    mood_type?: StringFilter<\"mood_diary_mood_entries\"> | string\n    note?: StringNullableFilter<\"mood_diary_mood_entries\"> | string | null\n    created_at?: DateTimeFilter<\"mood_diary_mood_entries\"> | Date | string\n    archived?: BoolFilter<\"mood_diary_mood_entries\"> | boolean\n  }\n\n  export type mood_diary_diaryusersCreateWithoutMood_diary_mood_entriesInput = {\n    id: string\n    created_at: Date | string\n  }\n\n  export type mood_diary_diaryusersUncheckedCreateWithoutMood_diary_mood_entriesInput = {\n    id: string\n    created_at: Date | string\n  }\n\n  export type mood_diary_diaryusersCreateOrConnectWithoutMood_diary_mood_entriesInput = {\n    where: mood_diary_diaryusersWhereUniqueInput\n    create: XOR<mood_diary_diaryusersCreateWithoutMood_diary_mood_entriesInput, mood_diary_diaryusersUncheckedCreateWithoutMood_diary_mood_entriesInput>\n  }\n\n  export type mood_diary_diaryusersUpsertWithoutMood_diary_mood_entriesInput = {\n    update: XOR<mood_diary_diaryusersUpdateWithoutMood_diary_mood_entriesInput, mood_diary_diaryusersUncheckedUpdateWithoutMood_diary_mood_entriesInput>\n    create: XOR<mood_diary_diaryusersCreateWithoutMood_diary_mood_entriesInput, mood_diary_diaryusersUncheckedCreateWithoutMood_diary_mood_entriesInput>\n    where?: mood_diary_diaryusersWhereInput\n  }\n\n  export type mood_diary_diaryusersUpdateToOneWithWhereWithoutMood_diary_mood_entriesInput = {\n    where?: mood_diary_diaryusersWhereInput\n    data: XOR<mood_diary_diaryusersUpdateWithoutMood_diary_mood_entriesInput, mood_diary_diaryusersUncheckedUpdateWithoutMood_diary_mood_entriesInput>\n  }\n\n  export type mood_diary_diaryusersUpdateWithoutMood_diary_mood_entriesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type mood_diary_diaryusersUncheckedUpdateWithoutMood_diary_mood_entriesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type mood_diary_mood_entriesCreateManyDiaryUserInput = {\n    id: string\n    mood_type: string\n    note?: string | null\n    created_at: Date | string\n    archived: boolean\n  }\n\n  export type mood_diary_mood_entriesUpdateWithoutDiaryUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    mood_type?: StringFieldUpdateOperationsInput | string\n    note?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    archived?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type mood_diary_mood_entriesUncheckedUpdateWithoutDiaryUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    mood_type?: StringFieldUpdateOperationsInput | string\n    note?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    archived?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n  export type mood_diary_mood_entriesUncheckedUpdateManyWithoutDiaryUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    mood_type?: StringFieldUpdateOperationsInput | string\n    note?: NullableStringFieldUpdateOperationsInput | string | null\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    archived?: BoolFieldUpdateOperationsInput | boolean\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}","node_modules/.prisma/client/runtime/index-browser.d.ts":"declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/library.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/wasm.d.ts":"export * from \"./index\"","node_modules/@prisma/client/index.d.ts":"export * from '.prisma/client/default'"},"document":"# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Actors](#actors)\n- [Diaries](#diaries)\n\n## Actors\n\n```mermaid\nerDiagram\n\"mood_diary_diaryusers\" {\n  String id PK\n  DateTime created_at\n}\n```\n\n### `mood_diary_diaryusers`\n\nRepresents the logical owner/actor of the Mood Diary. This model\ncurrently supports a single diary user, matching the app's business logic\nof a single-user system. It is the reference point for all mood entries\nvia foreign keys and ensures the actor boundary is clear. By\nencapsulating user context here, future expansion to a multi-user\nscenario or advanced metadata storage is simplified. Fields are minimized\nas only a logical system user is required.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `created_at`\n  > Timestamp indicating when the diary user was (theoretically) created.\n  > Used for future extensibility and auditability, even if only a single\n  > logical user exists.\n\n## Diaries\n\n```mermaid\nerDiagram\n\"mood_diary_mood_entries\" {\n  String id PK\n  String mood_diary_diaryuser_id FK\n  String mood_type\n  String note \"nullable\"\n  DateTime created_at\n  Boolean archived\n}\n```\n\n### `mood_diary_mood_entries`\n\nThis table stores each mood diary entry, representing the core journaling\nactivity in the Mood Diary application. Each entry records a mood\nselected from a fixed set of 8 types, an optional note (up to 500 Unicode\ncharacters), an automatic creation timestamp, and an \"archived\" status\nindicating if the entry is older than 30 days (and therefore excluded\nfrom listings and summaries). Entries are immutable: once created, they\ncannot be edited or deleted. Each entry references the logical diary user\nin the system ([mood_diary_diaryusers](#mood_diary_diaryusers)), supporting future\nextensibility for multi-user scenarios. All mood and archiving business\nrules are strictly enforced in application logic.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `mood_diary_diaryuser_id`: References the logical mood diary user. [mood_diary_diaryusers.id](#mood_diary_diaryusers).\n- `mood_type`\n  > Mood type selected for this entry, must be one of: happy, sad, anxious,\n  > excited, angry, calm, stressed, tired. Enforced via application logic.\n- `note`\n  > Optional freeform note for this entry, max 500 Unicode characters. May be\n  > blank or null.\n- `created_at`\n  > Timestamp when this entry was created (auto-set, UTC, immutable, used for\n  > archiving and queries).\n- `archived`\n  > Indicates if this entry has been archived (i.e., older than 30 days, as\n  > determined by background process). Archived entries are hidden from\n  > listings/statistics.\n","diagrams":{"Actors":"```mermaid\nerDiagram\n\"mood_diary_diaryusers\" {\n  String id PK\n  DateTime created_at\n}\n```","Diaries":"```mermaid\nerDiagram\n\"mood_diary_mood_entries\" {\n  String id PK\n  String mood_diary_diaryuser_id FK\n  String mood_type\n  String note \"nullable\"\n  DateTime created_at\n  Boolean archived\n}\n```"}},"created_at":"2025-09-14T15:08:27.696Z","completed_at":"2025-09-14T15:09:54.880Z","step":0},{"id":"019948c7-518f-763a-8897-7751fdcd527d","type":"userMessage","contents":[{"type":"text","text":"Let's go with API Interface"}],"created_at":"2025-09-14T15:10:46.159Z"},{"type":"interface","id":"019948cd-58b7-72ee-805f-df2d6ca9fc8d","reason":"The database design and ERD for the Mood Diary app have been completed. Proceeding to generate RESTful API interfaces to allow creation, listing, and weekly summary retrieval of mood entries, enforcing all relevant business rules and constraints.","authorizations":[{"role":"diaryUser","operations":[{"specification":"This operation allows the diaryUser role (single logical user) to obtain a session for accessing their Mood Diary. The app does not support registration, so this endpoint serves as a universal entry point for the one user, with no username or password. The session is stateless, with no personal data collected. The operation returns a short-lived access token and metadata representing the system's single logical user, referencing the mood_diary_diaryusers table, which contains only an id and created_at timestamp. Security is provided by the inherent stateless nature and the absence of multi-user data. Token issuance is for session identification and not for authentication. No personal or secret input is ever required from the user. The response follows the pattern IMoodDiaryDiaryUser.IAuthorized, containing the issued token and diary user metadata. The join/login distinction is artificial and only present for back-end convention. There is no login operation because there is no credential authentication; refresh is provided for session extension.","authorizationType":"join","description":"Allows the system's single logical diaryUser to retrieve a session token for using the Mood Diary application. This operation does not perform traditional user registration or authentication—since the app has only a single logical user, anyone accessing the API receives the same (non-personalized) access. The endpoint directly issues a token for the logical diaryUser, returning the unique id and created_at fields from the mood_diary_diaryusers table. No personal identifiers or credentials are used. This operation is not a security boundary; rather, it establishes a stateless, anonymous session for logging moods, consistent with the single-user design. There is no support for login or password-based authentication. The access token enables subsequent authorized API actions for mood entry/log/view/statistics operations. \n\nRelated operations are refresh for extending session lifetime and the main mood entry CRUD endpoints (protected by the issued token). Error behavior is limited to backend or system-level failures (e.g., database access issues). This endpoint is always allowed and never rate limited for business logic.\n\nMust reference only fields defined in mood_diary_diaryusers: id and created_at. No user-managed input. Result conforms to IMoodDiaryDiaryUser.IAuthorized DTO.","summary":"Obtain session token as the logical diaryUser (single-user, from mood_diary_diaryusers), no registration or authentication required.","parameters":[],"requestBody":null,"responseBody":{"description":"Session authorized data for the single logical diaryUser, containing generated access token and diary user metadata (id, created_at).","typeName":"IMoodDiaryDiaryUser.IAuthorized"},"authorizationRole":"diaryUser","name":"join","path":"/auth/diaryUser/join","method":"post"},{"specification":"This operation provides a conventional login endpoint for the Mood Diary application's single logical user (diaryUser), in compliance with required OpenAPI authorization workflows. In this unique case, no credentials, passwords, or identities are used or accepted. The endpoint always succeeds, issuing a new access token and session information for the single logical user represented in the mood_diary_diaryusers table. No registration, multi-user control, or personal data exist. The response conforms to IMoodDiaryDiaryUser.IAuthorized format, containing the user's id and created_at timestamp. All login input data is ignored, as any party may obtain access freely. No user session or account is created, this is a stateless, always-permitted operation, present only for API completeness where OAuth/JWT \"login\" flows would be required. No actual security boundary is present. Use for compliance and OpenAPI client compatibility only.","authorizationType":"login","description":"Allows the single logical diaryUser to \"login\", even though no authentication is performed and no credentials or password are accepted. Any client may POST to this endpoint and receive a valid access token for the Mood Diary API. The operation always succeeds unless system-level errors occur. The underlying user data is drawn from mood_diary_diaryusers: only the id and created_at properties are returned. This operation is included solely for OpenAPI/JWT compliance, not security. No personal information is ever managed, no session state is persisted, and all business logic is stateless and open. The response includes token and diary user metadata as per IMoodDiaryDiaryUser.IAuthorized. Related operations include join (stateless registration/entry point) and refresh (token renewal).","summary":"OpenAPI-compliant login endpoint for the single logical diaryUser (mood_diary_diaryusers); no credentials accepted, always issues a token.","parameters":[],"requestBody":null,"responseBody":{"description":"Authorized session information for the logical diaryUser, including access token plus id and created_at from mood_diary_diaryusers.","typeName":"IMoodDiaryDiaryUser.IAuthorized"},"authorizationRole":"diaryUser","name":"login","path":"/auth/diaryUser/login","method":"post"},{"specification":"This operation provides token refresh capability for the Mood Diary application's single logical user (diaryUser). Given a valid refresh token, the system issues a new access token, extending the session without re-authentication or interaction. Since the system is single-user and issues tokens without registration or login, refresh is mainly for session management only. The mood_diary_diaryusers table is used as the data source: only the id and created_at fields are referenced. No personal information is managed; the operation is always available to the single logical user. If the provided refresh token is invalid or expired, a standard error is returned. There is no distinction between multiple users. No profile or credential information is involved. The authorized DTO pattern IMoodDiaryDiaryUser.IAuthorized is used for the response.","authorizationType":"refresh","description":"Allows the diaryUser (the single logical user in the Mood Diary app) to refresh their session token and extend access without any login or further interaction. Only a valid refresh token is required; no personal credentials or data are checked. The system returns a new access token and the diary user's id and created_at values from mood_diary_diaryusers. This supports seamless, stateless session continuation in the single-user context. All error and security handling is limited to token verification. There is no multi-user management or credential validation. This operation presumes only one logical user exists. Related operation: join (to obtain initial token).","summary":"Refreshes the session for the logical diaryUser by issuing a new access token given a valid refresh token (mood_diary_diaryusers, single-user context).","parameters":[],"requestBody":null,"responseBody":{"description":"Updated authorized session with new token for the single logical diaryUser, including id and created_at from mood_diary_diaryusers.","typeName":"IMoodDiaryDiaryUser.IAuthorized"},"authorizationRole":"diaryUser","name":"refresh","path":"/auth/diaryUser/refresh","method":"post"}]}],"document":{"operations":[{"specification":"This operation allows the diaryUser role (single logical user) to obtain a session for accessing their Mood Diary. The app does not support registration, so this endpoint serves as a universal entry point for the one user, with no username or password. The session is stateless, with no personal data collected. The operation returns a short-lived access token and metadata representing the system's single logical user, referencing the mood_diary_diaryusers table, which contains only an id and created_at timestamp. Security is provided by the inherent stateless nature and the absence of multi-user data. Token issuance is for session identification and not for authentication. No personal or secret input is ever required from the user. The response follows the pattern IMoodDiaryDiaryUser.IAuthorized, containing the issued token and diary user metadata. The join/login distinction is artificial and only present for back-end convention. There is no login operation because there is no credential authentication; refresh is provided for session extension.","authorizationType":"join","description":"Allows the system's single logical diaryUser to retrieve a session token for using the Mood Diary application. This operation does not perform traditional user registration or authentication—since the app has only a single logical user, anyone accessing the API receives the same (non-personalized) access. The endpoint directly issues a token for the logical diaryUser, returning the unique id and created_at fields from the mood_diary_diaryusers table. No personal identifiers or credentials are used. This operation is not a security boundary; rather, it establishes a stateless, anonymous session for logging moods, consistent with the single-user design. There is no support for login or password-based authentication. The access token enables subsequent authorized API actions for mood entry/log/view/statistics operations. \n\nRelated operations are refresh for extending session lifetime and the main mood entry CRUD endpoints (protected by the issued token). Error behavior is limited to backend or system-level failures (e.g., database access issues). This endpoint is always allowed and never rate limited for business logic.\n\nMust reference only fields defined in mood_diary_diaryusers: id and created_at. No user-managed input. Result conforms to IMoodDiaryDiaryUser.IAuthorized DTO.","summary":"Obtain session token as the logical diaryUser (single-user, from mood_diary_diaryusers), no registration or authentication required.","parameters":[],"requestBody":null,"responseBody":{"description":"Session authorized data for the single logical diaryUser, containing generated access token and diary user metadata (id, created_at).","typeName":"IMoodDiaryDiaryUser.IAuthorized"},"authorizationRole":"diaryUser","name":"join","path":"/auth/diaryUser/join","method":"post"},{"specification":"This operation provides a conventional login endpoint for the Mood Diary application's single logical user (diaryUser), in compliance with required OpenAPI authorization workflows. In this unique case, no credentials, passwords, or identities are used or accepted. The endpoint always succeeds, issuing a new access token and session information for the single logical user represented in the mood_diary_diaryusers table. No registration, multi-user control, or personal data exist. The response conforms to IMoodDiaryDiaryUser.IAuthorized format, containing the user's id and created_at timestamp. All login input data is ignored, as any party may obtain access freely. No user session or account is created, this is a stateless, always-permitted operation, present only for API completeness where OAuth/JWT \"login\" flows would be required. No actual security boundary is present. Use for compliance and OpenAPI client compatibility only.","authorizationType":"login","description":"Allows the single logical diaryUser to \"login\", even though no authentication is performed and no credentials or password are accepted. Any client may POST to this endpoint and receive a valid access token for the Mood Diary API. The operation always succeeds unless system-level errors occur. The underlying user data is drawn from mood_diary_diaryusers: only the id and created_at properties are returned. This operation is included solely for OpenAPI/JWT compliance, not security. No personal information is ever managed, no session state is persisted, and all business logic is stateless and open. The response includes token and diary user metadata as per IMoodDiaryDiaryUser.IAuthorized. Related operations include join (stateless registration/entry point) and refresh (token renewal).","summary":"OpenAPI-compliant login endpoint for the single logical diaryUser (mood_diary_diaryusers); no credentials accepted, always issues a token.","parameters":[],"requestBody":null,"responseBody":{"description":"Authorized session information for the logical diaryUser, including access token plus id and created_at from mood_diary_diaryusers.","typeName":"IMoodDiaryDiaryUser.IAuthorized"},"authorizationRole":"diaryUser","name":"login","path":"/auth/diaryUser/login","method":"post"},{"specification":"This operation provides token refresh capability for the Mood Diary application's single logical user (diaryUser). Given a valid refresh token, the system issues a new access token, extending the session without re-authentication or interaction. Since the system is single-user and issues tokens without registration or login, refresh is mainly for session management only. The mood_diary_diaryusers table is used as the data source: only the id and created_at fields are referenced. No personal information is managed; the operation is always available to the single logical user. If the provided refresh token is invalid or expired, a standard error is returned. There is no distinction between multiple users. No profile or credential information is involved. The authorized DTO pattern IMoodDiaryDiaryUser.IAuthorized is used for the response.","authorizationType":"refresh","description":"Allows the diaryUser (the single logical user in the Mood Diary app) to refresh their session token and extend access without any login or further interaction. Only a valid refresh token is required; no personal credentials or data are checked. The system returns a new access token and the diary user's id and created_at values from mood_diary_diaryusers. This supports seamless, stateless session continuation in the single-user context. All error and security handling is limited to token verification. There is no multi-user management or credential validation. This operation presumes only one logical user exists. Related operation: join (to obtain initial token).","summary":"Refreshes the session for the logical diaryUser by issuing a new access token given a valid refresh token (mood_diary_diaryusers, single-user context).","parameters":[],"requestBody":null,"responseBody":{"description":"Updated authorized session with new token for the single logical diaryUser, including id and created_at from mood_diary_diaryusers.","typeName":"IMoodDiaryDiaryUser.IAuthorized"},"authorizationRole":"diaryUser","name":"refresh","path":"/auth/diaryUser/refresh","method":"post"},{"specification":"This operation retrieves a paginated, reverse-chronological list of non-archived mood diary entries for the single logical diary user. It operates on the mood_diary_mood_entries table, referencing mood_diary_diaryusers as the logical owner. This endpoint supports search, filtering by date range, sorting, and pagination, but always excludes archived entries (older than 30 days, archived=true). All response objects include: entry id, mood type (must be one of the fixed 8), optional note, created_at ISO timestamp, and archived boolean (should always be false for returned records). Business rules enforce returning only unarchived entries, maximum of 3 per day, newest first.\n\nAll listing logic must honor the rule that only non-archived (archived=false) entries from the past 30 days are returned, ordered from most recent. The operation provides pagination with likely page size and current/total result count. No editing is permitted by this operation. Filtering by mood type or date range may be implemented, but always within the context of unarchived entries. \n\nThe Prisma schema table mood_diary_mood_entries is the data source for this operation, which references the logical owner in mood_diary_diaryusers via mood_diary_diaryuser_id.","description":"This operation provides the means for the diaryUser to view a list of their recent mood diary entries, supporting features like scrolling and filtering. Each result includes mood type (one of eight fixed values), the optional note (up to 500 Unicode characters), the auto-generated UTC timestamp (created_at), and an archived flag (expected false, as only recent entries are listed).\n\nSecurity-wise, no authentication or user separation exists; the app assumes a single logical diary owner, so all data is exposed. This is in line with business rules. Only non-archived entries (archived=false) are eligible, enforcing the 30-day retention policy for active viewing. Pagination and sorting are handled in the backend as per standard API conventions. No modification (edit/delete) actions are surfaced—this endpoint is strictly for read access.\n\nKey validation rules: only entries from the past 30 days, not archived, ordered by created_at descending. Error handling includes ensuring no archived data is exposed, and appropriate messages for invalid filters or pagination arguments. Related operations include mood entry creation (POST /moodEntries) and summary fetching (GET /moodEntries/weeklySummary).","summary":"Retrieve a paginated list of non-archived mood diary entries for the single logical user from mood_diary_mood_entries.","parameters":[],"requestBody":{"description":"Filter, search, and pagination criteria for retrieving non-archived mood diary entries over the last 30 days.","typeName":"IMoodDiaryMoodEntry.IRequest"},"responseBody":{"description":"Paginated list of non-archived mood diary entries matching criteria.","typeName":"IPageIMoodDiaryMoodEntry"},"authorizationType":null,"authorizationRole":"diaryUser","name":"index","path":"/moodDiary/diaryUser/moodEntries","method":"patch"},{"specification":"This operation creates a new mood diary entry for the single logical diary user, writing to the mood_diary_mood_entries table. On invocation, the system verifies that the number of non-archived entries for the current calendar day (Asia/Calcutta time) is less than 3, and that the submitted mood type is one of the 8 allowed types. The note is recorded as optional and may be up to 500 Unicode characters, supporting emojis and all characters. The system must automatically assign the server's current timestamp as created_at (user submission of timestamp is ignored), and archived field is set to false upon creation. The entry becomes immutable: no subsequent edits or deletion allowed.\n\nBusiness logic includes strict daily entry limitation (3 per day), rejection of invalid mood types, enforcement of note length, and validation that timestamped entries are not in the future. Attempts to insert a fourth entry in one day, or provide invalid data, must receive detailed error messages. The model mood_diary_mood_entries is the authoritative data source for this operation.","description":"This operation enables the diaryUser to create a new mood diary entry, capturing their mood and, optionally, a personal note. Only 3 entries per calendar day are permitted, ensuring users journal mindfully without data abuse. The mood_type must be one of: happy, sad, anxious, excited, angry, calm, stressed, tired. If omitted or invalid, an explicit validation error is returned. The note, if present, may be blank or up to 500 Unicode characters, including emojis. The system always sets the created_at timestamp to the current server time (Asia/Calcutta zone), never accepting a user-supplied timestamp. The archived flag is false by default for all new entries.\n\nSecurity is simple: no authentication or user distinction—this is a single-user diary by business design. All validation failures (invalid mood, too-long note, over daily limit, future timestamps) yield clear, user-focused error messages. The response includes the persisted entry data (id, mood_type, note, created_at, archived=false). Other related endpoints allow subsequent listing or summary. No edit or deletion is ever permitted on entries once created.","summary":"Create a new mood diary entry for the logical user in mood_diary_mood_entries, enforcing daily entry limit and validation rules.","parameters":[],"requestBody":{"description":"New mood diary entry details: mood type (from fixed set), optional note (≤500 characters).","typeName":"IMoodDiaryMoodEntry.ICreate"},"responseBody":{"description":"Persisted mood diary entry record, immutable after creation.","typeName":"IMoodDiaryMoodEntry"},"authorizationType":null,"authorizationRole":"diaryUser","name":"create","path":"/moodDiary/diaryUser/moodEntries","method":"post"},{"specification":"This operation retrieves the complete detail record for a specific, non-archived mood diary entry by id. The target is the mood_diary_mood_entries table, filtered strictly by id, archived=false. An entry may be retrieved if and only if it is not archived—entries older than 30 days (archived=true) are totally inaccessible. The response includes id, mood type (from 8 fixed types), optional note, exact UTC timestamp, and archived flag (serves as an integrity check; must be false for returned results). Requests for non-existent or archived entries must yield a not-found or access-denied error.\n\nStrictly, this operation is single-user, no authentication, no distinction: the app operates under a single logical diaryUser. The entry is immutable—no further editing or deletion is permitted, and the archived flag is read-only for the user. Prisma mood_diary_mood_entries is the source table, joined to mood_diary_diaryusers solely for referential integrity.","description":"Retrieves one mood diary entry in detail, given its unique id. Only unarchived entries (created within last 30 days) are available; attempts to access archived or non-existent entries result in a clear not found or access error. Returned object includes: id, mood_type (fixed allowed list), note (if present), created_at UTC timestamp, and archived flag (always false for successful lookups). No edit or delete is possible—data is immutable.\n\nThis operation is open to the single logical user by business rules—no authentication, no per-user scope. Data returned is always up to date and immutable. Errors are detailed for invalid ids or archived data, and security is ensured solely through archiving and business constraints.","summary":"Fetch details for a single non-archived mood diary entry by id from mood_diary_mood_entries.","parameters":[{"name":"entryId","description":"Unique identifier for the mood diary entry to retrieve. Must be a valid UUID and reference a non-archived entry (archived=false).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Mood diary entry details for given id, if unarchived and present.","typeName":"IMoodDiaryMoodEntry"},"authorizationType":null,"authorizationRole":"diaryUser","name":"at","path":"/moodDiary/diaryUser/moodEntries/{entryId}","method":"get"},{"specification":"This operation generates a weekly summary report of the single user's moods over the past 7 calendar days (excluding today), based on the mood_diary_mood_entries table. It aggregates unarchived entries (archived=false, created_at within last 30 days) for each day in the 7 day period, tallying count for each of the 8 allowed mood types. The summary includes daily and total counts per mood (happy, sad, anxious, excited, angry, calm, stressed, tired), and provides the ISO range of the covered week. All counts for mood types without entries default to zero.\n\nNo archived data (entries older than 30 days, archived=true) is included, and summary logic must exclude invalid/future-dated entries. The operation is stateless and re-computed on each request. Prisma mood_diary_mood_entries is the definitive source table, referencing mood_diary_diaryusers for the logical owner. Handles edge cases, such as weeks with no data (returns zeroes for all moods), and shows correct date range. The business rule is strict: no user authentication—single diaryUser, all entries relevant to that context.","description":"This endpoint computes and returns the mood summary statistics for the past 7 calendar days (not including today) for the single diaryUser. For each day/mood, the system counts non-archived entries and returns daily and total mood counts for all 8 standard types (zero when none logged). The summary includes start/end ISO dates for the time window. If no entries are present in the time window, the summary is zeroed accordingly.\n\nBusiness and security rules: no authentication or user separation, single user logical model. Archived entries are always excluded (business logic and application-level enforcement). Performance is expected within 2 seconds as per requirements. This API does not expose any individual entry details, only summary statistics. Related endpoints enable listing or creation of entries.\n\nError responses handle only internal system failure or invalid business logic.\n","summary":"Generate a weekly summary of moods for the last 7 active days, aggregating counts from mood_diary_mood_entries.","parameters":[],"requestBody":null,"responseBody":{"description":"Weekly summary of moods, with daily and total counts for each fixed mood type over the date range.","typeName":"IMoodDiaryMoodEntryWeeklySummary"},"authorizationType":null,"authorizationRole":"diaryUser","name":"weeklySummary","path":"/moodDiary/diaryUser/moodEntries/weeklySummary","method":"get"}],"components":{"authorization":[{"name":"diaryUser","description":"A user of the Mood Diary application who can log up to 3 mood entries per day, add personal notes, view their entries and weekly mood summaries, but cannot edit or delete entries. No registration, all are treated as a single logical user. Role allows full access to mood logging and summary features via API.","kind":"member"}],"schemas":{"IPage.IPagination":{"type":"object","properties":{"current":{"type":"integer","minimum":0,"description":"Current page number."},"limit":{"type":"integer","minimum":0,"description":"Limitation of records per a page."},"records":{"type":"integer","minimum":0,"description":"Total records in the database."},"pages":{"type":"integer","minimum":0,"description":"Total pages.\n\nEqual to {@link records} / {@link limit} with ceiling."}},"required":["current","limit","records","pages"],"description":"Page information."},"IAuthorizationToken":{"type":"object","properties":{"access":{"type":"string","description":"JWT access token for authenticated requests.\n\nThis token should be included in the Authorization header for subsequent\nauthenticated API requests as `Bearer {token}`."},"refresh":{"type":"string","description":"Refresh token for obtaining new access tokens.\n\nThis token can be used to request new access tokens when the current access\ntoken expires, extending the user's session."},"expired_at":{"type":"string","format":"date-time","description":"Access token expiration timestamp.\n\nISO 8601 date-time string indicating when the access token will expire and\ncan no longer be used for authentication."},"refreshable_until":{"type":"string","format":"date-time","description":"Refresh token expiration timestamp.\n\nISO 8601 date-time string indicating the latest time until which the\nrefresh token can be used to obtain new access tokens."}},"required":["access","refresh","expired_at","refreshable_until"],"description":"Authorization token response structure.\n\nThis interface defines the structure of the authorization token response\nreturned after successful user authentication. It contains both access and\nrefresh tokens along with their expiration information.\n\nThis token structure is automatically included in API schemas when the system\ndetects authorization roles in the requirements analysis phase. It provides a\nstandard format for JWT-based authentication across the generated backend\napplications."},"IPageIMoodDiaryMoodEntry":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/IMoodDiaryMoodEntry"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"EMoodDiaryMoodType":{"oneOf":[{"const":"happy","description":"Mood type enum representing the fixed set of allowed moods in the diary application. Only these eight values are valid for mood entries. Original schema comment and business requirement explicitly restrict mood types to these. This enumeration is referenced in all entry creation, update, and retrieval DTOs to validate mood data integrity."},{"const":"sad","description":"Mood type enum representing the fixed set of allowed moods in the diary application. Only these eight values are valid for mood entries. Original schema comment and business requirement explicitly restrict mood types to these. This enumeration is referenced in all entry creation, update, and retrieval DTOs to validate mood data integrity."},{"const":"anxious","description":"Mood type enum representing the fixed set of allowed moods in the diary application. Only these eight values are valid for mood entries. Original schema comment and business requirement explicitly restrict mood types to these. This enumeration is referenced in all entry creation, update, and retrieval DTOs to validate mood data integrity."},{"const":"excited","description":"Mood type enum representing the fixed set of allowed moods in the diary application. Only these eight values are valid for mood entries. Original schema comment and business requirement explicitly restrict mood types to these. This enumeration is referenced in all entry creation, update, and retrieval DTOs to validate mood data integrity."},{"const":"angry","description":"Mood type enum representing the fixed set of allowed moods in the diary application. Only these eight values are valid for mood entries. Original schema comment and business requirement explicitly restrict mood types to these. This enumeration is referenced in all entry creation, update, and retrieval DTOs to validate mood data integrity."},{"const":"calm","description":"Mood type enum representing the fixed set of allowed moods in the diary application. Only these eight values are valid for mood entries. Original schema comment and business requirement explicitly restrict mood types to these. This enumeration is referenced in all entry creation, update, and retrieval DTOs to validate mood data integrity."},{"const":"stressed","description":"Mood type enum representing the fixed set of allowed moods in the diary application. Only these eight values are valid for mood entries. Original schema comment and business requirement explicitly restrict mood types to these. This enumeration is referenced in all entry creation, update, and retrieval DTOs to validate mood data integrity."},{"const":"tired","description":"Mood type enum representing the fixed set of allowed moods in the diary application. Only these eight values are valid for mood entries. Original schema comment and business requirement explicitly restrict mood types to these. This enumeration is referenced in all entry creation, update, and retrieval DTOs to validate mood data integrity."}],"description":"Mood type enum representing the fixed set of allowed moods in the diary application. Only these eight values are valid for mood entries. Original schema comment and business requirement explicitly restrict mood types to these. This enumeration is referenced in all entry creation, update, and retrieval DTOs to validate mood data integrity."},"IMoodDiaryDiaryUser":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier (UUID) for the logical diary user. Automatically generated and represents the single account context for all mood entries."},"created_at":{"type":"string","format":"date-time","description":"Timestamp indicating when the logical user was created in the database (ISO 8601 UTC). Used for auditing and for future extensibility."}},"required":["id","created_at"],"description":"Diary user entity representing the app's single logical user. This schema matches the mood_diary_diaryusers Prisma table, which contains only the unique id and created_at fields. No additional properties or authentication fields exist in this minimal model. Used for internal session logic, auditing, and is the return value for diary session and login operations."},"IMoodDiaryDiaryUser.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier (UUID) for the logical diary user, as issued from mood_diary_diaryusers. Used to identify the single user session context."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the logical user record was created, as stored in mood_diary_diaryusers. Returned for auditing and completeness, always present."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","created_at","token"],"description":"Authorization/session container for the diaryUser, returned when a join, login, or refresh endpoint is called.\n\nThis schema strictly matches the requirements for one logical user: it contains the unique id and created_at timestamp from mood_diary_diaryusers (no personal or credential fields), plus a standard authorization token structure (see IAuthorizationToken type). No sensitive credentials or secret fields are ever present. All properties are required by business convention and referenced in authentication/authorization workflows."},"IMoodDiaryMoodEntry":{"type":"object","description":"Represents a single mood diary entry, as stored in the database and returned by the API. Each entry is immutable, records which mood the user selected (from a fixed 8-value set), an optional note (unicode, up to 500 chars), the timestamp of creation (auto-set UTC/ISO8601), and whether the entry is archived (older than 30 days, fully hidden from all lists/summaries). Entries are always linked to the logical diary user (single-user scenario) by foreign key mood_diary_diaryuser_id. All fields are defined in the Prisma schema and no properties can be omitted.","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for this mood diary entry. Populated upon creation; never user-provided. Matches the id column in mood_diary_mood_entries table."},"mood_diary_diaryuser_id":{"type":"string","format":"uuid","description":"Foreign key reference to the logical diary user entity. Always present (single-user app, but designed for future proofing). Corresponds to mood_diary_diaryusers.id."},"mood_type":{"$ref":"#/components/schemas/EMoodType","description":"Mood selected for this entry. Must be one of: happy, sad, anxious, excited, angry, calm, stressed, tired. Enforced via enum at type and application level."},"note":{"oneOf":[{"type":"string","description":"Optional freeform mood note, up to 500 Unicode characters, may be blank or omitted. Populated if user added a text note for this mood entry."},{"type":"null"}],"description":"Optional freeform mood note, up to 500 Unicode characters, may be blank or omitted. Populated if user added a text note for this mood entry."},"created_at":{"type":"string","format":"date-time","description":"Timestamp at which the entry was created (ISO 8601 UTC, auto-set by system, never user-provided). Used for all sorting, listing, archiving."},"archived":{"type":"boolean","description":"If true, entry is archived (older than 30 days, business logic enforced); if false, entry is active and visible. User never edits or sets this property; system-controlled."}},"required":["id","mood_diary_diaryuser_id","mood_type","created_at","archived"]},"IMoodDiaryMoodEntry.IRequest":{"type":"object","description":"Request body schema for listing/searching mood diary entries. Allows pagination, filtering by date, mood_type, full-text search, and sort specification. Used in PATCH /moodDiary/diaryUser/moodEntries.","properties":{"page":{"oneOf":[{"type":"integer"},{"type":"null"}],"description":"Which page to retrieve (optional, 1-based indexing)."},"limit":{"oneOf":[{"type":"integer"},{"type":"null"}],"description":"Maximum number of results per page (optional, enforced server-side)."},"from_date":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional ISO8601 lower-bound filter for created_at (entries after or equal to this datetime)."},"to_date":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Optional ISO8601 upper-bound filter for created_at (entries before or equal to this datetime)."},"mood_type":{"oneOf":[{"$ref":"#/components/schemas/EMoodType"},{"type":"null"}],"description":"Restrict results to a single mood type (optional)."},"search":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Full-text search over note content (optional, accent/emoji/Unicode-aware)."},"sort_by":{"oneOf":[{"const":"created_at"},{"type":"null"}],"description":"Sort field, only valid value in current API is 'created_at'."},"sort_dir":{"oneOf":[{"const":"asc"},{"const":"desc"},{"type":"null"}],"description":"Sort direction: 'asc' (oldest first) or 'desc' (newest first). Default is descending for reverse chronological listing."}},"required":[]},"IMoodDiaryMoodEntry.ICreate":{"type":"object","description":"Creation payload for a new mood diary entry. Only includes properties user may declare: mood_type and note. ID and timestamps are set system-side, and archived is always false for new entries. Prisma schema and all business logic strictly enforced. Mood type must be valid enum value. Note is optional, but if supplied, must be a string ≤ 500 Unicode chars. No extra properties permitted.","properties":{"mood_type":{"$ref":"#/components/schemas/EMoodType","description":"Mood type for the new entry. Required. Must be exactly one of the 8 allowed values, or entry is rejected."},"note":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Optional note content associated with the mood entry, up to 500 Unicode chars. May be blank or omitted. Emojis/symbols accepted."}},"required":["mood_type"]},"EMoodType":{"oneOf":[{"const":"happy","description":"Enumeration for valid mood types in the Mood Diary app. Values correspond to the business-mandated fixed set: happy, sad, anxious, excited, angry, calm, stressed, tired. This enum should be used everywhere a mood_type appears, ensuring all business validation and logic constraints are enforced at the type level. Mood types outside this set are never permitted in requests or responses."},{"const":"sad","description":"Enumeration for valid mood types in the Mood Diary app. Values correspond to the business-mandated fixed set: happy, sad, anxious, excited, angry, calm, stressed, tired. This enum should be used everywhere a mood_type appears, ensuring all business validation and logic constraints are enforced at the type level. Mood types outside this set are never permitted in requests or responses."},{"const":"anxious","description":"Enumeration for valid mood types in the Mood Diary app. Values correspond to the business-mandated fixed set: happy, sad, anxious, excited, angry, calm, stressed, tired. This enum should be used everywhere a mood_type appears, ensuring all business validation and logic constraints are enforced at the type level. Mood types outside this set are never permitted in requests or responses."},{"const":"excited","description":"Enumeration for valid mood types in the Mood Diary app. Values correspond to the business-mandated fixed set: happy, sad, anxious, excited, angry, calm, stressed, tired. This enum should be used everywhere a mood_type appears, ensuring all business validation and logic constraints are enforced at the type level. Mood types outside this set are never permitted in requests or responses."},{"const":"angry","description":"Enumeration for valid mood types in the Mood Diary app. Values correspond to the business-mandated fixed set: happy, sad, anxious, excited, angry, calm, stressed, tired. This enum should be used everywhere a mood_type appears, ensuring all business validation and logic constraints are enforced at the type level. Mood types outside this set are never permitted in requests or responses."},{"const":"calm","description":"Enumeration for valid mood types in the Mood Diary app. Values correspond to the business-mandated fixed set: happy, sad, anxious, excited, angry, calm, stressed, tired. This enum should be used everywhere a mood_type appears, ensuring all business validation and logic constraints are enforced at the type level. Mood types outside this set are never permitted in requests or responses."},{"const":"stressed","description":"Enumeration for valid mood types in the Mood Diary app. Values correspond to the business-mandated fixed set: happy, sad, anxious, excited, angry, calm, stressed, tired. This enum should be used everywhere a mood_type appears, ensuring all business validation and logic constraints are enforced at the type level. Mood types outside this set are never permitted in requests or responses."},{"const":"tired","description":"Enumeration for valid mood types in the Mood Diary app. Values correspond to the business-mandated fixed set: happy, sad, anxious, excited, angry, calm, stressed, tired. This enum should be used everywhere a mood_type appears, ensuring all business validation and logic constraints are enforced at the type level. Mood types outside this set are never permitted in requests or responses."}],"description":"Enumeration for valid mood types in the Mood Diary app. Values correspond to the business-mandated fixed set: happy, sad, anxious, excited, angry, calm, stressed, tired. This enum should be used everywhere a mood_type appears, ensuring all business validation and logic constraints are enforced at the type level. Mood types outside this set are never permitted in requests or responses."},"IMoodDiaryMoodEntryWeeklySummary":{"type":"object","description":"Describes the weekly statistics summary of moods over the latest 7 calendar days, not including today. Used for reporting and trend tracking by the user's Mood Diary app. The schema provides ISO8601 date ranges (start/end), and an array of 8 mood statistics objects (one for each valid EMoodType), each with total and daily counts. No entry data ever covers archived moods (older than 30 days). All counts default to zero when no matching data in summary period.","properties":{"start_date":{"type":"string","format":"date","description":"Inclusive start of the week summary window, ISO 8601 local date (Asia/Calcutta time). Earliest day included when aggregating summary."},"end_date":{"type":"string","format":"date","description":"Inclusive end of the week window (usually 6 days after start_date), ISO 8601 local date. Day before today if summary runs in normal business logic."},"mood_counts":{"type":"array","items":{"$ref":"#/components/schemas/IMoodDiaryMoodEntryWeeklySummary.IMoodCount"},"description":"One object for each of 8 valid mood types, summarizing total and per-day counts in the window. Always returns 8 objects in consistent mood type order. All counts are zero if there are no matching entries."}},"required":["start_date","end_date","mood_counts"]},"IMoodDiaryMoodEntryWeeklySummary.IMoodCount":{"type":"object","description":"Aggregated mood statistics in the summary: mood type, total count over the week, and daily counts array (7 values, one for each calendar day in the window). This type is always used inside weekly summary arrays.","properties":{"mood_type":{"$ref":"#/components/schemas/EMoodType","description":"Mood type this count applies to (one of 8 allowed)."},"total_count":{"type":"integer","description":"Sum of entries for this mood in the 7-day period, not including today (business rule)."},"daily_counts":{"type":"array","items":{"type":"integer"},"minItems":7,"maxItems":7,"description":"Number of entries per day for this mood. Array is exactly 7 elements, in order from window start_date to end_date (business convention)."}},"required":["mood_type","total_count","daily_counts"]}}}},"created_at":"2025-09-14T15:10:47.956Z","completed_at":"2025-09-14T15:17:21.207Z","step":0},{"id":"019948d3-2cba-7109-81eb-69704ce6c6eb","type":"userMessage","contents":[{"type":"text","text":"Now go with Test Code"}],"created_at":"2025-09-14T15:23:43.162Z"},{"type":"test","id":"019948d6-e4fc-75db-911f-8a25883fdf55","reason":"The API interface for the Mood Diary web application is complete. Now generating comprehensive E2E test suites to validate entry creation, listing, archival behavior, and weekly summary statistics according to the specified business rules.","files":[{"scenario":{"endpoint":{"path":"/auth/diaryUser/join","method":"post"},"draft":"Test the stateless session token issuance for the single logical diaryUser. Scenario: (1) App attempts to obtain a session by calling the endpoint. (2) Ensure the operation returns a valid token and unique diaryUser id with created_at (no user input required). (3) Expectation: operation always succeeds, never asks for credentials or registration, and multiple repeated calls issue distinct tokens for the same single user id. (4) Validation points: token format, id/created_at presence, consistent diaryUser id across tokens, and no confidential information leakage. (5) Edge: Backend/system failures return error, but not business logic errors or rate limits. (6) Business rule: Only single user, no registration, no personal data, always available. (7) Attempt to inject unexpected input data is ignored (robust to nonsense requests).","functionName":"test_api_diaryuser_session_token_issuance","dependencies":[{"endpoint":{"method":"post","path":"/auth/diaryUser/join"},"purpose":"Essential authentication prerequisite: \nThis join operation (post /auth/diaryUser/join) must be executed before any operations requiring 'diaryUser' role authorization. \n                It establishes the necessary user account and authentication context for the 'diaryUser' role, enabling subsequent API calls that depend on this specific authorization level. \n                Without this join operation, the main scenario endpoint and its dependencies will fail due to insufficient authentication credentials."}]},"location":"test/features/api/auth/test_api_diaryuser_session_token_issuance.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IMoodDiaryDiaryUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryDiaryUser\";\n\n/**\n * Validate stateless session token issuance for the single logical\n * diaryUser.\n *\n * This test ensures that the /auth/diaryUser/join endpoint always returns a\n * valid session token for the unique diaryUser—no registration,\n * credentials, or input required. Multiple calls should return distinct\n * tokens for the same logical user id, and returned objects must have the\n * required id, created_at, and token properties (with valid formats, never\n * leaking personal data).\n *\n * 1. Call the join endpoint and validate the output DTO is correct and all\n *    required fields are present and in the correct formats.\n * 2. Call join repeatedly—ensure the id and created_at remain consistent,\n *    while the token values differ.\n * 3. Validate that the endpoint is robust to extraneous/nonsense data—such\n *    input must be ignored.\n * 4. Confirm there is no confidential information in the response beyond id,\n *    created_at, and token.\n */\nexport async function test_api_diaryuser_session_token_issuance(\n  connection: api.IConnection,\n) {\n  // (1) Issue first session token\n  const output1: IMoodDiaryDiaryUser.IAuthorized =\n    await api.functional.auth.diaryUser.join(connection);\n  typia.assert(output1);\n\n  TestValidator.predicate(\n    \"id is valid uuid\",\n    typeof output1.id === \"string\" &&\n      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n        output1.id,\n      ),\n  );\n  TestValidator.predicate(\n    \"created_at is ISO string\",\n    typeof output1.created_at === \"string\" &&\n      /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d+)?Z$/.test(output1.created_at),\n  );\n\n  // Must contain only the three fields: id, created_at, token\n  TestValidator.equals(\n    \"response has only id, created_at, token\",\n    Object.keys(output1).sort(),\n    [\"created_at\", \"id\", \"token\"],\n  );\n\n  // Validate token substructure\n  typia.assert<IAuthorizationToken>(output1.token);\n  TestValidator.predicate(\n    \"token.access present\",\n    typeof output1.token.access === \"string\" &&\n      output1.token.access.length > 10,\n  );\n  TestValidator.predicate(\n    \"token.refresh present\",\n    typeof output1.token.refresh === \"string\" &&\n      output1.token.refresh.length > 10,\n  );\n  TestValidator.predicate(\n    \"token.expired_at ISO str\",\n    typeof output1.token.expired_at === \"string\" &&\n      /T\\d{2}:\\d{2}:\\d{2}/.test(output1.token.expired_at),\n  );\n  TestValidator.predicate(\n    \"token.refreshable_until ISO str\",\n    typeof output1.token.refreshable_until === \"string\" &&\n      /T\\d{2}:\\d{2}:\\d{2}/.test(output1.token.refreshable_until),\n  );\n\n  // (2) Repeat and confirm id and created_at are identical, token differs\n  const output2: IMoodDiaryDiaryUser.IAuthorized =\n    await api.functional.auth.diaryUser.join(connection);\n  typia.assert(output2);\n  TestValidator.equals(\"id is consistent\", output2.id, output1.id);\n  TestValidator.equals(\n    \"created_at is consistent\",\n    output2.created_at,\n    output1.created_at,\n  );\n  TestValidator.notEquals(\n    \"token.access should differ\",\n    output2.token.access,\n    output1.token.access,\n  );\n\n  // (3) Try to submit extraneous data (should be ignored)\n  // We can't actually send extra data (no parameters accepted), but just verify call is robust\n  // (This step is skipped due to API definition)\n\n  // (4) Simulate system error (not tested here, would require test harness to force backend failure)\n}\n"},{"scenario":{"endpoint":{"path":"/auth/diaryUser/refresh","method":"post"},"draft":"Test refresh flow for the single logical diaryUser. (1) Obtain an initial access and refresh token by /auth/diaryUser/join or /login. (2) Call /refresh providing the refresh token. (3) Validate new access token and that returned diaryUser id, created_at remain unchanged. (4) Expectation: operation succeeds with valid token, but fails with expired/invalid token (returns appropriate error). (5) Attempting refresh without a token, or with a malformed/invalid token, triggers a clear error. (6) Ensure business invariants: single logical user, no state change to user id or created_at. (7) No personal or credential data is every checked or used.","functionName":"test_api_diaryuser_token_refresh","dependencies":[{"endpoint":{"path":"/auth/diaryUser/join","method":"post"},"purpose":"Obtain valid refresh token for the stateless diaryUser session before refresh operation."},{"endpoint":{"method":"post","path":"/auth/diaryUser/join"},"purpose":"Essential authentication prerequisite: \nThis join operation (post /auth/diaryUser/join) must be executed before any operations requiring 'diaryUser' role authorization. \n                It establishes the necessary user account and authentication context for the 'diaryUser' role, enabling subsequent API calls that depend on this specific authorization level. \n                Without this join operation, the main scenario endpoint and its dependencies will fail due to insufficient authentication credentials."}]},"location":"test/features/api/auth/test_api_diaryuser_token_refresh.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IMoodDiaryDiaryUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryDiaryUser\";\n\n/**\n * Validate the refresh flow for the single stateless diaryUser.\n *\n * 1. Obtain initial diaryUser session via /auth/diaryUser/join\n * 2. Call /auth/diaryUser/refresh (should return new access token with matching\n *    id/created_at)\n * 3. Validate user id and created_at are unchanged\n * 4. Attempt refresh with no token, expect error\n * 5. Attempt refresh with a deliberately corrupted/invalid token, expect error\n */\nexport async function test_api_diaryuser_token_refresh(\n  connection: api.IConnection,\n) {\n  // 1. Obtain initial diaryUser session\n  const session: IMoodDiaryDiaryUser.IAuthorized =\n    await api.functional.auth.diaryUser.join(connection);\n  typia.assert(session);\n\n  const prevAccess = session.token.access;\n  const prevRefresh = session.token.refresh;\n  const prevId = session.id;\n  const prevCreated = session.created_at;\n\n  // 2. Call refresh: /auth/diaryUser/refresh (should issue new access token)\n  connection.headers = { Authorization: prevRefresh };\n  const refreshed: IMoodDiaryDiaryUser.IAuthorized =\n    await api.functional.auth.diaryUser.refresh(connection);\n  typia.assert(refreshed);\n  TestValidator.equals(\"refreshed user id matches\", refreshed.id, prevId);\n  TestValidator.equals(\n    \"refreshed created_at matches\",\n    refreshed.created_at,\n    prevCreated,\n  );\n  TestValidator.notEquals(\n    \"new access token is different\",\n    refreshed.token.access,\n    prevAccess,\n  );\n\n  // 3. Refresh WITHOUT a token (should error)\n  const unauthConn: api.IConnection = { ...connection, headers: {} };\n  await TestValidator.error(\"refresh with no token fails\", async () => {\n    await api.functional.auth.diaryUser.refresh(unauthConn);\n  });\n\n  // 4. Refresh with an invalid token (should error)\n  const badConn: api.IConnection = {\n    ...connection,\n    headers: { Authorization: prevRefresh.slice(0, -2) + \"zz\" },\n  };\n  await TestValidator.error(\"refresh with tampered token fails\", async () => {\n    await api.functional.auth.diaryUser.refresh(badConn);\n  });\n}\n"},{"scenario":{"endpoint":{"path":"/moodDiary/diaryUser/moodEntries","method":"patch"},"draft":"Test retrieval of non-archived mood entries for the logical diaryUser. (1) Ensure at least one valid mood entry exists by invoking mood entry creation (POST /moodDiary/diaryUser/moodEntries) for today and/or previous days within the past 30 days. (2) Use the PATCH endpoint to request paginated entries. (3) Validate that (a) all returned entries have archived=false, (b) all are within the previous 30 days (Asia/Calcutta), (c) mood_type is one of the 8 allowed values, (d) pagination data is accurate, and (e) returned entry count does not exceed daily 3-entry limit. (4) Ensure archived or older entries are not returned, even if created. (5) Exercise filter/search arguments if provided: expect correct subsets. (6) Attempt with empty data set: expect empty list. (7) Expect errors for invalid pagination/search input. (8) All data belongs to the single logical user, no authentication/user separation.","functionName":"test_api_moodentry_list_recent_nonarchived_entries","dependencies":[{"endpoint":{"path":"/auth/diaryUser/join","method":"post"},"purpose":"Obtain access token for authorized request as the logical diaryUser."},{"endpoint":{"path":"/moodDiary/diaryUser/moodEntries","method":"post"},"purpose":"Create one or more mood entries in the past 30 days for subsequent retrieval testing."},{"endpoint":{"method":"post","path":"/auth/diaryUser/join"},"purpose":"Essential authentication prerequisite: \nThis join operation (post /auth/diaryUser/join) must be executed before any operations requiring 'diaryUser' role authorization. \n                It establishes the necessary user account and authentication context for the 'diaryUser' role, enabling subsequent API calls that depend on this specific authorization level. \n                Without this join operation, the main scenario endpoint and its dependencies will fail due to insufficient authentication credentials."}]},"location":"test/features/api/mood_diary/test_api_moodentry_list_recent_nonarchived_entries.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { EMoodType } from \"@ORGANIZATION/PROJECT-api/lib/structures/EMoodType\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IMoodDiaryDiaryUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryDiaryUser\";\nimport type { IMoodDiaryMoodEntry } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryMoodEntry\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageIMoodDiaryMoodEntry } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIMoodDiaryMoodEntry\";\n\n/**\n * Validate retrieval of non-archived mood entries for the single diaryUser.\n *\n * 1. Authenticate and get diaryUser session.\n * 2. Create mood entries for several days, varying mood_type and note, ensure\n *    daily 3 max.\n * 3. Use PATCH /moodDiary/diaryUser/moodEntries with no filters to get recent\n *    entries.\n *\n * - Validate all entries are archived=false and within 30 days.\n * - Mood types are one of the 8 allowed values.\n * - Entry count (in data and pagination) does not exceed total created.\n *\n * 4. Create an entry backdated to >31 days ago (simulate archived as old), ensure\n *    it's never present in results.\n * 5. Test pagination: request small page size, check correct\n *    pagination.meta/pages.\n * 6. Filter: query a single mood_type, ensure only those returned.\n * 7. Filter: search by note substring, all matches must contain string.\n * 8. Error: send invalid pagination (negative page/limit), expect error.\n * 9. Empty: use separate unauthenticated connection (fresh with empty dataset),\n *    expect empty list.\n */\nexport async function test_api_moodentry_list_recent_nonarchived_entries(\n  connection: api.IConnection,\n) {\n  // 1. Authenticate/join as diaryUser\n  const session: IMoodDiaryDiaryUser.IAuthorized =\n    await api.functional.auth.diaryUser.join(connection);\n  typia.assert(session);\n  const moods = [\n    \"happy\",\n    \"sad\",\n    \"anxious\",\n    \"excited\",\n    \"angry\",\n    \"calm\",\n    \"stressed\",\n    \"tired\",\n  ] as const;\n  const now = new Date();\n  // 2. Create 3 entries for today, with each allowed mood_type + 1 per prev 5 days\n  const createdEntries: IMoodDiaryMoodEntry[] = [];\n  for (let d = 0; d < 5; ++d) {\n    for (let n = 0; n < 3; ++n) {\n      const mood_type = RandomGenerator.pick(moods);\n      const note = RandomGenerator.paragraph({\n        sentences: 1,\n        wordMin: 8,\n        wordMax: 14,\n      });\n      const entry = await api.functional.moodDiary.diaryUser.moodEntries.create(\n        connection,\n        {\n          body: {\n            mood_type,\n            note,\n          } satisfies IMoodDiaryMoodEntry.ICreate,\n        },\n      );\n      typia.assert(entry);\n      createdEntries.push(entry);\n    }\n  }\n  // 3. Get recent mood entries (no filter)\n  const recentPage: IPageIMoodDiaryMoodEntry =\n    await api.functional.moodDiary.diaryUser.moodEntries.index(connection, {\n      body: {} satisfies IMoodDiaryMoodEntry.IRequest,\n    });\n  typia.assert(recentPage);\n  TestValidator.predicate(\n    \"all entries archived=false\",\n    recentPage.data.every((e) => e.archived === false),\n  );\n  const dayMs = 24 * 60 * 60 * 1000;\n  const cutoff = now.getTime() - 30 * dayMs;\n  TestValidator.predicate(\n    \"all entries within 30 days\",\n    recentPage.data.every((e) => new Date(e.created_at).getTime() >= cutoff),\n  );\n  TestValidator.predicate(\n    \"all mood_type valid\",\n    recentPage.data.every((e) => moods.includes(e.mood_type)),\n  );\n  TestValidator.predicate(\"count <= 15\", recentPage.data.length <= 15);\n  TestValidator.equals(\n    \"pagination.records is correct\",\n    recentPage.pagination.records,\n    recentPage.data.length,\n  );\n\n  // 4. Create an archived (old) entry by simulating system date -- not possible through allowed API, skip (checked by previous test).\n  // 5. Pagination: request limit 5, page 1\n  const pagedPage = await api.functional.moodDiary.diaryUser.moodEntries.index(\n    connection,\n    {\n      body: { limit: 5, page: 1 } satisfies IMoodDiaryMoodEntry.IRequest,\n    },\n  );\n  typia.assert(pagedPage);\n  TestValidator.equals(\n    \"limit match\",\n    pagedPage.data.length,\n    Math.min(5, createdEntries.length),\n  );\n  TestValidator.equals(\"page current==1\", pagedPage.pagination.current, 1);\n\n  // 6. Filter: mood_type only\n  const moodToFilter = RandomGenerator.pick(moods);\n  const moodTypePage =\n    await api.functional.moodDiary.diaryUser.moodEntries.index(connection, {\n      body: { mood_type: moodToFilter } satisfies IMoodDiaryMoodEntry.IRequest,\n    });\n  typia.assert(moodTypePage);\n  TestValidator.predicate(\n    \"all results same mood_type\",\n    moodTypePage.data.every((e) => e.mood_type === moodToFilter),\n  );\n\n  // 7. Filter: substring search by note\n  const targetEntry = createdEntries.find(\n    (e) => typeof e.note === \"string\" && e.note.length > 10,\n  );\n  if (targetEntry && typeof targetEntry.note === \"string\") {\n    const searchTerm = targetEntry.note.slice(0, 4);\n    const searchResultPage =\n      await api.functional.moodDiary.diaryUser.moodEntries.index(connection, {\n        body: { search: searchTerm } satisfies IMoodDiaryMoodEntry.IRequest,\n      });\n    typia.assert(searchResultPage);\n    TestValidator.predicate(\n      \"all search matches contain string\",\n      searchResultPage.data.every(\n        (e) => typeof e.note === \"string\" && e.note.includes(searchTerm),\n      ),\n    );\n  }\n  // 8. Error: invalid negative page/limit\n  await TestValidator.error(\"invalid pagination input rejected\", async () => {\n    await api.functional.moodDiary.diaryUser.moodEntries.index(connection, {\n      body: { page: -1, limit: -5 } satisfies IMoodDiaryMoodEntry.IRequest,\n    });\n  });\n  // 9. Empty: new unauthenticated connection, no data\n  const emptyConn: api.IConnection = { ...connection, headers: {} };\n  const emptyPage = await api.functional.moodDiary.diaryUser.moodEntries.index(\n    emptyConn,\n    {\n      body: {} satisfies IMoodDiaryMoodEntry.IRequest,\n    },\n  );\n  typia.assert(emptyPage);\n  TestValidator.equals(\"result empty\", emptyPage.data.length, 0);\n}\n"},{"scenario":{"endpoint":{"path":"/moodDiary/diaryUser/moodEntries","method":"post"},"draft":"This scenario tests creating a new mood diary entry for the single logical diaryUser, following all business rules. The test begins by establishing a valid session for the diaryUser using the join authentication endpoint. It then submits a mood diary entry with a valid mood type (one of: happy, sad, anxious, excited, angry, calm, stressed, tired) and an optional note of less than 500 Unicode characters. The entry must not exceed the daily limit of 3 entries (enforced per Asia/Calcutta calendar day). The scenario validates that the response contains the expected entry data (id, mood_type, note, created_at, archived=false) and that the created_at is set by the server and within the allowed day. It also checks that business validation is enforced: only allowed mood types, note length constraint, and correct timezone handling. Success criteria are the precise creation of an immutable mood entry, correct response body, and no errors when all constraints are met. Failure cases such as providing an invalid mood type, a note over 500 characters, or attempting a fourth entry on the same day should return detailed error messages as per business rules.","functionName":"test_api_mood_entry_creation_with_valid_data","dependencies":[{"endpoint":{"path":"/auth/diaryUser/join","method":"post"},"purpose":"Obtain a valid access token for the single logical diaryUser to enable protected mood entry creation."},{"endpoint":{"method":"post","path":"/auth/diaryUser/join"},"purpose":"Essential authentication prerequisite: \nThis join operation (post /auth/diaryUser/join) must be executed before any operations requiring 'diaryUser' role authorization. \n                It establishes the necessary user account and authentication context for the 'diaryUser' role, enabling subsequent API calls that depend on this specific authorization level. \n                Without this join operation, the main scenario endpoint and its dependencies will fail due to insufficient authentication credentials."}]},"location":"test/features/api/mood_entry/test_api_mood_entry_creation_with_valid_data.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { EMoodType } from \"@ORGANIZATION/PROJECT-api/lib/structures/EMoodType\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IMoodDiaryDiaryUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryDiaryUser\";\nimport type { IMoodDiaryMoodEntry } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryMoodEntry\";\n\n/**\n * Validate creation of a new mood diary entry for the (only) diary user.\n *\n * This test:\n *\n * 1. Authenticates/logs in as the logical diaryUser via join endpoint\n * 2. Submits a valid mood entry (allowed mood_type; note ≤500 chars or omitted)\n * 3. Validates the entry is created with the expected server-generated fields\n * 4. Confirms all business constraints: mood_type allowed; note length ≤500;\n *    archived is false; user id binding; etc.\n * 5. Attempts up to 3 creations within a single day (Asia/Calcutta), and verifies\n *    all succeed\n */\nexport async function test_api_mood_entry_creation_with_valid_data(\n  connection: api.IConnection,\n) {\n  // 1. Join/log in as diaryUser\n  const auth: IMoodDiaryDiaryUser.IAuthorized =\n    await api.functional.auth.diaryUser.join(connection);\n  typia.assert(auth);\n\n  // All 8 allowed mood types\n  const allowedMoods = [\n    \"happy\",\n    \"sad\",\n    \"anxious\",\n    \"excited\",\n    \"angry\",\n    \"calm\",\n    \"stressed\",\n    \"tired\",\n  ] as const;\n\n  // 2. Create up to three entries using all different valid mood values and optional notes\n  const createdEntries: IMoodDiaryMoodEntry[] = [];\n  for (const idx of [0, 1, 2]) {\n    const mood_type = RandomGenerator.pick(allowedMoods);\n    // Randomly decide if note is present, null, or omitted\n    let note: string | null | undefined;\n    switch (RandomGenerator.pick([0, 1, 2])) {\n      case 0:\n        note = undefined;\n        break;\n      case 1:\n        note = null;\n        break;\n      case 2:\n        // Generate a random note ≤ 500 chars\n        note = RandomGenerator.paragraph({\n          sentences: RandomGenerator.pick([5, 10, 15]),\n          wordMin: 4,\n          wordMax: 12,\n        }).slice(0, 500);\n        break;\n    }\n    const createBody = {\n      mood_type,\n      ...(note !== undefined ? { note } : {}),\n    } satisfies IMoodDiaryMoodEntry.ICreate;\n    const entry = await api.functional.moodDiary.diaryUser.moodEntries.create(\n      connection,\n      { body: createBody },\n    );\n    typia.assert(entry);\n    TestValidator.equals(\n      \"user id matches\",\n      entry.mood_diary_diaryuser_id,\n      auth.id,\n    );\n    TestValidator.equals(\"mood_type matches\", entry.mood_type, mood_type);\n    TestValidator.equals(\"archived must be false\", entry.archived, false);\n    if (note === undefined || note === null) {\n      TestValidator.equals(\n        \"note matches missing or null\",\n        entry.note,\n        note ?? null,\n      );\n    } else {\n      TestValidator.equals(\"note matches non-null\", entry.note, note);\n      TestValidator.predicate(\"note length ≤ 500\", note.length <= 500);\n    }\n    TestValidator.predicate(\n      \"created_at is ISO8601\",\n      typeof entry.created_at === \"string\" &&\n        /^\\d{4}-\\d{2}-\\d{2}T[0-9:.]+(Z|([+\\-][0-9:]+))$/.test(entry.created_at),\n    );\n    createdEntries.push(entry);\n  }\n\n  // 3 entries must have unique IDs and valid payloads\n  const ids = createdEntries.map((e) => e.id);\n  TestValidator.predicate(\n    \"all entries have unique ids\",\n    ids.length === new Set(ids).size,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/moodDiary/diaryUser/moodEntries/{entryId}","method":"get"},"draft":"This scenario tests fetching details for a single mood diary entry by its unique id. After obtaining a valid session for the diaryUser via the join authentication endpoint, a mood diary entry is first created to acquire a valid entryId. The test then requests the mood entry details using the returned id. It verifies that the response includes id, a valid mood_type from the allowed list, optional note, created_at in UTC, and archived flag set to false. The test also ensures that only non-archived entries (within 30 days) are retrievable. Success criteria include accurate field values and full data match with what was submitted during mood entry creation. Error cases to check: requesting with an invalid or non-existent entryId, or trying to fetch an archived (older than 30 days) entry, both of which should result in a clear error. The dependency chain fully implements proper data and context generation.","functionName":"test_api_mood_entry_detail_retrieval_by_id","dependencies":[{"endpoint":{"path":"/auth/diaryUser/join","method":"post"},"purpose":"Establish session for the single logical diaryUser prior to creating or retrieving mood entries."},{"endpoint":{"path":"/moodDiary/diaryUser/moodEntries","method":"post"},"purpose":"Create a mood diary entry so that a valid entryId is available for the detail retrieval test."},{"endpoint":{"method":"post","path":"/auth/diaryUser/join"},"purpose":"Essential authentication prerequisite: \nThis join operation (post /auth/diaryUser/join) must be executed before any operations requiring 'diaryUser' role authorization. \n                It establishes the necessary user account and authentication context for the 'diaryUser' role, enabling subsequent API calls that depend on this specific authorization level. \n                Without this join operation, the main scenario endpoint and its dependencies will fail due to insufficient authentication credentials."}]},"location":"test/features/api/mood_diary/test_api_mood_entry_detail_retrieval_by_id.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { EMoodType } from \"@ORGANIZATION/PROJECT-api/lib/structures/EMoodType\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IMoodDiaryDiaryUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryDiaryUser\";\nimport type { IMoodDiaryMoodEntry } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryMoodEntry\";\n\n/**\n * E2E test for retrieving mood diary entry details by id as a diaryUser.\n *\n * 1. Establish session for diaryUser (POST /auth/diaryUser/join).\n * 2. Create a valid mood diary entry as diaryUser (choose mood_type from enum,\n *    supply/omit note randomly).\n * 3. Retrieve the entry details using GET\n *    /moodDiary/diaryUser/moodEntries/{entryId}.\n *\n *    - Check fields: id, mood_type (enum), note (optional), created_at\n *         (ISO8601), archived (false)\n *    - Assert that data matches what was submitted in creation\n * 4. Negative test: Try to retrieve with a random invalid UUID (should error)\n * 5. Negative test: Simulate an archived entry by creating an old entry\n *    (created_at > 30 days ago), check retrieval errors.\n *\n *    - If archive cannot be simulated directly, explain logic / skip in review.\n */\nexport async function test_api_mood_entry_detail_retrieval_by_id(\n  connection: api.IConnection,\n) {\n  // 1. Join as diaryUser, get session/token\n  const auth = await api.functional.auth.diaryUser.join(connection);\n  typia.assert(auth);\n\n  // 2. Create mood entry (random allowed mood_type, sometimes with note)\n  const moodTypes = [\n    \"happy\",\n    \"sad\",\n    \"anxious\",\n    \"excited\",\n    \"angry\",\n    \"calm\",\n    \"stressed\",\n    \"tired\",\n  ] as const;\n  const mood_type = RandomGenerator.pick(moodTypes);\n  const note =\n    Math.random() > 0.5\n      ? RandomGenerator.paragraph({ sentences: 2 })\n      : undefined;\n  const entryCreateBody = {\n    mood_type,\n    note,\n  } satisfies IMoodDiaryMoodEntry.ICreate;\n  const created = await api.functional.moodDiary.diaryUser.moodEntries.create(\n    connection,\n    {\n      body: entryCreateBody,\n    },\n  );\n  typia.assert(created);\n\n  // 3. Retrieve entry by id\n  const fetched = await api.functional.moodDiary.diaryUser.moodEntries.at(\n    connection,\n    {\n      entryId: created.id,\n    },\n  );\n  typia.assert(fetched);\n  TestValidator.equals(\"mood entry id matches\", fetched.id, created.id);\n  TestValidator.equals(\n    \"mood_type matches\",\n    fetched.mood_type,\n    created.mood_type,\n  );\n  TestValidator.equals(\"note matches\", fetched.note, created.note ?? null);\n  TestValidator.equals(\n    \"created_at matches\",\n    fetched.created_at,\n    created.created_at,\n  );\n  TestValidator.equals(\"archived must be false\", fetched.archived, false);\n\n  // 4. Negative - fetch with invalid/random uuid\n  await TestValidator.error(\"fetching with invalid id fails\", async () => {\n    await api.functional.moodDiary.diaryUser.moodEntries.at(connection, {\n      entryId: typia.random<string & tags.Format<\"uuid\">>(),\n    });\n  });\n\n  // 5. Negative - archived entry retrieval (simulate if possible)\n  // Business logic: entries older than 30 days are auto-archived and rejected for GET.\n  // Since created_at is generated server-side and cannot be set in test, cannot directly create an archived entry.\n  // So, this branch is not implementable via API (left for documentation, no code).\n}\n"},{"scenario":{"endpoint":{"path":"/moodDiary/diaryUser/moodEntries/weeklySummary","method":"get"},"draft":"This scenario validates the weekly summary generation for moods over the last 7 days (excluding today). It starts by authenticating as the diaryUser using the join endpoint. Multiple mood diary entries with various allowed mood types are then created across several days within the last week. The test invokes the summary endpoint and verifies that the daily and total mood counts are correctly aggregated per business rules—from entries created within the covered date range, excluding today and ignoring archived data. The reported start and end dates of the summary are checked to ensure accuracy, and all 8 mood types must appear with correct counts (zero if no entries). The scenario includes edge cases: a week with no data (all counts zero), as well as combinations of entries for only some moods. Error cases should reflect only system-level failures, as the endpoint always returns a summary (empty or populated). Success criteria are precise adherence to aggregation, time window, and type rules.","functionName":"test_api_mood_weekly_summary_aggregation","dependencies":[{"endpoint":{"path":"/auth/diaryUser/join","method":"post"},"purpose":"Authenticate as the single logical diaryUser so mood entries can be created and weekly summary can be accessed."},{"endpoint":{"path":"/moodDiary/diaryUser/moodEntries","method":"post"},"purpose":"Create several mood entries across different days and mood types to populate the data needed for accurate weekly summary aggregation testing."},{"endpoint":{"method":"post","path":"/auth/diaryUser/join"},"purpose":"Essential authentication prerequisite: \nThis join operation (post /auth/diaryUser/join) must be executed before any operations requiring 'diaryUser' role authorization. \n                It establishes the necessary user account and authentication context for the 'diaryUser' role, enabling subsequent API calls that depend on this specific authorization level. \n                Without this join operation, the main scenario endpoint and its dependencies will fail due to insufficient authentication credentials."}]},"location":"test/features/api/mood_diary_mood_entry/test_api_mood_weekly_summary_aggregation.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { EMoodType } from \"@ORGANIZATION/PROJECT-api/lib/structures/EMoodType\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IMoodDiaryDiaryUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryDiaryUser\";\nimport type { IMoodDiaryMoodEntry } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryMoodEntry\";\nimport type { IMoodDiaryMoodEntryWeeklySummary } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryMoodEntryWeeklySummary\";\n\n/**\n * Validate aggregation of weekly mood summary, including correct handling of:\n *\n * - All 8 moods present with correct counts (some zero)\n * - Daily and total mood counts over the correct 7-day window (Asia/Calcutta)\n * - Archived and today-excluded enforcement\n * - All-zero state when there is no data in the week\n */\nexport async function test_api_mood_weekly_summary_aggregation(\n  connection: api.IConnection,\n) {\n  // Step 1: Authenticate as diaryUser (join)\n  const auth: IMoodDiaryDiaryUser.IAuthorized =\n    await api.functional.auth.diaryUser.join(connection);\n  typia.assert(auth);\n\n  // Helper: List of all mood types\n  const moodTypes = [\n    \"happy\",\n    \"sad\",\n    \"anxious\",\n    \"excited\",\n    \"angry\",\n    \"calm\",\n    \"stressed\",\n    \"tired\",\n  ] as const satisfies EMoodType[];\n\n  // Step 2(a): Weekly summary with NO data (should be all-zeros)\n  const summaryEmpty: IMoodDiaryMoodEntryWeeklySummary =\n    await api.functional.moodDiary.diaryUser.moodEntries.weeklySummary(\n      connection,\n    );\n  typia.assert(summaryEmpty);\n\n  // All moods with 0s\n  for (const mood of moodTypes) {\n    const stat = summaryEmpty.mood_counts.find((m) => m.mood_type === mood);\n    TestValidator.predicate(`mood ${mood} present in all-zero state`, !!stat);\n    TestValidator.equals(\n      `total_count=0 for mood ${mood} in empty summary`,\n      stat!.total_count,\n      0,\n    );\n    TestValidator.equals(\n      `daily_counts=0s for mood ${mood} in empty summary`,\n      stat!.daily_counts,\n      Array(7).fill(0),\n    );\n  }\n\n  // Step 2(b): Insert a variety of valid entries across recent week (excluding today)\n  const baseDay = new Date();\n  baseDay.setHours(0, 0, 0, 0); // Start of today\n  const msPerDay = 24 * 60 * 60 * 1000;\n  const weekDates = ArrayUtil.repeat(7, (i) => {\n    // i = 0: 7 days ago (start), i = 6: yesterday (end)\n    const d = new Date(baseDay.getTime() - msPerDay * (7 - i));\n    // Need YYYY-MM-DD string, local Asia/Calcutta date (simulate)\n    const y = d.getFullYear();\n    const m = String(d.getMonth() + 1).padStart(2, \"0\");\n    const day = String(d.getDate()).padStart(2, \"0\");\n    return `${y}-${m}-${day}`;\n  });\n\n  // We'll insert: happy (1x on day0, 2x on day3), sad (1x on day2), angry (2x on day1), excited (3x on day4), rest skipped\n  const entryPlan: Array<{ dayIdx: number; mood: EMoodType; count: number }> = [\n    { dayIdx: 0, mood: \"happy\", count: 1 },\n    { dayIdx: 3, mood: \"happy\", count: 2 },\n    { dayIdx: 2, mood: \"sad\", count: 1 },\n    { dayIdx: 1, mood: \"angry\", count: 2 },\n    { dayIdx: 4, mood: \"excited\", count: 3 },\n  ];\n\n  for (const plan of entryPlan) {\n    for (let i = 0; i < plan.count; ++i) {\n      // Only set created_at if backend allows override, but assume system time\n      await api.functional.moodDiary.diaryUser.moodEntries.create(connection, {\n        body: {\n          mood_type: plan.mood,\n          note: RandomGenerator.paragraph({ sentences: 2 }),\n        } satisfies IMoodDiaryMoodEntry.ICreate,\n      });\n    }\n  }\n\n  // Step 3: Request weekly summary again\n  const summaryPopulated: IMoodDiaryMoodEntryWeeklySummary =\n    await api.functional.moodDiary.diaryUser.moodEntries.weeklySummary(\n      connection,\n    );\n  typia.assert(summaryPopulated);\n\n  // Step 4: Validate core fields and aggregation\n  // 4.1 - Date window\n  TestValidator.equals(\n    \"start_date should match start of 7d window\",\n    summaryPopulated.start_date,\n    weekDates[0],\n  );\n  TestValidator.equals(\n    \"end_date should match end of 7d window (yesterday)\",\n    summaryPopulated.end_date,\n    weekDates[6],\n  );\n\n  // 4.2 - All 8 mood types present with correct total/daily counts\n  for (const mood of moodTypes) {\n    const expectedDayCounts = Array(7).fill(0);\n    for (const plan of entryPlan) {\n      if (plan.mood === mood) {\n        expectedDayCounts[plan.dayIdx] += plan.count;\n      }\n    }\n    const total = expectedDayCounts.reduce((a, b) => a + b, 0);\n    const stat = summaryPopulated.mood_counts.find((m) => m.mood_type === mood);\n    TestValidator.predicate(\n      `mood ${mood} present in summary after entries`,\n      !!stat,\n    );\n    TestValidator.equals(\n      `total_count for mood ${mood} after entries`,\n      stat!.total_count,\n      total,\n    );\n    TestValidator.equals(\n      `daily_counts for mood ${mood} after entries`,\n      stat!.daily_counts,\n      expectedDayCounts,\n    );\n  }\n\n  // 4.3 - All moods present, no duplicates\n  TestValidator.equals(\n    \"all 8 moods present (no extra/dup)\",\n    summaryPopulated.mood_counts.map((c) => c.mood_type).sort(),\n    [...moodTypes].sort(),\n  );\n}\n"}],"compiled":{"type":"success"},"created_at":"2025-09-14T15:23:44.778Z","completed_at":"2025-09-14T15:27:46.940Z","step":0},{"id":"019948d7-c9e9-750c-89f1-c4fe3894d393","type":"userMessage","contents":[{"type":"text","text":"Now let's go with Implementation Complete"}],"created_at":"2025-09-14T15:28:45.545Z"},{"type":"realize","id":"019948e0-0638-7527-b333-e1c2b70466eb","reason":"All previous stages (requirements analysis, database design, API interface, and test code) are successfully complete for the Mood Diary app. Proceeding to implement the actual business logic, enforcing all features and constraints as specified.","authorizations":[{"error_analysis":"1. Provider (src/providers/authorize/diaryUserAuthorize.ts):\n- Error: Cannot find module '../../decorators/payload/DiaryuserPayload'. (error 2307)\n- Error: Cannot find name 'DiaryUserPayload'. (error 2304)\nRoot cause: The generated payload and its import use 'DiaryUserPayload' (PascalCase), but per naming conventions and user direction, it should be 'DiaryuserPayload' (PascalCase, first letter of role only capitalized, rest lowercase).\n\n2. Decorator (src/decorators/DiaryUserAuth.ts):\n- Error: Cannot find module '../providers/authorize/diaryuserAuthorize'. (error 2307)\n- Error: Cannot find name 'diaryUserAuthorize'. (error 2552)\nRoot cause: The file and symbol names should use 'diaryuserAuthorize' (camelCase, first letter lowercase, rest match role case), not 'diaryUserAuthorize'.\n\nGeneral: All references to the provider, decorator, and payload must use 'diaryuserAuthorize', 'DiaryuserAuth', and 'DiaryuserPayload' respectively to ensure consistency and match naming rules.","solution_guidance":"1. Update all naming to correct role capitalization: use 'diaryuserAuthorize' for provider function and file, 'DiaryuserAuth' for decorator, 'DiaryuserPayload' for payload type.\n2. In provider, update the import statement to '../../decorators/payload/DiaryuserPayload' and type usages to 'DiaryuserPayload'.\n3. In decorator, update the import path to '../providers/authorize/diaryuserAuthorize' and use 'diaryuserAuthorize' everywhere, including the Singleton.\n4. Ensure the function and type names match exactly the corrected PascalCase/camelCase role-cased names as per user instruction and conventions.\n5. Test that all references are now consistent, all imports resolve, and all symbols exist and compile.","provider":{"name":"diaryuserAuthorize","content":"import { ForbiddenException } from \"@nestjs/common\";\n\nimport { MyGlobal } from \"../../MyGlobal\";\nimport { jwtAuthorize } from \"./jwtAuthorize\";\nimport { DiaryuserPayload } from \"../../decorators/payload/DiaryuserPayload\";\n\n/**\n * Authorize and authenticate the Diaryuser role for the Mood Diary app.\n * Ensures JWT token is valid and the logical diaryuser exists in the system.\n *\n * @param request The HTTP request object containing headers\n * @returns DiaryuserPayload containing the top-level diaryuser ID and role type\n */\nexport async function diaryuserAuthorize(request: {\n  headers: {\n    authorization?: string;\n  };\n}): Promise<DiaryuserPayload> {\n  const payload: DiaryuserPayload = jwtAuthorize({ request }) as DiaryuserPayload;\n\n  if (payload.type !== \"diaryUser\") {\n    throw new ForbiddenException(`You're not ${payload.type}`);\n  }\n\n  // payload.id contains the top-level diaryuser table ID\n  const diaryuser = await MyGlobal.prisma.mood_diary_diaryusers.findFirst({\n    where: {\n      id: payload.id\n    },\n  });\n\n  if (diaryuser === null) {\n    throw new ForbiddenException(\"You're not enrolled\");\n  }\n\n  return payload;\n}\n","location":"src/providers/authorize/diaryuserAuthorize.ts"},"decorator":{"name":"DiaryuserAuth","content":"import { SwaggerCustomizer } from \"@nestia/core\";\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { diaryuserAuthorize } from \"../providers/authorize/diaryuserAuthorize\";\n\n/**\n * Parameter decorator for authenticating Diaryuser role via JWT.\n * Injects the authenticated DiaryuserPayload into Controller method parameters.\n */\nexport const DiaryuserAuth =\n  (): ParameterDecorator =>\n  (\n    target: object,\n    propertyKey: string | symbol | undefined,\n    parameterIndex: number,\n  ): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({\n        bearer: [],\n      });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_0: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return diaryuserAuthorize(request);\n  })(),\n);\n","location":"src/decorators/DiaryuserAuth.ts"},"payload":{"name":"DiaryuserPayload","location":"src/decorators/payload/DiaryuserPayload.ts","content":"import { tags } from \"typia\";\n\n/**\n * Payload interface for Diaryuser JWT authentication context. Contains the\n * top-level logical mood_diary_diaryusers ID and role discriminator.\n */\nexport interface DiaryuserPayload {\n  /** The logical diaryuser primary key (mood_diary_diaryusers.id) */\n  id: string & tags.Format<\"uuid\">;\n  /** Discriminator for Diaryuser role */\n  type: \"diaryUser\";\n}\n"},"role":{"name":"diaryUser","description":"A user of the Mood Diary application who can log up to 3 mood entries per day, add personal notes, view their entries and weekly mood summaries, but cannot edit or delete entries. No registration, all are treated as a single logical user. Role allows full access to mood logging and summary features via API.","kind":"member"}}],"functions":[{"location":"src/providers/postauthDiaryUserJoin.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { IMoodDiaryDiaryUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryDiaryUser\";\nimport { DiaryuserPayload } from \"../decorators/payload/DiaryuserPayload\";\n\n/**\n * Obtain session token as the logical diaryUser (single-user, from\n * mood_diary_diaryusers), no registration or authentication required.\n *\n * This operation issues a short-lived access token and token metadata for the\n * application's single logical diary user. No registration, credentials, or\n * user input is ever required; this is stateless, non-personalized access, with\n * no sensitive data. Token includes only id and role discriminator (type), with\n * correct expiry fields.\n *\n * @returns Authorized session object for the one logical diary user, with JWT\n *   token info and user id/created_at.\n * @throws {Error} If the system's logical diary user does not exist in the\n *   database (system setup error).\n */\nexport async function postauthDiaryUserJoin(): Promise<IMoodDiaryDiaryUser.IAuthorized> {\n  // Fetch the single logical diary user; must always exist (1-user system)\n  const user = await MyGlobal.prisma.mood_diary_diaryusers.findFirst();\n  if (!user) {\n    throw new Error(\n      \"The logical diary user does not exist in the system database.\",\n    );\n  }\n\n  // Timestamps: always use string & tags.Format<'date-time'>\n  const now: string & tags.Format<\"date-time\"> = toISOStringSafe(new Date());\n  // Calculate expiries using string timestamps\n  const accessExpires: string & tags.Format<\"date-time\"> = toISOStringSafe(\n    new Date(Date.parse(now) + 60 * 60 * 1000),\n  );\n  const refreshExpires: string & tags.Format<\"date-time\"> = toISOStringSafe(\n    new Date(Date.parse(now) + 7 * 24 * 60 * 60 * 1000),\n  );\n\n  // JWT: diary user payload as per DiaryuserPayload definition\n  const tokenPayload = {\n    id: user.id,\n    type: \"diaryUser\",\n  };\n\n  const accessToken = jwt.sign(tokenPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"1h\",\n    issuer: \"autobe\",\n  });\n\n  const refreshToken = jwt.sign(tokenPayload, MyGlobal.env.JWT_SECRET_KEY, {\n    expiresIn: \"7d\",\n    issuer: \"autobe\",\n  });\n\n  return {\n    id: user.id,\n    created_at: toISOStringSafe(user.created_at),\n    token: {\n      access: accessToken,\n      refresh: refreshToken,\n      expired_at: accessExpires,\n      refreshable_until: refreshExpires,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/diaryUser/join"},"name":"postauthDiaryUserJoin"},{"location":"src/providers/postauthDiaryUserLogin.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { IMoodDiaryDiaryUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryDiaryUser\";\nimport { DiaryuserPayload } from \"../decorators/payload/DiaryuserPayload\";\n\n/**\n * OpenAPI-compliant login endpoint for the single logical diaryUser\n * (mood_diary_diaryusers); no credentials accepted, always issues a token.\n *\n * This endpoint allows any client to perform a login operation and receive a\n * valid access token for the Mood Diary API. No authentication or credentials\n * are required. The operation issues a new session token and exposes only the\n * logical mood diary user's id and created_at timestamp. Tokens are generated\n * for OpenAPI/JWT compatibility, not security. Any client may invoke this\n * endpoint.\n *\n * @param props - Object containing the authenticated DiaryuserPayload\n *   (diaryUser)\n * @returns Authorized session information (IMoodDiaryDiaryUser.IAuthorized) for\n *   the logical diary user, including access and refresh tokens, session\n *   expiration metadata, id, and created_at.\n * @throws {Error} If the logical diaryUser record is not found in the database\n *   (system invariant error).\n */\nexport async function postauthDiaryUserLogin(props: {\n  diaryUser: DiaryuserPayload;\n}): Promise<IMoodDiaryDiaryUser.IAuthorized> {\n  // Lookup the unique logical diary user\n  const diaryUser = await MyGlobal.prisma.mood_diary_diaryusers.findFirst();\n  if (!diaryUser) {\n    throw new Error(\"Logical diary user not found in database\");\n  }\n\n  // ISO timestamp strings for token expiry metadata\n  const accessExpires: string & tags.Format<\"date-time\"> = toISOStringSafe(\n    new Date(Date.now() + 1000 * 60 * 60),\n  ); // 1hr\n  const refreshExpires: string & tags.Format<\"date-time\"> = toISOStringSafe(\n    new Date(Date.now() + 1000 * 60 * 60 * 24 * 7),\n  ); // 7 days\n\n  // Create JWT access and refresh tokens for the mood diary user\n  const accessToken = jwt.sign(\n    { id: diaryUser.id, type: \"diaryUser\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"1h\", issuer: \"autobe\" },\n  );\n  const refreshToken = jwt.sign(\n    { id: diaryUser.id, type: \"diaryUser\", tokenType: \"refresh\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    { expiresIn: \"7d\", issuer: \"autobe\" },\n  );\n\n  return {\n    id: diaryUser.id,\n    created_at: toISOStringSafe(diaryUser.created_at),\n    token: {\n      access: accessToken,\n      refresh: refreshToken,\n      expired_at: accessExpires,\n      refreshable_until: refreshExpires,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/diaryUser/login"},"name":"postauthDiaryUserLogin"},{"location":"src/providers/postauthDiaryUserRefresh.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { IMoodDiaryDiaryUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryDiaryUser\";\nimport { DiaryuserPayload } from \"../decorators/payload/DiaryuserPayload\";\n\n/**\n * Refreshes the session for the logical diaryUser by issuing a new access token\n * given a valid refresh token (mood_diary_diaryusers, single-user context).\n *\n * Allows the diaryUser (the single logical user in the Mood Diary app) to\n * refresh their session token and extend access without any login or further\n * interaction. Only a valid refresh token is required; no personal credentials\n * or data are checked. The system returns a new access token and the diary\n * user's id and created_at values from mood_diary_diaryusers. This supports\n * seamless, stateless session continuation in the single-user context. All\n * error and security handling is limited to token verification. There is no\n * multi-user management or credential validation. This operation presumes only\n * one logical user exists. Related operation: join (to obtain initial token).\n *\n * @param props - Object containing the authenticated diaryUser payload\n * @param props.diaryUser - The payload containing the top-level logical diary\n *   user's ID and type\n * @returns Updated authorized session with new token for the single logical\n *   diaryUser, including id and created_at from mood_diary_diaryusers\n * @throws {Error} If diary user does not exist in the system\n */\nexport async function postauthDiaryUserRefresh(props: {\n  diaryUser: DiaryuserPayload;\n}): Promise<IMoodDiaryDiaryUser.IAuthorized> {\n  const { diaryUser } = props;\n  // Find the logical diary user by ID (must always exist in this business domain)\n  const user = await MyGlobal.prisma.mood_diary_diaryusers.findFirst({\n    where: { id: diaryUser.id },\n  });\n  if (!user) {\n    throw new Error(\"Diary user not found\");\n  }\n  // Calculate ISO string timestamps (never use Date as type)\n  const now = toISOStringSafe(new Date());\n  // Calculate expiration times (1 hour for access token, 7 days for refresh token)\n  const accessExpires = toISOStringSafe(new Date(Date.now() + 60 * 60 * 1000)); // 1 hour\n  const refreshExpires = toISOStringSafe(\n    new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n  ); // 7 days\n\n  // Generate access token with strict payload structure\n  const access = jwt.sign(\n    {\n      id: user.id,\n      type: \"diaryUser\",\n    },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"1h\",\n      issuer: \"autobe\",\n    },\n  );\n  // Generate refresh token with same id/type, for continued session renewal\n  const refresh = jwt.sign(\n    {\n      id: user.id,\n      type: \"diaryUser\",\n    },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"7d\",\n      issuer: \"autobe\",\n    },\n  );\n  // Return strictly-typed authorized DTO; all fields required, no native Date\n  return {\n    id: user.id,\n    created_at: toISOStringSafe(user.created_at),\n    token: {\n      access,\n      refresh,\n      expired_at: accessExpires,\n      refreshable_until: refreshExpires,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/diaryUser/refresh"},"name":"postauthDiaryUserRefresh"},{"location":"src/providers/patchmoodDiaryDiaryUserMoodEntries.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { IMoodDiaryMoodEntry } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryMoodEntry\";\nimport { IPageIMoodDiaryMoodEntry } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIMoodDiaryMoodEntry\";\nimport { DiaryuserPayload } from \"../decorators/payload/DiaryuserPayload\";\n\n/**\n * Retrieve a paginated list of non-archived mood diary entries for the single\n * logical user from mood_diary_mood_entries.\n *\n * This operation fetches recent mood diary entries for the current diaryUser,\n * supporting search, filtering, sorting, and pagination. Only unarchived\n * (archived=false) entries created within the last 30 days are included. All\n * fields (`id`, `mood_type`, `note`, `created_at`, `archived`) strictly match\n * business and type requirements. Pagination and search filters are provided\n * through the request body. Returned entries include all required properties\n * per IMoodDiaryMoodEntry.\n *\n * @param props - Object containing required DiaryuserPayload and filter/query\n *   body.\n * @param props.diaryUser - Authenticated diaryUser payload (for filtering to\n *   owner only).\n * @param props.body - Search, filter, and pagination options (IRequest).\n * @returns Paginated list of recent, non-archived mood diary entries with full\n *   result and pagination info.\n * @throws {Error} If any pagination parameter is invalid (page/limit <= 0 or\n *   limit > 100).\n */\nexport async function patchmoodDiaryDiaryUserMoodEntries(props: {\n  diaryUser: DiaryuserPayload;\n  body: IMoodDiaryMoodEntry.IRequest;\n}): Promise<IPageIMoodDiaryMoodEntry> {\n  const now = toISOStringSafe(new Date());\n  // Calculate 30-days-ago cutoff (ISO8601 string)\n  const cutoffTimestamp = new Date(Date.parse(now) - 30 * 24 * 60 * 60 * 1000);\n  const cutoff = toISOStringSafe(cutoffTimestamp);\n  // Page/limit logic with branding. Default safely. Enforce max/min.\n  let page = props.body.page;\n  let limit = props.body.limit;\n  if (page == null || page < 1) page = 1;\n  if (limit == null || limit < 1) limit = 15;\n  if (limit > 100) limit = 100;\n  // Error if negative or zero\n  if (page < 1 || limit < 1) throw new Error(\"Invalid pagination parameters\");\n  const skip = (Number(page) - 1) * Number(limit);\n  // Compose created_at date filter\n  const createdAtFilter: Record<string, string> = { gte: cutoff };\n  if (props.body.from_date) {\n    createdAtFilter.gte = props.body.from_date;\n  }\n  if (props.body.to_date) {\n    createdAtFilter.lte = props.body.to_date;\n  }\n  // Compose Prisma where condition, only include optional fields if present\n  const where = {\n    mood_diary_diaryuser_id: props.diaryUser.id,\n    archived: false,\n    created_at: createdAtFilter,\n    ...(props.body.mood_type != null && { mood_type: props.body.mood_type }),\n    ...(props.body.search != null &&\n      props.body.search.length > 0 && {\n        note: { contains: props.body.search },\n      }),\n  };\n  // Order by created_at: default desc, or asc if specified\n  const sortDir = props.body.sort_dir === \"asc\" ? \"asc\" : \"desc\";\n  const orderBy = [{ created_at: sortDir }];\n  // Query paginated results and total count in parallel\n  const [rows, total] = await Promise.all([\n    MyGlobal.prisma.mood_diary_mood_entries.findMany({\n      where,\n      orderBy,\n      skip: Number(skip),\n      take: Number(limit),\n    }),\n    MyGlobal.prisma.mood_diary_mood_entries.count({ where }),\n  ]);\n  // Map DB model → API DTO, handle branding & nullables\n  const data = rows.map((entry) => ({\n    id: entry.id,\n    mood_diary_diaryuser_id: entry.mood_diary_diaryuser_id,\n    mood_type: entry.mood_type,\n    note: entry.note === null ? undefined : entry.note,\n    created_at: toISOStringSafe(entry.created_at),\n    archived: entry.archived,\n  }));\n  // Calculate pagination, enforce branding with Number() so branded types are preserved\n  return {\n    pagination: {\n      current: Number(page),\n      limit: Number(limit),\n      records: Number(total),\n      pages: Math.ceil(total / Number(limit)),\n    },\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/moodDiary/diaryUser/moodEntries"},"name":"patchmoodDiaryDiaryUserMoodEntries"},{"location":"src/providers/postmoodDiaryDiaryUserMoodEntries.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { IMoodDiaryMoodEntry } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryMoodEntry\";\nimport { DiaryuserPayload } from \"../decorators/payload/DiaryuserPayload\";\n\n/**\n * Create a new mood diary entry for the logical user.\n *\n * This operation allows the single logical diary user to submit a new mood\n * diary entry in the mood_diary_mood_entries table. Business rules enforce no\n * more than 3 entries per calendar day (Asia/Calcutta time), required mood_type\n * from allowed values, note must be ≤500 chars if present, and all timestamps\n * are set reliably by the server. The created_at value is always the current\n * Asia/Calcutta time in ISO8601, regardless of user input. Entries are\n * immutable. All validation failures produce detailed error messages.\n *\n * @param props - Object containing authentication payload and entry creation\n *   body\n * @param props.diaryUser - Authenticated logical diaryuser (single-user\n *   scenario)\n * @param props.body - Entry data (mood_type and optional note)\n * @returns The newly created mood diary entry, never editable or deletable\n * @throws {Error} If entry limit is exceeded, invalid mood, or note too long\n */\nexport async function postmoodDiaryDiaryUserMoodEntries(props: {\n  diaryUser: DiaryuserPayload;\n  body: IMoodDiaryMoodEntry.ICreate;\n}): Promise<IMoodDiaryMoodEntry> {\n  const { diaryUser, body } = props;\n  // 1. Validate mood_type\n  const allowedMoods: IMoodDiaryMoodEntry[\"mood_type\"][] = [\n    \"happy\",\n    \"sad\",\n    \"anxious\",\n    \"excited\",\n    \"angry\",\n    \"calm\",\n    \"stressed\",\n    \"tired\",\n  ];\n  if (!allowedMoods.includes(body.mood_type)) {\n    throw new Error(\n      `Invalid mood_type: '${body.mood_type}'. Allowed values: ${allowedMoods.join(\", \")}`,\n    );\n  }\n  // 2. Validate note (if present)\n  if (body.note !== undefined && body.note !== null && body.note.length > 500) {\n    throw new Error(\"Note must be blank or up to 500 Unicode characters.\");\n  }\n  // 3. Determine Asia/Calcutta (UTC+5:30) calendar date boundaries for today\n  // Compute current time in IST\n  const nowUtcMillis = Date.now();\n  const IST_OFFSET_MINUTES = 330; // +05:30 offset in minutes\n  const nowInISTMillis = nowUtcMillis + IST_OFFSET_MINUTES * 60 * 1000;\n  const nowInIST = new Date(nowInISTMillis);\n  const year = nowInIST.getUTCFullYear();\n  const month = nowInIST.getUTCMonth(); // 0-based\n  const day = nowInIST.getUTCDate();\n  // Start and end of day in IST, in UTC\n  const startISTMillis =\n    Date.UTC(year, month, day, 0, 0, 0) - IST_OFFSET_MINUTES * 60 * 1000;\n  const endISTMillis =\n    Date.UTC(year, month, day, 23, 59, 59, 999) -\n    IST_OFFSET_MINUTES * 60 * 1000;\n  // 4. Count today's (non-archived) entries for this diaryuser\n  const entriesToday = await MyGlobal.prisma.mood_diary_mood_entries.count({\n    where: {\n      mood_diary_diaryuser_id: diaryUser.id,\n      archived: false,\n      created_at: {\n        gte: toISOStringSafe(new Date(startISTMillis)),\n        lte: toISOStringSafe(new Date(endISTMillis)),\n      },\n    },\n  });\n  if (entriesToday >= 3) {\n    throw new Error(\n      \"Entry limit reached: only 3 mood entries allowed per calendar day.\",\n    );\n  }\n  // 5. Generate IDs and timestamps with branding\n  const newId = v4() as string & tags.Format<\"uuid\">;\n  // Created-at timestamp MUST be server time (Asia/Calcutta notionally, but value in UTC ISO)\n  const nowIso = toISOStringSafe(new Date());\n  // 6. Create DB entry\n  const created = await MyGlobal.prisma.mood_diary_mood_entries.create({\n    data: {\n      id: newId,\n      mood_diary_diaryuser_id: diaryUser.id,\n      mood_type: body.mood_type,\n      note: body.note !== undefined ? body.note : null,\n      created_at: nowIso,\n      archived: false,\n    },\n  });\n  // 7. Assemble response object (exact DTO fields)\n  return {\n    id: created.id,\n    mood_diary_diaryuser_id: created.mood_diary_diaryuser_id,\n    mood_type: created.mood_type as IMoodDiaryMoodEntry[\"mood_type\"],\n    // The DTO contract expects missing/blank note as undefined or null\n    note: created.note !== undefined ? created.note : null,\n    created_at: toISOStringSafe(created.created_at),\n    archived: created.archived,\n  };\n}\n","endpoint":{"method":"post","path":"/moodDiary/diaryUser/moodEntries"},"name":"postmoodDiaryDiaryUserMoodEntries"},{"location":"src/providers/getmoodDiaryDiaryUserMoodEntriesEntryId.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { IMoodDiaryMoodEntry } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryMoodEntry\";\nimport { DiaryuserPayload } from \"../decorators/payload/DiaryuserPayload\";\n\n/**\n * Fetch details for a single non-archived mood diary entry by id from\n * mood_diary_mood_entries.\n *\n * This operation retrieves the details for a specific, non-archived mood diary\n * entry using its unique id. Only unarchived entries (archived=false, created\n * within 30 days) are retrievable; attempts to fetch archived or non-existent\n * entries result in a not-found error. Returned data includes unique id,\n * mood_type (one of 8 allowed), optional note, UTC timestamp of creation, and\n * archived flag (guaranteed false for successful lookups).\n *\n * This operation does not permit any editing or deletion: returned entries are\n * immutable, and archiving is enforced by business rule (entries over 30 days\n * old).\n *\n * @param props - Object containing the logical diary user authentication\n *   payload and the entryId to fetch\n * @param props.diaryUser - The authenticated DiaryuserPayload for API role\n *   compliance (business logic: single user, context only)\n * @param props.entryId - UUID of the target mood entry to retrieve (must be\n *   valid and for an unarchived entry)\n * @returns The complete mood diary entry detail as IMoodDiaryMoodEntry (all\n *   fields required; note optional/nullable)\n * @throws {Error} If entry does not exist or has been archived (access denied\n *   or not found scenario)\n */\nexport async function getmoodDiaryDiaryUserMoodEntriesEntryId(props: {\n  diaryUser: DiaryuserPayload;\n  entryId: string & tags.Format<\"uuid\">;\n}): Promise<IMoodDiaryMoodEntry> {\n  const { diaryUser, entryId } = props;\n  const entry = await MyGlobal.prisma.mood_diary_mood_entries.findFirst({\n    where: {\n      id: entryId,\n      archived: false,\n    },\n    select: {\n      id: true,\n      mood_diary_diaryuser_id: true,\n      mood_type: true,\n      note: true,\n      created_at: true,\n      archived: true,\n    },\n  });\n  if (!entry) {\n    throw new Error(\"Mood diary entry not found or has been archived.\");\n  }\n  return {\n    id: entry.id,\n    mood_diary_diaryuser_id: entry.mood_diary_diaryuser_id,\n    mood_type: entry.mood_type,\n    note: entry.note === null ? undefined : entry.note,\n    created_at: toISOStringSafe(entry.created_at),\n    archived: entry.archived,\n  };\n}\n","endpoint":{"method":"get","path":"/moodDiary/diaryUser/moodEntries/{entryId}"},"name":"getmoodDiaryDiaryUserMoodEntriesEntryId"},{"location":"src/providers/getmoodDiaryDiaryUserMoodEntriesWeeklySummary.ts","content":"import jwt from \"jsonwebtoken\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport typia, { tags } from \"typia\";\nimport { Prisma } from \"@prisma/client\";\nimport { v4 } from \"uuid\";\nimport { toISOStringSafe } from \"../util/toISOStringSafe\";\nimport { IMoodDiaryMoodEntryWeeklySummary } from \"@ORGANIZATION/PROJECT-api/lib/structures/IMoodDiaryMoodEntryWeeklySummary\";\nimport { DiaryuserPayload } from \"../decorators/payload/DiaryuserPayload\";\n\n/**\n * Generate a weekly summary of moods for the last 7 active days, aggregating\n * counts from mood_diary_mood_entries.\n *\n * This endpoint computes and returns the mood summary statistics for the past 7\n * calendar days (not including today) for the single diaryUser. For each\n * day/mood, the system counts non-archived entries and returns daily and total\n * mood counts for all 8 standard types (zero when none logged). The summary\n * includes start/end ISO dates for the time window. If no entries are present\n * in the time window, the summary is zeroed accordingly.\n *\n * Business and security rules: no authentication or user separation, single\n * user logical model. Archived entries are always excluded (business logic and\n * application-level enforcement). Performance is expected within 2 seconds as\n * per requirements. This API does not expose any individual entry details, only\n * summary statistics. Related endpoints enable listing or creation of entries.\n *\n * @param props - Object containing all necessary parameters for the operation\n * @param props.diaryUser - The authenticated Diaryuser, contains the logical\n *   diary user id\n * @returns Weekly summary of moods over the last 7 calendar days, including\n *   per-day and total counts for each mood type\n * @throws {Error} If there is a system or database failure during summary\n *   construction\n */\nexport async function getmoodDiaryDiaryUserMoodEntriesWeeklySummary(props: {\n  diaryUser: DiaryuserPayload;\n}): Promise<IMoodDiaryMoodEntryWeeklySummary> {\n  const moodTypes = [\n    \"happy\",\n    \"sad\",\n    \"anxious\",\n    \"excited\",\n    \"angry\",\n    \"calm\",\n    \"stressed\",\n    \"tired\",\n  ];\n\n  // Step 1: Establish boundaries using Asia/Calcutta timezone\n  // We cannot use native Date in output, but we can use JS Dates for calculations\n  const zone = \"Asia/Calcutta\";\n  // Compute current date/time in Asia/Calcutta\n  const now = new Date();\n  const utc = now.getTime();\n  // Get the offset (minutes) for IST as of now\n  const localNow = new Date(now.toLocaleString(\"en-US\", { timeZone: zone }));\n  // Find local midnight at today (Asia/Calcutta today = end boundary, not included in window)\n  localNow.setHours(0, 0, 0, 0);\n  const msPerDay = 24 * 60 * 60 * 1000;\n  // Compute 7 days prior\n  const weekStart = new Date(localNow.getTime() - 7 * msPerDay);\n  const weekDates: string[] = [];\n  for (let i = 0; i < 7; ++i) {\n    const d = new Date(weekStart.getTime() + i * msPerDay);\n    const localDateParts = d\n      .toLocaleDateString(\"en-CA\", { timeZone: zone })\n      .split(\"-\");\n    // en-CA gets YYYY-MM-DD even in Node\n    weekDates.push(\n      `${localDateParts[0]}-${localDateParts[1]}-${localDateParts[2]}`,\n    );\n  }\n  // weekDates[0]=start, weekDates[6]=yesterday as local ISO (Asia/Calcutta)\n\n  // Step 2: Calculate UTC boundaries for Prisma query\n  // Start: weekStart at local day 0 in Asia/Calcutta, but in UTC\n  // End: localNow (midnight Asia/Calcutta today), in UTC\n  // We'll need to query all entries for the diaryUser in this UTC range\n  const rangeStartUTC = new Date(\n    weekStart.toLocaleString(\"en-US\", { timeZone: \"UTC\" }),\n  );\n  rangeStartUTC.setHours(0, 0, 0, 0);\n  const rangeEndUTC = new Date(\n    localNow.toLocaleString(\"en-US\", { timeZone: \"UTC\" }),\n  );\n  rangeEndUTC.setHours(0, 0, 0, 0);\n\n  // Step 3: Query all unarchived entries for this diaryUser in window\n  const entries = await MyGlobal.prisma.mood_diary_mood_entries.findMany({\n    where: {\n      mood_diary_diaryuser_id: props.diaryUser.id,\n      archived: false,\n      created_at: {\n        gte: rangeStartUTC.toISOString(),\n        lt: rangeEndUTC.toISOString(),\n      },\n    },\n    select: {\n      mood_type: true,\n      created_at: true,\n    },\n  });\n\n  // Step 4: Aggregate per mood, per day\n  // Build a map: mood_type -> array of 7 zeros, then fill\n  const moodStats: Record<string, number[]> = {};\n  moodTypes.forEach((mood) => {\n    moodStats[mood] = [0, 0, 0, 0, 0, 0, 0];\n  });\n\n  for (const entry of entries) {\n    // Convert entry.created_at (which is UTC ISO string) to a local date string (Asia/Calcutta: YYYY-MM-DD)\n    const localEntryDate = new Date(\n      new Date(entry.created_at).toLocaleString(\"en-US\", { timeZone: zone }),\n    );\n    localEntryDate.setHours(0, 0, 0, 0);\n    const localDateString = localEntryDate.toLocaleDateString(\"en-CA\", {\n      timeZone: zone,\n    });\n    // Find which day index this date is in our weekDates array\n    const dayIdx = weekDates.indexOf(localDateString);\n    if (dayIdx !== -1 && moodStats[entry.mood_type] !== undefined) {\n      moodStats[entry.mood_type][dayIdx]++;\n    }\n  }\n  // Step 5: Build output mood_counts array\n  const mood_counts = moodTypes.map((mood) => ({\n    mood_type: mood,\n    total_count: moodStats[mood].reduce((a, b) => a + b, 0),\n    daily_counts: moodStats[mood],\n  }));\n\n  // Step 6: Output: start_date/end_date (string & tags.Format<'date'>) and mood_counts\n  return {\n    start_date: weekDates[0],\n    end_date: weekDates[6],\n    mood_counts: mood_counts,\n  };\n}\n","endpoint":{"method":"get","path":"/moodDiary/diaryUser/moodEntries/weeklySummary"},"name":"getmoodDiaryDiaryUserMoodEntriesWeeklySummary"}],"controllers":{"src/controllers/auth/diaryUser/AuthDiaryuserController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute } from \"@nestia/core\";\nimport typia from \"typia\";\n\nimport { IMoodDiaryDiaryUser } from \"../../../api/structures/IMoodDiaryDiaryUser\";\n\n@Controller(\"/auth/diaryUser\")\nexport class AuthDiaryuserController {\n  /**\n   * Obtain session token as the logical diaryUser (single-user, from\n   * mood_diary_diaryusers), no registration or authentication required.\n   *\n   * Allows the system's single logical diaryUser to retrieve a session token\n   * for using the Mood Diary application. This operation does not perform\n   * traditional user registration or authentication—since the app has only a\n   * single logical user, anyone accessing the API receives the same\n   * (non-personalized) access. The endpoint directly issues a token for the\n   * logical diaryUser, returning the unique id and created_at fields from the\n   * mood_diary_diaryusers table. No personal identifiers or credentials are\n   * used. This operation is not a security boundary; rather, it establishes a\n   * stateless, anonymous session for logging moods, consistent with the\n   * single-user design. There is no support for login or password-based\n   * authentication. The access token enables subsequent authorized API actions\n   * for mood entry/log/view/statistics operations.\n   *\n   * Related operations are refresh for extending session lifetime and the main\n   * mood entry CRUD endpoints (protected by the issued token). Error behavior\n   * is limited to backend or system-level failures (e.g., database access\n   * issues). This endpoint is always allowed and never rate limited for\n   * business logic.\n   *\n   * Must reference only fields defined in mood_diary_diaryusers: id and\n   * created_at. No user-managed input. Result conforms to\n   * IMoodDiaryDiaryUser.IAuthorized DTO.\n   *\n   * @param connection\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"join\")\n  public async join(): Promise<IMoodDiaryDiaryUser.IAuthorized> {\n    return typia.random<IMoodDiaryDiaryUser.IAuthorized>();\n  }\n\n  /**\n   * OpenAPI-compliant login endpoint for the single logical diaryUser\n   * (mood_diary_diaryusers); no credentials accepted, always issues a token.\n   *\n   * Allows the single logical diaryUser to \"login\", even though no\n   * authentication is performed and no credentials or password are accepted.\n   * Any client may POST to this endpoint and receive a valid access token for\n   * the Mood Diary API. The operation always succeeds unless system-level\n   * errors occur. The underlying user data is drawn from mood_diary_diaryusers:\n   * only the id and created_at properties are returned. This operation is\n   * included solely for OpenAPI/JWT compliance, not security. No personal\n   * information is ever managed, no session state is persisted, and all\n   * business logic is stateless and open. The response includes token and diary\n   * user metadata as per IMoodDiaryDiaryUser.IAuthorized. Related operations\n   * include join (stateless registration/entry point) and refresh (token\n   * renewal).\n   *\n   * @param connection\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"login\")\n  public async login(): Promise<IMoodDiaryDiaryUser.IAuthorized> {\n    return typia.random<IMoodDiaryDiaryUser.IAuthorized>();\n  }\n\n  /**\n   * Refreshes the session for the logical diaryUser by issuing a new access\n   * token given a valid refresh token (mood_diary_diaryusers, single-user\n   * context).\n   *\n   * Allows the diaryUser (the single logical user in the Mood Diary app) to\n   * refresh their session token and extend access without any login or further\n   * interaction. Only a valid refresh token is required; no personal\n   * credentials or data are checked. The system returns a new access token and\n   * the diary user's id and created_at values from mood_diary_diaryusers. This\n   * supports seamless, stateless session continuation in the single-user\n   * context. All error and security handling is limited to token verification.\n   * There is no multi-user management or credential validation. This operation\n   * presumes only one logical user exists. Related operation: join (to obtain\n   * initial token).\n   *\n   * @param connection\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"refresh\")\n  public async refresh(): Promise<IMoodDiaryDiaryUser.IAuthorized> {\n    return typia.random<IMoodDiaryDiaryUser.IAuthorized>();\n  }\n}\n","src/controllers/moodDiary/diaryUser/moodEntries/MooddiaryDiaryuserMoodentriesController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { patchmoodDiaryDiaryUserMoodEntries } from \"../../../../providers/patchmoodDiaryDiaryUserMoodEntries\";\nimport { DiaryuserAuth } from \"../../../../decorators/DiaryuserAuth\";\nimport { DiaryuserPayload } from \"../../../../decorators/payload/DiaryuserPayload\";\nimport { getmoodDiaryDiaryUserMoodEntriesEntryId } from \"../../../../providers/getmoodDiaryDiaryUserMoodEntriesEntryId\";\nimport { getmoodDiaryDiaryUserMoodEntriesWeeklySummary } from \"../../../../providers/getmoodDiaryDiaryUserMoodEntriesWeeklySummary\";\n\nimport { IMoodDiaryMoodEntry } from \"../../../../api/structures/IMoodDiaryMoodEntry\";\nimport { IPageIMoodDiaryMoodEntry } from \"../../../../api/structures/IPageIMoodDiaryMoodEntry\";\nimport { IMoodDiaryMoodEntryWeeklySummary } from \"../../../../api/structures/IMoodDiaryMoodEntryWeeklySummary\";\n\n@Controller(\"/moodDiary/diaryUser/moodEntries\")\nexport class MooddiaryDiaryuserMoodentriesController {\n  /**\n   * Create a new mood diary entry for the logical user in\n   * mood_diary_mood_entries, enforcing daily entry limit and validation rules.\n   *\n   * This operation enables the diaryUser to create a new mood diary entry,\n   * capturing their mood and, optionally, a personal note. Only 3 entries per\n   * calendar day are permitted, ensuring users journal mindfully without data\n   * abuse. The mood_type must be one of: happy, sad, anxious, excited, angry,\n   * calm, stressed, tired. If omitted or invalid, an explicit validation error\n   * is returned. The note, if present, may be blank or up to 500 Unicode\n   * characters, including emojis. The system always sets the created_at\n   * timestamp to the current server time (Asia/Calcutta zone), never accepting\n   * a user-supplied timestamp. The archived flag is false by default for all\n   * new entries.\n   *\n   * Security is simple: no authentication or user distinction—this is a\n   * single-user diary by business design. All validation failures (invalid\n   * mood, too-long note, over daily limit, future timestamps) yield clear,\n   * user-focused error messages. The response includes the persisted entry data\n   * (id, mood_type, note, created_at, archived=false). Other related endpoints\n   * allow subsequent listing or summary. No edit or deletion is ever permitted\n   * on entries once created.\n   *\n   * @param connection\n   * @param body New mood diary entry details: mood type (from fixed set),\n   *   optional note (≤500 characters).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post()\n  public async create(\n    @TypedBody()\n    body: IMoodDiaryMoodEntry.ICreate,\n  ): Promise<IMoodDiaryMoodEntry> {\n    body;\n    return typia.random<IMoodDiaryMoodEntry>();\n  }\n\n  /**\n   * Retrieve a paginated list of non-archived mood diary entries for the single\n   * logical user from mood_diary_mood_entries.\n   *\n   * This operation provides the means for the diaryUser to view a list of their\n   * recent mood diary entries, supporting features like scrolling and\n   * filtering. Each result includes mood type (one of eight fixed values), the\n   * optional note (up to 500 Unicode characters), the auto-generated UTC\n   * timestamp (created_at), and an archived flag (expected false, as only\n   * recent entries are listed).\n   *\n   * Security-wise, no authentication or user separation exists; the app assumes\n   * a single logical diary owner, so all data is exposed. This is in line with\n   * business rules. Only non-archived entries (archived=false) are eligible,\n   * enforcing the 30-day retention policy for active viewing. Pagination and\n   * sorting are handled in the backend as per standard API conventions. No\n   * modification (edit/delete) actions are surfaced—this endpoint is strictly\n   * for read access.\n   *\n   * Key validation rules: only entries from the past 30 days, not archived,\n   * ordered by created_at descending. Error handling includes ensuring no\n   * archived data is exposed, and appropriate messages for invalid filters or\n   * pagination arguments. Related operations include mood entry creation (POST\n   * /moodEntries) and summary fetching (GET /moodEntries/weeklySummary).\n   *\n   * @param connection\n   * @param body Filter, search, and pagination criteria for retrieving\n   *   non-archived mood diary entries over the last 30 days.\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @DiaryuserAuth()\n    diaryUser: DiaryuserPayload,\n    @TypedBody()\n    body: IMoodDiaryMoodEntry.IRequest,\n  ): Promise<IPageIMoodDiaryMoodEntry> {\n    try {\n      return await patchmoodDiaryDiaryUserMoodEntries({\n        diaryUser,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Fetch details for a single non-archived mood diary entry by id from\n   * mood_diary_mood_entries.\n   *\n   * Retrieves one mood diary entry in detail, given its unique id. Only\n   * unarchived entries (created within last 30 days) are available; attempts to\n   * access archived or non-existent entries result in a clear not found or\n   * access error. Returned object includes: id, mood_type (fixed allowed list),\n   * note (if present), created_at UTC timestamp, and archived flag (always\n   * false for successful lookups). No edit or delete is possible—data is\n   * immutable.\n   *\n   * This operation is open to the single logical user by business rules—no\n   * authentication, no per-user scope. Data returned is always up to date and\n   * immutable. Errors are detailed for invalid ids or archived data, and\n   * security is ensured solely through archiving and business constraints.\n   *\n   * @param connection\n   * @param entryId Unique identifier for the mood diary entry to retrieve. Must\n   *   be a valid UUID and reference a non-archived entry (archived=false).\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":entryId\")\n  public async at(\n    @DiaryuserAuth()\n    diaryUser: DiaryuserPayload,\n    @TypedParam(\"entryId\")\n    entryId: string & tags.Format<\"uuid\">,\n  ): Promise<IMoodDiaryMoodEntry> {\n    try {\n      return await getmoodDiaryDiaryUserMoodEntriesEntryId({\n        diaryUser,\n        entryId,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate a weekly summary of moods for the last 7 active days, aggregating\n   * counts from mood_diary_mood_entries.\n   *\n   * This endpoint computes and returns the mood summary statistics for the past\n   * 7 calendar days (not including today) for the single diaryUser. For each\n   * day/mood, the system counts non-archived entries and returns daily and\n   * total mood counts for all 8 standard types (zero when none logged). The\n   * summary includes start/end ISO dates for the time window. If no entries are\n   * present in the time window, the summary is zeroed accordingly.\n   *\n   * Business and security rules: no authentication or user separation, single\n   * user logical model. Archived entries are always excluded (business logic\n   * and application-level enforcement). Performance is expected within 2\n   * seconds as per requirements. This API does not expose any individual entry\n   * details, only summary statistics. Related endpoints enable listing or\n   * creation of entries.\n   *\n   * Error responses handle only internal system failure or invalid business\n   * logic.\n   *\n   * @param connection\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\"weeklySummary\")\n  public async weeklySummary(\n    @DiaryuserAuth()\n    diaryUser: DiaryuserPayload,\n  ): Promise<IMoodDiaryMoodEntryWeeklySummary> {\n    try {\n      return await getmoodDiaryDiaryUserMoodEntriesWeeklySummary({\n        diaryUser,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n"},"compiled":{"type":"failure","diagnostics":[{"file":"src/providers/getmoodDiaryDiaryUserMoodEntriesEntryId.ts","category":"error","code":2304,"start":1822,"length":9,"messageText":"Cannot find name 'EMoodType'."}]},"created_at":"2025-09-14T15:28:47.457Z","completed_at":"2025-09-14T15:37:45.272Z","step":0}]