import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IMoodDiaryMoodEntry } from "../../../../structures/IMoodDiaryMoodEntry";
import { IPageIMoodDiaryMoodEntry } from "../../../../structures/IPageIMoodDiaryMoodEntry";
import { IMoodDiaryMoodEntryWeeklySummary } from "../../../../structures/IMoodDiaryMoodEntryWeeklySummary";

/**
 * Create a new mood diary entry for the logical user in
 * mood_diary_mood_entries, enforcing daily entry limit and validation rules.
 *
 * This operation enables the diaryUser to create a new mood diary entry,
 * capturing their mood and, optionally, a personal note. Only 3 entries per
 * calendar day are permitted, ensuring users journal mindfully without data
 * abuse. The mood_type must be one of: happy, sad, anxious, excited, angry,
 * calm, stressed, tired. If omitted or invalid, an explicit validation error is
 * returned. The note, if present, may be blank or up to 500 Unicode characters,
 * including emojis. The system always sets the created_at timestamp to the
 * current server time (Asia/Calcutta zone), never accepting a user-supplied
 * timestamp. The archived flag is false by default for all new entries.
 *
 * Security is simple: no authentication or user distinction—this is a
 * single-user diary by business design. All validation failures (invalid mood,
 * too-long note, over daily limit, future timestamps) yield clear, user-focused
 * error messages. The response includes the persisted entry data (id,
 * mood_type, note, created_at, archived=false). Other related endpoints allow
 * subsequent listing or summary. No edit or deletion is ever permitted on
 * entries once created.
 *
 * @param props.connection
 * @param props.body New mood diary entry details: mood type (from fixed set),
 *   optional note (≤500 characters).
 * @path /moodDiary/diaryUser/moodEntries
 * @accessor api.functional.moodDiary.diaryUser.moodEntries.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * New mood diary entry details: mood type (from fixed set), optional
     * note (≤500 characters).
     */
    body: IMoodDiaryMoodEntry.ICreate;
  };
  export type Body = IMoodDiaryMoodEntry.ICreate;
  export type Response = IMoodDiaryMoodEntry;

  export const METADATA = {
    method: "POST",
    path: "/moodDiary/diaryUser/moodEntries",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moodDiary/diaryUser/moodEntries";
  export const random = (): IMoodDiaryMoodEntry =>
    typia.random<IMoodDiaryMoodEntry>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a paginated list of non-archived mood diary entries for the single
 * logical user from mood_diary_mood_entries.
 *
 * This operation provides the means for the diaryUser to view a list of their
 * recent mood diary entries, supporting features like scrolling and filtering.
 * Each result includes mood type (one of eight fixed values), the optional note
 * (up to 500 Unicode characters), the auto-generated UTC timestamp
 * (created_at), and an archived flag (expected false, as only recent entries
 * are listed).
 *
 * Security-wise, no authentication or user separation exists; the app assumes a
 * single logical diary owner, so all data is exposed. This is in line with
 * business rules. Only non-archived entries (archived=false) are eligible,
 * enforcing the 30-day retention policy for active viewing. Pagination and
 * sorting are handled in the backend as per standard API conventions. No
 * modification (edit/delete) actions are surfaced—this endpoint is strictly for
 * read access.
 *
 * Key validation rules: only entries from the past 30 days, not archived,
 * ordered by created_at descending. Error handling includes ensuring no
 * archived data is exposed, and appropriate messages for invalid filters or
 * pagination arguments. Related operations include mood entry creation (POST
 * /moodEntries) and summary fetching (GET /moodEntries/weeklySummary).
 *
 * @param props.connection
 * @param props.body Filter, search, and pagination criteria for retrieving
 *   non-archived mood diary entries over the last 30 days.
 * @path /moodDiary/diaryUser/moodEntries
 * @accessor api.functional.moodDiary.diaryUser.moodEntries.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter, search, and pagination criteria for retrieving non-archived
     * mood diary entries over the last 30 days.
     */
    body: IMoodDiaryMoodEntry.IRequest;
  };
  export type Body = IMoodDiaryMoodEntry.IRequest;
  export type Response = IPageIMoodDiaryMoodEntry;

  export const METADATA = {
    method: "PATCH",
    path: "/moodDiary/diaryUser/moodEntries",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moodDiary/diaryUser/moodEntries";
  export const random = (): IPageIMoodDiaryMoodEntry =>
    typia.random<IPageIMoodDiaryMoodEntry>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch details for a single non-archived mood diary entry by id from
 * mood_diary_mood_entries.
 *
 * Retrieves one mood diary entry in detail, given its unique id. Only
 * unarchived entries (created within last 30 days) are available; attempts to
 * access archived or non-existent entries result in a clear not found or access
 * error. Returned object includes: id, mood_type (fixed allowed list), note (if
 * present), created_at UTC timestamp, and archived flag (always false for
 * successful lookups). No edit or delete is possible—data is immutable.
 *
 * This operation is open to the single logical user by business rules—no
 * authentication, no per-user scope. Data returned is always up to date and
 * immutable. Errors are detailed for invalid ids or archived data, and security
 * is ensured solely through archiving and business constraints.
 *
 * @param props.connection
 * @param props.entryId Unique identifier for the mood diary entry to retrieve.
 *   Must be a valid UUID and reference a non-archived entry (archived=false).
 * @path /moodDiary/diaryUser/moodEntries/:entryId
 * @accessor api.functional.moodDiary.diaryUser.moodEntries.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier for the mood diary entry to retrieve. Must be a
     * valid UUID and reference a non-archived entry (archived=false).
     */
    entryId: string & tags.Format<"uuid">;
  };
  export type Response = IMoodDiaryMoodEntry;

  export const METADATA = {
    method: "GET",
    path: "/moodDiary/diaryUser/moodEntries/:entryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/moodDiary/diaryUser/moodEntries/${encodeURIComponent(props.entryId ?? "null")}`;
  export const random = (): IMoodDiaryMoodEntry =>
    typia.random<IMoodDiaryMoodEntry>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("entryId")(() => typia.assert(props.entryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Generate a weekly summary of moods for the last 7 active days, aggregating
 * counts from mood_diary_mood_entries.
 *
 * This endpoint computes and returns the mood summary statistics for the past 7
 * calendar days (not including today) for the single diaryUser. For each
 * day/mood, the system counts non-archived entries and returns daily and total
 * mood counts for all 8 standard types (zero when none logged). The summary
 * includes start/end ISO dates for the time window. If no entries are present
 * in the time window, the summary is zeroed accordingly.
 *
 * Business and security rules: no authentication or user separation, single
 * user logical model. Archived entries are always excluded (business logic and
 * application-level enforcement). Performance is expected within 2 seconds as
 * per requirements. This API does not expose any individual entry details, only
 * summary statistics. Related endpoints enable listing or creation of entries.
 *
 * Error responses handle only internal system failure or invalid business
 * logic.
 *
 * @param props.connection
 * @path /moodDiary/diaryUser/moodEntries/weeklySummary
 * @accessor api.functional.moodDiary.diaryUser.moodEntries.weeklySummary
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function weeklySummary(
  connection: IConnection,
): Promise<weeklySummary.Response> {
  return true === connection.simulate
    ? weeklySummary.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...weeklySummary.METADATA,
          path: weeklySummary.path(),
          status: null,
        },
      );
}
export namespace weeklySummary {
  export type Response = IMoodDiaryMoodEntryWeeklySummary;

  export const METADATA = {
    method: "GET",
    path: "/moodDiary/diaryUser/moodEntries/weeklySummary",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/moodDiary/diaryUser/moodEntries/weeklySummary";
  export const random = (): IMoodDiaryMoodEntryWeeklySummary =>
    typia.random<IMoodDiaryMoodEntryWeeklySummary>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}
