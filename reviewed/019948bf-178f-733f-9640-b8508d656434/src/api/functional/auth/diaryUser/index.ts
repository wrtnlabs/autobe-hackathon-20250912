import { IConnection } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";

import { IMoodDiaryDiaryUser } from "../../../structures/IMoodDiaryDiaryUser";

/**
 * Obtain session token as the logical diaryUser (single-user, from
 * mood_diary_diaryusers), no registration or authentication required.
 *
 * Allows the system's single logical diaryUser to retrieve a session token for
 * using the Mood Diary application. This operation does not perform traditional
 * user registration or authenticationâ€”since the app has only a single logical
 * user, anyone accessing the API receives the same (non-personalized) access.
 * The endpoint directly issues a token for the logical diaryUser, returning the
 * unique id and created_at fields from the mood_diary_diaryusers table. No
 * personal identifiers or credentials are used. This operation is not a
 * security boundary; rather, it establishes a stateless, anonymous session for
 * logging moods, consistent with the single-user design. There is no support
 * for login or password-based authentication. The access token enables
 * subsequent authorized API actions for mood entry/log/view/statistics
 * operations.
 *
 * Related operations are refresh for extending session lifetime and the main
 * mood entry CRUD endpoints (protected by the issued token). Error behavior is
 * limited to backend or system-level failures (e.g., database access issues).
 * This endpoint is always allowed and never rate limited for business logic.
 *
 * Must reference only fields defined in mood_diary_diaryusers: id and
 * created_at. No user-managed input. Result conforms to
 * IMoodDiaryDiaryUser.IAuthorized DTO.
 *
 * @param props.connection
 * @setHeader token.access Authorization
 *
 * @path /auth/diaryUser/join
 * @accessor api.functional.auth.diaryUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(connection: IConnection): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Response = IMoodDiaryDiaryUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/diaryUser/join",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/diaryUser/join";
  export const random = (): IMoodDiaryDiaryUser.IAuthorized =>
    typia.random<IMoodDiaryDiaryUser.IAuthorized>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * OpenAPI-compliant login endpoint for the single logical diaryUser
 * (mood_diary_diaryusers); no credentials accepted, always issues a token.
 *
 * Allows the single logical diaryUser to "login", even though no authentication
 * is performed and no credentials or password are accepted. Any client may POST
 * to this endpoint and receive a valid access token for the Mood Diary API. The
 * operation always succeeds unless system-level errors occur. The underlying
 * user data is drawn from mood_diary_diaryusers: only the id and created_at
 * properties are returned. This operation is included solely for OpenAPI/JWT
 * compliance, not security. No personal information is ever managed, no session
 * state is persisted, and all business logic is stateless and open. The
 * response includes token and diary user metadata as per
 * IMoodDiaryDiaryUser.IAuthorized. Related operations include join (stateless
 * registration/entry point) and refresh (token renewal).
 *
 * @param props.connection
 * @setHeader token.access Authorization
 *
 * @path /auth/diaryUser/login
 * @accessor api.functional.auth.diaryUser.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(connection: IConnection): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Response = IMoodDiaryDiaryUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/diaryUser/login",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/diaryUser/login";
  export const random = (): IMoodDiaryDiaryUser.IAuthorized =>
    typia.random<IMoodDiaryDiaryUser.IAuthorized>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Refreshes the session for the logical diaryUser by issuing a new access token
 * given a valid refresh token (mood_diary_diaryusers, single-user context).
 *
 * Allows the diaryUser (the single logical user in the Mood Diary app) to
 * refresh their session token and extend access without any login or further
 * interaction. Only a valid refresh token is required; no personal credentials
 * or data are checked. The system returns a new access token and the diary
 * user's id and created_at values from mood_diary_diaryusers. This supports
 * seamless, stateless session continuation in the single-user context. All
 * error and security handling is limited to token verification. There is no
 * multi-user management or credential validation. This operation presumes only
 * one logical user exists. Related operation: join (to obtain initial token).
 *
 * @param props.connection
 * @setHeader token.access Authorization
 *
 * @path /auth/diaryUser/refresh
 * @accessor api.functional.auth.diaryUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Response = IMoodDiaryDiaryUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/diaryUser/refresh",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/diaryUser/refresh";
  export const random = (): IMoodDiaryDiaryUser.IAuthorized =>
    typia.random<IMoodDiaryDiaryUser.IAuthorized>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}
