import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postmoodDiaryDiaryUserMoodEntries } from "../../../../providers/postmoodDiaryDiaryUserMoodEntries";
import { DiaryuserAuth } from "../../../../decorators/DiaryuserAuth";
import { DiaryuserPayload } from "../../../../decorators/payload/DiaryuserPayload";
import { patchmoodDiaryDiaryUserMoodEntries } from "../../../../providers/patchmoodDiaryDiaryUserMoodEntries";
import { getmoodDiaryDiaryUserMoodEntriesEntryId } from "../../../../providers/getmoodDiaryDiaryUserMoodEntriesEntryId";
import { getmoodDiaryDiaryUserMoodEntriesWeeklySummary } from "../../../../providers/getmoodDiaryDiaryUserMoodEntriesWeeklySummary";

import { IMoodDiaryMoodEntry } from "../../../../api/structures/IMoodDiaryMoodEntry";
import { IPageIMoodDiaryMoodEntry } from "../../../../api/structures/IPageIMoodDiaryMoodEntry";
import { IMoodDiaryMoodEntryWeeklySummary } from "../../../../api/structures/IMoodDiaryMoodEntryWeeklySummary";

@Controller("/moodDiary/diaryUser/moodEntries")
export class MooddiaryDiaryuserMoodentriesController {
  /**
   * Create a new mood diary entry for the logical user in
   * mood_diary_mood_entries, enforcing daily entry limit and validation rules.
   *
   * This operation enables the diaryUser to create a new mood diary entry,
   * capturing their mood and, optionally, a personal note. Only 3 entries per
   * calendar day are permitted, ensuring users journal mindfully without data
   * abuse. The mood_type must be one of: happy, sad, anxious, excited, angry,
   * calm, stressed, tired. If omitted or invalid, an explicit validation error
   * is returned. The note, if present, may be blank or up to 500 Unicode
   * characters, including emojis. The system always sets the created_at
   * timestamp to the current server time (Asia/Calcutta zone), never accepting
   * a user-supplied timestamp. The archived flag is false by default for all
   * new entries.
   *
   * Security is simple: no authentication or user distinction—this is a
   * single-user diary by business design. All validation failures (invalid
   * mood, too-long note, over daily limit, future timestamps) yield clear,
   * user-focused error messages. The response includes the persisted entry data
   * (id, mood_type, note, created_at, archived=false). Other related endpoints
   * allow subsequent listing or summary. No edit or deletion is ever permitted
   * on entries once created.
   *
   * @param connection
   * @param body New mood diary entry details: mood type (from fixed set),
   *   optional note (≤500 characters).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @DiaryuserAuth()
    diaryUser: DiaryuserPayload,
    @TypedBody()
    body: IMoodDiaryMoodEntry.ICreate,
  ): Promise<IMoodDiaryMoodEntry> {
    try {
      return await postmoodDiaryDiaryUserMoodEntries({
        diaryUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve a paginated list of non-archived mood diary entries for the single
   * logical user from mood_diary_mood_entries.
   *
   * This operation provides the means for the diaryUser to view a list of their
   * recent mood diary entries, supporting features like scrolling and
   * filtering. Each result includes mood type (one of eight fixed values), the
   * optional note (up to 500 Unicode characters), the auto-generated UTC
   * timestamp (created_at), and an archived flag (expected false, as only
   * recent entries are listed).
   *
   * Security-wise, no authentication or user separation exists; the app assumes
   * a single logical diary owner, so all data is exposed. This is in line with
   * business rules. Only non-archived entries (archived=false) are eligible,
   * enforcing the 30-day retention policy for active viewing. Pagination and
   * sorting are handled in the backend as per standard API conventions. No
   * modification (edit/delete) actions are surfaced—this endpoint is strictly
   * for read access.
   *
   * Key validation rules: only entries from the past 30 days, not archived,
   * ordered by created_at descending. Error handling includes ensuring no
   * archived data is exposed, and appropriate messages for invalid filters or
   * pagination arguments. Related operations include mood entry creation (POST
   * /moodEntries) and summary fetching (GET /moodEntries/weeklySummary).
   *
   * @param connection
   * @param body Filter, search, and pagination criteria for retrieving
   *   non-archived mood diary entries over the last 30 days.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @DiaryuserAuth()
    diaryUser: DiaryuserPayload,
    @TypedBody()
    body: IMoodDiaryMoodEntry.IRequest,
  ): Promise<IPageIMoodDiaryMoodEntry> {
    try {
      return await patchmoodDiaryDiaryUserMoodEntries({
        diaryUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Fetch details for a single non-archived mood diary entry by id from
   * mood_diary_mood_entries.
   *
   * Retrieves one mood diary entry in detail, given its unique id. Only
   * unarchived entries (created within last 30 days) are available; attempts to
   * access archived or non-existent entries result in a clear not found or
   * access error. Returned object includes: id, mood_type (fixed allowed list),
   * note (if present), created_at UTC timestamp, and archived flag (always
   * false for successful lookups). No edit or delete is possible—data is
   * immutable.
   *
   * This operation is open to the single logical user by business rules—no
   * authentication, no per-user scope. Data returned is always up to date and
   * immutable. Errors are detailed for invalid ids or archived data, and
   * security is ensured solely through archiving and business constraints.
   *
   * @param connection
   * @param entryId Unique identifier for the mood diary entry to retrieve. Must
   *   be a valid UUID and reference a non-archived entry (archived=false).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":entryId")
  public async at(
    @DiaryuserAuth()
    diaryUser: DiaryuserPayload,
    @TypedParam("entryId")
    entryId: string & tags.Format<"uuid">,
  ): Promise<IMoodDiaryMoodEntry> {
    try {
      return await getmoodDiaryDiaryUserMoodEntriesEntryId({
        diaryUser,
        entryId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Generate a weekly summary of moods for the last 7 active days, aggregating
   * counts from mood_diary_mood_entries.
   *
   * This endpoint computes and returns the mood summary statistics for the past
   * 7 calendar days (not including today) for the single diaryUser. For each
   * day/mood, the system counts non-archived entries and returns daily and
   * total mood counts for all 8 standard types (zero when none logged). The
   * summary includes start/end ISO dates for the time window. If no entries are
   * present in the time window, the summary is zeroed accordingly.
   *
   * Business and security rules: no authentication or user separation, single
   * user logical model. Archived entries are always excluded (business logic
   * and application-level enforcement). Performance is expected within 2
   * seconds as per requirements. This API does not expose any individual entry
   * details, only summary statistics. Related endpoints enable listing or
   * creation of entries.
   *
   * Error responses handle only internal system failure or invalid business
   * logic.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get("weeklySummary")
  public async weeklySummary(
    @DiaryuserAuth()
    diaryUser: DiaryuserPayload,
  ): Promise<IMoodDiaryMoodEntryWeeklySummary> {
    try {
      return await getmoodDiaryDiaryUserMoodEntriesWeeklySummary({
        diaryUser,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
