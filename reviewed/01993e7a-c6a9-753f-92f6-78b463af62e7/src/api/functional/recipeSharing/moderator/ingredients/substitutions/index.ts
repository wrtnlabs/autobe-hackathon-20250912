import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRecipeSharingIngredientSubstitution } from "../../../../../structures/IRecipeSharingIngredientSubstitution";

/**
 * Create a new ingredient substitution for a given ingredient.
 *
 * Create a new ingredient substitution entry for a particular ingredient
 * identified by 'ingredientId'. This substitution defines an alternative
 * ingredient along with a conversion ratio indicating how to adjust quantities
 * when substituting.
 *
 * The substitution must be linked to a valid existing ingredient and an
 * approved substitute ingredient in the system. Users are required to provide
 * the substitute ingredient ID and conversion ratio.
 *
 * Timestamps for creation and update are managed automatically by the system,
 * ensuring accurate audit trails. This operation requires authenticated users
 * with appropriate permissions to add substitutions.
 *
 * Note that the substitution status field exists in the database but its value
 * must be managed by moderation processes and is not set during creation.
 *
 * If substitution with the same ingredient and substitute combination exists,
 * the system rejects duplication.
 *
 * The created substitution can be managed subsequently via update or delete
 * operations.
 *
 * @param props.connection
 * @param props.ingredientId ID of the ingredient to add substitution for
 * @param props.body Information to create an ingredient substitution entry
 * @path /recipeSharing/moderator/ingredients/:ingredientId/substitutions
 * @accessor api.functional.recipeSharing.moderator.ingredients.substitutions.createSubstitution
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createSubstitution(
  connection: IConnection,
  props: createSubstitution.Props,
): Promise<createSubstitution.Response> {
  return true === connection.simulate
    ? createSubstitution.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createSubstitution.METADATA,
          path: createSubstitution.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createSubstitution {
  export type Props = {
    /** ID of the ingredient to add substitution for */
    ingredientId: string & tags.Format<"uuid">;

    /** Information to create an ingredient substitution entry */
    body: IRecipeSharingIngredientSubstitution.ICreate;
  };
  export type Body = IRecipeSharingIngredientSubstitution.ICreate;
  export type Response = IRecipeSharingIngredientSubstitution;

  export const METADATA = {
    method: "POST",
    path: "/recipeSharing/moderator/ingredients/:ingredientId/substitutions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/moderator/ingredients/${encodeURIComponent(props.ingredientId ?? "null")}/substitutions`;
  export const random = (): IRecipeSharingIngredientSubstitution =>
    typia.random<IRecipeSharingIngredientSubstitution>();
  export const simulate = (
    connection: IConnection,
    props: createSubstitution.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createSubstitution.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("ingredientId")(() => typia.assert(props.ingredientId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an ingredient substitution by its ID under a specific ingredient.
 *
 * Update an existing ingredient substitution linked to a given ingredient
 * identified by 'ingredientId' and 'substitutionId'.
 *
 * This allows modification of the substitute ingredient, conversion ratio, and
 * moderation status.
 *
 * Moderation statuses are strict enum values: 'pending', 'approved', 'rejected'
 * must be used exactly.
 *
 * Creation timestamp remains unchanged. Update timestamp updates automatically.
 *
 * This operation requires authenticated admin or moderator role for
 * authorization.
 *
 * Validation ensures the substitution belongs to the specified ingredient and
 * identifiers are valid UUIDs.
 *
 * @param props.connection
 * @param props.ingredientId ID of the ingredient to which substitution belongs
 * @param props.substitutionId ID of the substitution to update
 * @param props.body Information to update an ingredient substitution entry
 * @path /recipeSharing/moderator/ingredients/:ingredientId/substitutions/:substitutionId
 * @accessor api.functional.recipeSharing.moderator.ingredients.substitutions.updateSubstitution
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateSubstitution(
  connection: IConnection,
  props: updateSubstitution.Props,
): Promise<updateSubstitution.Response> {
  return true === connection.simulate
    ? updateSubstitution.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateSubstitution.METADATA,
          path: updateSubstitution.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateSubstitution {
  export type Props = {
    /** ID of the ingredient to which substitution belongs */
    ingredientId: string & tags.Format<"uuid">;

    /** ID of the substitution to update */
    substitutionId: string & tags.Format<"uuid">;

    /** Information to update an ingredient substitution entry */
    body: IRecipeSharingIngredientSubstitution.IUpdate;
  };
  export type Body = IRecipeSharingIngredientSubstitution.IUpdate;
  export type Response = IRecipeSharingIngredientSubstitution;

  export const METADATA = {
    method: "PUT",
    path: "/recipeSharing/moderator/ingredients/:ingredientId/substitutions/:substitutionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/moderator/ingredients/${encodeURIComponent(props.ingredientId ?? "null")}/substitutions/${encodeURIComponent(props.substitutionId ?? "null")}`;
  export const random = (): IRecipeSharingIngredientSubstitution =>
    typia.random<IRecipeSharingIngredientSubstitution>();
  export const simulate = (
    connection: IConnection,
    props: updateSubstitution.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateSubstitution.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("ingredientId")(() => typia.assert(props.ingredientId));
      assert.param("substitutionId")(() => typia.assert(props.substitutionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete an ingredient substitution by ID.
 *
 * Erase (permanently delete) an ingredient substitution record linked to a
 * specific ingredient.
 *
 * This action removes the substitution entirely from the database with no
 * recovery. It does not soft delete.
 *
 * Authorization requires admin or moderator role.
 *
 * Path parameters must correctly specify the ingredient and substitution IDs.
 *
 * No request body or response body is needed.
 *
 * @param props.connection
 * @param props.ingredientId ID of the ingredient linked to the substitution
 * @param props.substitutionId ID of the ingredient substitution to delete
 * @path /recipeSharing/moderator/ingredients/:ingredientId/substitutions/:substitutionId
 * @accessor api.functional.recipeSharing.moderator.ingredients.substitutions.eraseSubstitution
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseSubstitution(
  connection: IConnection,
  props: eraseSubstitution.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseSubstitution.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseSubstitution.METADATA,
          path: eraseSubstitution.path(props),
          status: null,
        },
      );
}
export namespace eraseSubstitution {
  export type Props = {
    /** ID of the ingredient linked to the substitution */
    ingredientId: string & tags.Format<"uuid">;

    /** ID of the ingredient substitution to delete */
    substitutionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/recipeSharing/moderator/ingredients/:ingredientId/substitutions/:substitutionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/moderator/ingredients/${encodeURIComponent(props.ingredientId ?? "null")}/substitutions/${encodeURIComponent(props.substitutionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseSubstitution.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseSubstitution.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("ingredientId")(() => typia.assert(props.ingredientId));
      assert.param("substitutionId")(() => typia.assert(props.substitutionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
