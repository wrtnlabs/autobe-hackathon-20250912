import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRecipeSharingRecipeCategoriesConfig } from "../../../../structures/IRecipeSharingRecipeCategoriesConfig";
import { IPageIRecipeSharingRecipeCategoriesConfig } from "../../../../structures/IPageIRecipeSharingRecipeCategoriesConfig";

/**
 * Create new recipe category configuration.
 *
 * Create a new recipe category configuration.
 *
 * Accepts the required code and name fields, optional description, and
 * timestamps.
 *
 * Accessible only by moderators for category management purposes.
 *
 * Returns the detailed entity of the created recipe category configuration.
 *
 * @param props.connection
 * @param props.body Creation information for a new recipe category
 *   configuration
 * @path /recipeSharing/moderator/recipeCategoriesConfig
 * @accessor api.functional.recipeSharing.moderator.recipeCategoriesConfig.createRecipeCategoriesConfig
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createRecipeCategoriesConfig(
  connection: IConnection,
  props: createRecipeCategoriesConfig.Props,
): Promise<createRecipeCategoriesConfig.Response> {
  return true === connection.simulate
    ? createRecipeCategoriesConfig.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createRecipeCategoriesConfig.METADATA,
          path: createRecipeCategoriesConfig.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createRecipeCategoriesConfig {
  export type Props = {
    /** Creation information for a new recipe category configuration */
    body: IRecipeSharingRecipeCategoriesConfig.ICreate;
  };
  export type Body = IRecipeSharingRecipeCategoriesConfig.ICreate;
  export type Response = IRecipeSharingRecipeCategoriesConfig;

  export const METADATA = {
    method: "POST",
    path: "/recipeSharing/moderator/recipeCategoriesConfig",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/recipeSharing/moderator/recipeCategoriesConfig";
  export const random = (): IRecipeSharingRecipeCategoriesConfig =>
    typia.random<IRecipeSharingRecipeCategoriesConfig>();
  export const simulate = (
    connection: IConnection,
    props: createRecipeCategoriesConfig.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createRecipeCategoriesConfig.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list recipe category configurations.
 *
 * Retrieve a filtered, paginated list of recipe category configurations for
 * administrative purposes.
 *
 * Supports filtering by category code, name, and description with partial
 * matching, pagination, and sorting.
 *
 * This allows frontend clients to efficiently fetch recipe categories with rich
 * querying.
 *
 * No path parameters are required.
 *
 * Roles with moderator privileges may access this operation.
 *
 * Response includes concise summary information suitable for list views.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for recipe
 *   category configurations
 * @path /recipeSharing/moderator/recipeCategoriesConfig
 * @accessor api.functional.recipeSharing.moderator.recipeCategoriesConfig.indexRecipeCategoriesConfig
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexRecipeCategoriesConfig(
  connection: IConnection,
  props: indexRecipeCategoriesConfig.Props,
): Promise<indexRecipeCategoriesConfig.Response> {
  return true === connection.simulate
    ? indexRecipeCategoriesConfig.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexRecipeCategoriesConfig.METADATA,
          path: indexRecipeCategoriesConfig.path(),
          status: null,
        },
        props.body,
      );
}
export namespace indexRecipeCategoriesConfig {
  export type Props = {
    /**
     * Search criteria and pagination parameters for recipe category
     * configurations
     */
    body: IRecipeSharingRecipeCategoriesConfig.IRequest;
  };
  export type Body = IRecipeSharingRecipeCategoriesConfig.IRequest;
  export type Response = IPageIRecipeSharingRecipeCategoriesConfig.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/recipeSharing/moderator/recipeCategoriesConfig",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/recipeSharing/moderator/recipeCategoriesConfig";
  export const random =
    (): IPageIRecipeSharingRecipeCategoriesConfig.ISummary =>
      typia.random<IPageIRecipeSharingRecipeCategoriesConfig.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: indexRecipeCategoriesConfig.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexRecipeCategoriesConfig.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get recipe category configuration by ID.
 *
 * Fetch detailed information of a recipe category configuration by its unique
 * id.
 *
 * Includes all properties such as code, name, description, and timestamps.
 *
 * The path parameter 'id' is required to uniquely specify the target record.
 *
 * Accessible only to authenticated moderators.
 *
 * This facilitates viewing and editing full category details.
 *
 * @param props.connection
 * @param props.id Unique identifier of the recipe category configuration
 * @path /recipeSharing/moderator/recipeCategoriesConfig/:id
 * @accessor api.functional.recipeSharing.moderator.recipeCategoriesConfig.atRecipeCategoriesConfig
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atRecipeCategoriesConfig(
  connection: IConnection,
  props: atRecipeCategoriesConfig.Props,
): Promise<atRecipeCategoriesConfig.Response> {
  return true === connection.simulate
    ? atRecipeCategoriesConfig.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atRecipeCategoriesConfig.METADATA,
          path: atRecipeCategoriesConfig.path(props),
          status: null,
        },
      );
}
export namespace atRecipeCategoriesConfig {
  export type Props = {
    /** Unique identifier of the recipe category configuration */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRecipeSharingRecipeCategoriesConfig;

  export const METADATA = {
    method: "GET",
    path: "/recipeSharing/moderator/recipeCategoriesConfig/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/moderator/recipeCategoriesConfig/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IRecipeSharingRecipeCategoriesConfig =>
    typia.random<IRecipeSharingRecipeCategoriesConfig>();
  export const simulate = (
    connection: IConnection,
    props: atRecipeCategoriesConfig.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atRecipeCategoriesConfig.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific recipe category configuration by ID.
 *
 * Update the details of a predefined recipe category configuration.
 *
 * This operation modifies a recipe category config identified by its unique ID.
 * It enables updating the 'code' which is a unique identifier for the category,
 * the human-readable 'name', and an optional 'description'. The update affects
 * the respective timestamps to record the modification instant.
 *
 * Security considerations include authorization checks to ensure only permitted
 * user roles can update category configurations, preventing unauthorized
 * changes.
 *
 * The business logic enforces uniqueness of the 'code' field to maintain
 * consistency across the platform's category taxonomy. Related operations
 * include creating new category configs and deleting obsolete configs.
 *
 * Validation rules require the 'code' and 'name' to be non-empty strings. The
 * 'description' can be null or a descriptive string.
 *
 * This operation directly updates the 'recipe_sharing_recipe_categories_config'
 * table as defined in the Prisma schema.
 *
 * @param props.connection
 * @param props.id Unique identifier of the recipe category configuration to
 *   update
 * @param props.body Updated data for the recipe category configuration
 * @path /recipeSharing/moderator/recipeCategoriesConfig/:id
 * @accessor api.functional.recipeSharing.moderator.recipeCategoriesConfig.updateRecipeCategoryConfig
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateRecipeCategoryConfig(
  connection: IConnection,
  props: updateRecipeCategoryConfig.Props,
): Promise<updateRecipeCategoryConfig.Response> {
  return true === connection.simulate
    ? updateRecipeCategoryConfig.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateRecipeCategoryConfig.METADATA,
          path: updateRecipeCategoryConfig.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateRecipeCategoryConfig {
  export type Props = {
    /** Unique identifier of the recipe category configuration to update */
    id: string & tags.Format<"uuid">;

    /** Updated data for the recipe category configuration */
    body: IRecipeSharingRecipeCategoriesConfig.IUpdate;
  };
  export type Body = IRecipeSharingRecipeCategoriesConfig.IUpdate;
  export type Response = IRecipeSharingRecipeCategoriesConfig;

  export const METADATA = {
    method: "PUT",
    path: "/recipeSharing/moderator/recipeCategoriesConfig/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/moderator/recipeCategoriesConfig/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IRecipeSharingRecipeCategoriesConfig =>
    typia.random<IRecipeSharingRecipeCategoriesConfig>();
  export const simulate = (
    connection: IConnection,
    props: updateRecipeCategoryConfig.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateRecipeCategoryConfig.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a specific recipe category configuration by ID.
 *
 * Permanently remove a recipe category configuration identified by its unique
 * ID.
 *
 * This operation performs a hard delete on the record in the
 * 'recipe_sharing_recipe_categories_config' table corresponding to the given
 * ID. After deletion, the category configuration will no longer exist in the
 * system.
 *
 * Security checks ensure only authorized user roles can execute this operation.
 * Adequate validation confirms that the category exists before attempting
 * deletion.
 *
 * Related maintenance operations may include updating or re-creating category
 * configurations.
 *
 * This irreversible action cleanly removes all traces of the configuration
 * entry from the database.
 *
 * @param props.connection
 * @param props.id Unique identifier of the recipe category configuration to
 *   delete
 * @path /recipeSharing/moderator/recipeCategoriesConfig/:id
 * @accessor api.functional.recipeSharing.moderator.recipeCategoriesConfig.eraseRecipeCategoryConfig
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseRecipeCategoryConfig(
  connection: IConnection,
  props: eraseRecipeCategoryConfig.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseRecipeCategoryConfig.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseRecipeCategoryConfig.METADATA,
          path: eraseRecipeCategoryConfig.path(props),
          status: null,
        },
      );
}
export namespace eraseRecipeCategoryConfig {
  export type Props = {
    /** Unique identifier of the recipe category configuration to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/recipeSharing/moderator/recipeCategoriesConfig/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/moderator/recipeCategoriesConfig/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseRecipeCategoryConfig.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseRecipeCategoryConfig.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
