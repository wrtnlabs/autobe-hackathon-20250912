import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRecipeSharingReviewVote } from "../../../../../structures/IRecipeSharingReviewVote";
import { IPageIRecipeSharingReviewVote } from "../../../../../structures/IPageIRecipeSharingReviewVote";

/**
 * Create a helpfulness vote for a review.
 *
 * This operation allows authorized users to cast a helpfulness vote on a given
 * review specified by reviewId. The vote includes a boolean field indicating
 * the helpfulness.
 *
 * Only one vote per user per review is allowed, but users may update their
 * vote.
 *
 * The request body must include the helpfulness status. Authentication ensures
 * valid user association.
 *
 * Related operations include retrieving existing votes and deleting votes.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the review to vote on
 * @param props.body Helpfulness vote data to create
 * @path /recipeSharing/regularUser/reviews/:reviewId/votes
 * @accessor api.functional.recipeSharing.regularUser.reviews.votes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the review to vote on */
    reviewId: string & tags.Format<"uuid">;

    /** Helpfulness vote data to create */
    body: IRecipeSharingReviewVote.ICreate;
  };
  export type Body = IRecipeSharingReviewVote.ICreate;
  export type Response = IRecipeSharingReviewVote;

  export const METADATA = {
    method: "POST",
    path: "/recipeSharing/regularUser/reviews/:reviewId/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/regularUser/reviews/${encodeURIComponent(props.reviewId ?? "null")}/votes`;
  export const random = (): IRecipeSharingReviewVote =>
    typia.random<IRecipeSharingReviewVote>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve paginated list of helpfulness votes for a review.
 *
 * This operation fetches a filtered, paginated list of all review helpfulness
 * votes linked to a particular review identified by reviewId. Each vote
 * indicates if a user found the review helpful.
 *
 * Clients can paginate responses and optionally filter votes via the request
 * body parameters.
 *
 * Access to this endpoint is restricted to authorized users to protect review
 * privacy and integrity.
 *
 * This operation enables display of collective feedback on reviews, supporting
 * user decision-making and moderation.
 *
 * Related endpoints include retrieving individual votes and creating or
 * deleting votes.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the target review
 * @param props.body Filtering and pagination parameters for review votes
 * @path /recipeSharing/regularUser/reviews/:reviewId/votes
 * @accessor api.functional.recipeSharing.regularUser.reviews.votes.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the target review */
    reviewId: string & tags.Format<"uuid">;

    /** Filtering and pagination parameters for review votes */
    body: IRecipeSharingReviewVote.IRequest;
  };
  export type Body = IRecipeSharingReviewVote.IRequest;
  export type Response = IPageIRecipeSharingReviewVote;

  export const METADATA = {
    method: "PATCH",
    path: "/recipeSharing/regularUser/reviews/:reviewId/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/regularUser/reviews/${encodeURIComponent(props.reviewId ?? "null")}/votes`;
  export const random = (): IPageIRecipeSharingReviewVote =>
    typia.random<IPageIRecipeSharingReviewVote>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a specific helpfulness vote on a review.
 *
 * This endpoint returns detailed information about a specific helpfulness vote
 * identified by voteId, associated with a particular review identified by
 * reviewId.
 *
 * The returned vote data includes the helpful status of the vote, user
 * identity, and timestamps.
 *
 * Access is secured and restricted to authenticated users.
 *
 * This operation supports UI functionality for showing vote details and
 * administrative review processes.
 *
 * Related endpoints cover vote creation, listing, and deletion.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the review
 * @param props.voteId Unique identifier of the helpfulness vote
 * @path /recipeSharing/regularUser/reviews/:reviewId/votes/:voteId
 * @accessor api.functional.recipeSharing.regularUser.reviews.votes.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the review */
    reviewId: string & tags.Format<"uuid">;

    /** Unique identifier of the helpfulness vote */
    voteId: string & tags.Format<"uuid">;
  };
  export type Response = IRecipeSharingReviewVote;

  export const METADATA = {
    method: "GET",
    path: "/recipeSharing/regularUser/reviews/:reviewId/votes/:voteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/regularUser/reviews/${encodeURIComponent(props.reviewId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): IRecipeSharingReviewVote =>
    typia.random<IRecipeSharingReviewVote>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("voteId")(() => typia.assert(props.voteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a helpfulness vote on a review.
 *
 * Update a specific helpfulness vote on a recipe review identified by voteId
 * and associated with reviewId.
 *
 * This operation updates the helpfulness flag indicating whether the vote marks
 * the review as helpful or not. Only the user who made the vote can update it,
 * and the operation requires authentication.
 *
 * This operation interacts directly with the recipe_sharing_review_votes table
 * in the Prisma schema, modifying the 'helpful' boolean field. The user ID and
 * review ID in the path parameters ensure the vote record's correct targeting.
 *
 * Appropriate validations include ensuring the vote belongs to the
 * authenticated user and the vote ID corresponds to an existing record.
 *
 * This update operation returns the updated review vote details.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the target review
 * @param props.voteId Unique identifier of the target vote
 * @param props.body Data to update a review vote
 * @path /recipeSharing/regularUser/reviews/:reviewId/votes/:voteId
 * @accessor api.functional.recipeSharing.regularUser.reviews.votes.updateVote
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateVote(
  connection: IConnection,
  props: updateVote.Props,
): Promise<updateVote.Response> {
  return true === connection.simulate
    ? updateVote.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateVote.METADATA,
          path: updateVote.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateVote {
  export type Props = {
    /** Unique identifier of the target review */
    reviewId: string & tags.Format<"uuid">;

    /** Unique identifier of the target vote */
    voteId: string & tags.Format<"uuid">;

    /** Data to update a review vote */
    body: IRecipeSharingReviewVote.IUpdate;
  };
  export type Body = IRecipeSharingReviewVote.IUpdate;
  export type Response = IRecipeSharingReviewVote;

  export const METADATA = {
    method: "PUT",
    path: "/recipeSharing/regularUser/reviews/:reviewId/votes/:voteId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/regularUser/reviews/${encodeURIComponent(props.reviewId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): IRecipeSharingReviewVote =>
    typia.random<IRecipeSharingReviewVote>();
  export const simulate = (
    connection: IConnection,
    props: updateVote.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateVote.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("voteId")(() => typia.assert(props.voteId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a helpfulness vote on a review.
 *
 * Delete a helpfulness vote on a recipe review, identified by voteId and
 * reviewId.
 *
 * This operation permanently removes the vote record from the database,
 * disallowing recovery.
 *
 * Only the owner of the vote, an authenticated user, may perform this deletion.
 *
 * The operation requires reviewId and voteId as path parameters to ensure the
 * correct vote is deleted.
 *
 * No request body or response body is included for this operation.
 *
 * @param props.connection
 * @param props.reviewId Unique identifier of the target review
 * @param props.voteId Unique identifier of the target vote
 * @path /recipeSharing/regularUser/reviews/:reviewId/votes/:voteId
 * @accessor api.functional.recipeSharing.regularUser.reviews.votes.eraseVote
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseVote(
  connection: IConnection,
  props: eraseVote.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseVote.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseVote.METADATA,
          path: eraseVote.path(props),
          status: null,
        },
      );
}
export namespace eraseVote {
  export type Props = {
    /** Unique identifier of the target review */
    reviewId: string & tags.Format<"uuid">;

    /** Unique identifier of the target vote */
    voteId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/recipeSharing/regularUser/reviews/:reviewId/votes/:voteId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/regularUser/reviews/${encodeURIComponent(props.reviewId ?? "null")}/votes/${encodeURIComponent(props.voteId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseVote.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseVote.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("reviewId")(() => typia.assert(props.reviewId));
      assert.param("voteId")(() => typia.assert(props.voteId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
