import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IRecipeSharingRating } from "../../../../structures/IRecipeSharingRating";
import { IPageIRecipeSharingRating } from "../../../../structures/IPageIRecipeSharingRating";

/**
 * Create a new user rating.
 *
 * This API endpoint enables authenticated regular users to submit new ratings
 * for recipes. The request body must include the rating data such as the user
 * ID, recipe ID, and the star rating value (an integer from 1 to 5). This
 * operation enforces uniqueness such that users can only rate a recipe once.
 *
 * Upon successful creation, the system records the creation and update
 * timestamps automatically and returns the full rating entity in the response.
 * Validation ensures the rating value falls within the 1-5 range, user and
 * recipe IDs are valid UUIDs, and the user has permission to rate the recipe.
 *
 * This operation complements GET, PUT, and DELETE rating operations to maintain
 * the full lifecycle. Authorization restricts access to authenticated regular
 * users, ensuring that only legitimate users can rate recipes.
 *
 * The rating contributes to average score calculation seen in recipe details
 * and user feedback modules.
 *
 * Request and response structures strictly follow the
 * IRecipeSharingRating.ICreate and IRecipeSharingRating type definitions
 * respectively.
 *
 * @param props.connection
 * @param props.body Creation info of the rating
 * @path /recipeSharing/regularUser/ratings
 * @accessor api.functional.recipeSharing.regularUser.ratings.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Creation info of the rating */
    body: IRecipeSharingRating.ICreate;
  };
  export type Body = IRecipeSharingRating.ICreate;
  export type Response = IRecipeSharingRating;

  export const METADATA = {
    method: "POST",
    path: "/recipeSharing/regularUser/ratings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/recipeSharing/regularUser/ratings";
  export const random = (): IRecipeSharingRating =>
    typia.random<IRecipeSharingRating>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve recipe ratings with pagination.
 *
 * Retrieve a list of recipe ratings matching search criteria with pagination,
 * filtering, and sorting options.
 *
 * Authenticated users can query ratings submitted by themselves or others to
 * view rating distributions.
 *
 * The response includes paginated rating summaries with rating values and
 * related user and recipe identifiers.
 *
 * This is a read-only endpoint and does not permit modification of ratings.
 *
 * Proper error handling ensures that invalid queries are rejected.
 *
 * @param props.connection
 * @param props.body Search and filter parameters for ratings.
 * @path /recipeSharing/regularUser/ratings
 * @accessor api.functional.recipeSharing.regularUser.ratings.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search and filter parameters for ratings. */
    body: IRecipeSharingRating.IRequest;
  };
  export type Body = IRecipeSharingRating.IRequest;
  export type Response = IPageIRecipeSharingRating;

  export const METADATA = {
    method: "PATCH",
    path: "/recipeSharing/regularUser/ratings",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/recipeSharing/regularUser/ratings";
  export const random = (): IPageIRecipeSharingRating =>
    typia.random<IPageIRecipeSharingRating>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific rating by ID.
 *
 * This API operation allows an authenticated regular user to fetch detailed
 * information for a specific rating entry by its unique ID. It is primarily
 * used to view user-submitted ratings on recipes, supporting functionalities
 * such as displaying average ratings and individual user reviews.
 *
 * Security considerations ensure only authorized regular users can access
 * rating details. The operation references the `recipe_sharing_ratings` table
 * in the Prisma schema, which maintains user-rating relationships, star values,
 * and timestamps for tracking creation and updates.
 *
 * Being a readonly GET endpoint, it returns the full rating entity as defined
 * in the schema, facilitating front-end display and analytics purposes. The
 * operation expects a valid UUID path parameter `id` representing the rating's
 * unique identifier.
 *
 * Validation rules require the `id` to be a valid UUID string. If no matching
 * rating is found, a 404 error is expected to be handled by the backend
 * service.
 *
 * Related API operations include creating ratings (POST /ratings), updating
 * ratings (PUT /ratings/{id}), and deleting ratings (DELETE /ratings/{id}).
 * This operation returns comprehensive data for a single rating record.
 *
 * @param props.connection
 * @param props.id Unique identifier of the target rating
 * @path /recipeSharing/regularUser/ratings/:id
 * @accessor api.functional.recipeSharing.regularUser.ratings.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target rating */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IRecipeSharingRating;

  export const METADATA = {
    method: "GET",
    path: "/recipeSharing/regularUser/ratings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/regularUser/ratings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IRecipeSharingRating =>
    typia.random<IRecipeSharingRating>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing rating by ID.
 *
 * This endpoint permits authenticated regular users to update their own rating
 * on a recipe. The user provides the rating ID in the path parameter and the
 * revised rating data in the request body.
 *
 * The system validates the updated star rating to be within the 1-5 range and
 * confirms the user owns the rating record. Update timestamps are automatically
 * managed by the system.
 *
 * This operation enables users to refine their feedback on recipes and is part
 * of the full rating lifecycle along with create, get, and delete operations.
 * Authorization ensures only the rating owner can perform updates.
 *
 * Request and response data structures adhere to IRecipeSharingRating.IUpdate
 * and IRecipeSharingRating typed schemas.
 *
 * This API enhances user engagement by allowing rating corrections and updated
 * opinions over time.
 *
 * @param props.connection
 * @param props.id Unique identifier of the target rating
 * @param props.body Update info of the rating
 * @path /recipeSharing/regularUser/ratings/:id
 * @accessor api.functional.recipeSharing.regularUser.ratings.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target rating */
    id: string & tags.Format<"uuid">;

    /** Update info of the rating */
    body: IRecipeSharingRating.IUpdate;
  };
  export type Body = IRecipeSharingRating.IUpdate;
  export type Response = IRecipeSharingRating;

  export const METADATA = {
    method: "PUT",
    path: "/recipeSharing/regularUser/ratings/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/recipeSharing/regularUser/ratings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IRecipeSharingRating =>
    typia.random<IRecipeSharingRating>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a rating by ID permanently.
 *
 * This API endpoint allows authenticated regular users to delete their own
 * rating records on recipes by providing the rating ID. The deletion is
 * permanent, physically removing the record from the database.
 *
 * The operation requires path parameter `id` which must be a valid UUID string.
 * Upon successful deletion, no content is returned.
 *
 * Users can remove ratings they no longer wish to associate with a recipe,
 * supporting data hygiene and user choice. Authorization restricts deletion to
 * the rating owner.
 *
 * This operation complements create, read, and update APIs for managing ratings
 * effectively.
 *
 * @param props.connection
 * @param props.id Unique identifier of the target rating
 * @path /recipeSharing/regularUser/ratings/:id
 * @accessor api.functional.recipeSharing.regularUser.ratings.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target rating */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/recipeSharing/regularUser/ratings/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/recipeSharing/regularUser/ratings/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
