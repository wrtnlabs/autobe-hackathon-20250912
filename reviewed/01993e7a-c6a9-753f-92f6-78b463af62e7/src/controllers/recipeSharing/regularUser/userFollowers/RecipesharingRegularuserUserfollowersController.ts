import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { postrecipeSharingRegularUserUserFollowers } from "../../../../providers/postrecipeSharingRegularUserUserFollowers";
import { RegularuserAuth } from "../../../../decorators/RegularuserAuth";
import { RegularuserPayload } from "../../../../decorators/payload/RegularuserPayload";
import { patchrecipeSharingRegularUserUserFollowers } from "../../../../providers/patchrecipeSharingRegularUserUserFollowers";
import { getrecipeSharingRegularUserUserFollowersUserFollowerId } from "../../../../providers/getrecipeSharingRegularUserUserFollowersUserFollowerId";
import { putrecipeSharingRegularUserUserFollowersUserFollowerId } from "../../../../providers/putrecipeSharingRegularUserUserFollowersUserFollowerId";
import { deleterecipeSharingRegularUserUserFollowersUserFollowerId } from "../../../../providers/deleterecipeSharingRegularUserUserFollowersUserFollowerId";

import { IRecipeSharingUserFollower } from "../../../../api/structures/IRecipeSharingUserFollower";
import { IPageIRecipeSharingUserFollower } from "../../../../api/structures/IPageIRecipeSharingUserFollower";

@Controller("/recipeSharing/regularUser/userFollowers")
export class RecipesharingRegularuserUserfollowersController {
  /**
   * Create a new user follower relationship.
   *
   * Create a new user follower connection, linking follower user to followee
   * user.
   *
   * This operation is critical for social engagement features, allowing users
   * to follow each other and receive personalized feeds.
   *
   * Security involves validating authenticated user privileges and preventing
   * duplicate follow relationships.
   *
   * Request body includes follower_user_id and followee_user_id UUIDs.
   *
   * Response returns the created follower relationship with timestamps.
   *
   * Validation ensures both users exist, and no prior follow relationship
   * already exists.
   *
   * No request parameters are required since POST uses request body.
   *
   * This operation supports social interaction in the Recipe Sharing platform.
   *
   * @param connection
   * @param body Follower and followee user IDs to create the follower
   *   connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedBody()
    body: IRecipeSharingUserFollower.ICreate,
  ): Promise<IRecipeSharingUserFollower> {
    try {
      return await postrecipeSharingRegularUserUserFollowers({
        regularUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and retrieve paginated list of user followers.
   *
   * Retrieve a filtered and paginated list of user follower connections in the
   * recipe sharing platform. This list supports search, filtering by follower
   * or followee user ID, sorting, and pagination.
   *
   * Each follower record identifies the follower and the followee, along with
   * timestamps and soft deletion status if present.
   *
   * Security considerations involve ensuring only authorized users can view
   * follower relationships, protecting privacy.
   *
   * Related operations include creating new follower relationships, retrieving
   * individual follower relationships, and deleting follows.
   *
   * Results aid in building social graphs, personalized feeds, and UI
   * components displaying followers and following lists.
   *
   * @param connection
   * @param body Search criteria and pagination parameters for filtering user
   *   followers
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedBody()
    body: IRecipeSharingUserFollower.IRequest,
  ): Promise<IPageIRecipeSharingUserFollower.ISummary> {
    try {
      return await patchrecipeSharingRegularUserUserFollowers({
        regularUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve user follower relationship by ID.
   *
   * Retrieve detailed information about a user follower relationship by
   * follower ID.
   *
   * The follower entity contains the UUID of both follower and followee users
   * and audit timestamps. This supports social features to display follower
   * connections.
   *
   * Security considerations must protect follower relationship privacy.
   *
   * Validation includes UUID format and record existence verification.
   *
   * No request body is needed for this GET operation.
   *
   * Returns the follower relationship object corresponding to the specified
   * identifier.
   *
   * @param connection
   * @param userFollowerId Unique user follower relationship UUID
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":userFollowerId")
  public async at(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedParam("userFollowerId")
    userFollowerId: string & tags.Format<"uuid">,
  ): Promise<IRecipeSharingUserFollower> {
    try {
      return await getrecipeSharingRegularUserUserFollowersUserFollowerId({
        regularUser,
        userFollowerId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a user follower relationship by ID.
   *
   * Update the user follower record identified by the provided userFollowerId
   * path parameter. This record represents the follow relationship between one
   * user (the follower) and another user (the followee). The request body
   * contains the new follower and/or followee user IDs with valid UUID format.
   * Only authorized users with the correct roles can perform this update.
   *
   * The updating process checks that the follower and followee users exist and
   * preserves database relations. Upon success, the operation returns the
   * updated user follower information. Errors may occur if the provided
   * identifier does not exist or if the input data fails validation.
   *
   * This API corresponds to the recipe_sharing_user_followers table in the
   * Prisma schema, which defines follower-followee user relations with auditing
   * timestamps.
   *
   * @param connection
   * @param userFollowerId Unique identifier of the user follower relationship
   *   to update
   * @param body User follower update information
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":userFollowerId")
  public async update(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedParam("userFollowerId")
    userFollowerId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IRecipeSharingUserFollower.IUpdate,
  ): Promise<IRecipeSharingUserFollower> {
    try {
      return await putrecipeSharingRegularUserUserFollowersUserFollowerId({
        regularUser,
        userFollowerId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete a user follower relationship by ID.
   *
   * Delete a user follower record identified by the userFollowerId path
   * parameter. This permanently removes the follower relation between users
   * from the system database.
   *
   * Authorization requires authenticated regular or premium users with
   * permissions to modify their follower links.
   *
   * Upon success, no response body is returned. If the target follower record
   * does not exist, an error is returned.
   *
   * This maps to the recipe_sharing_user_followers table in the Prisma DB
   * schema, which manages social user follower relationships.
   *
   * @param connection
   * @param userFollowerId Unique identifier of the user follower relationship
   *   to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":userFollowerId")
  public async erase(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedParam("userFollowerId")
    userFollowerId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deleterecipeSharingRegularUserUserFollowersUserFollowerId({
        regularUser,
        userFollowerId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
