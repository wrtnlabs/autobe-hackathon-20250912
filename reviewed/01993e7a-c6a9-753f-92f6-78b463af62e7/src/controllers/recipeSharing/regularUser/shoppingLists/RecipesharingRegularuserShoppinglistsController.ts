import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { getrecipeSharingRegularUserShoppingListsShoppingListId } from "../../../../providers/getrecipeSharingRegularUserShoppingListsShoppingListId";
import { RegularuserAuth } from "../../../../decorators/RegularuserAuth";
import { RegularuserPayload } from "../../../../decorators/payload/RegularuserPayload";
import { putrecipeSharingRegularUserShoppingListsShoppingListId } from "../../../../providers/putrecipeSharingRegularUserShoppingListsShoppingListId";
import { deleterecipeSharingRegularUserShoppingListsShoppingListId } from "../../../../providers/deleterecipeSharingRegularUserShoppingListsShoppingListId";
import { postrecipeSharingRegularUserShoppingLists } from "../../../../providers/postrecipeSharingRegularUserShoppingLists";

import { IRecipeSharingShoppingList } from "../../../../api/structures/IRecipeSharingShoppingList";

@Controller("/recipeSharing/regularUser/shoppingLists")
export class RecipesharingRegularuserShoppinglistsController {
  /**
   * Retrieve details of a specific shopping list.
   *
   * Retrieve detailed information for a shopping list identified by the
   * shoppingListId parameter. Data includes all shopping list metadata plus
   * individual shopping list items.
   *
   * Only authenticated users with the "regularUser" role may access this
   * endpoint.
   *
   * The operation fetches data from the recipe_sharing_shopping_lists table and
   * related recipe_sharing_shopping_list_items linked by shopping_list_id.
   *
   * This API enables viewing or editing shopping lists within client
   * applications.
   *
   * @param connection
   * @param shoppingListId Unique identifier of the shopping list to retrieve
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":shoppingListId")
  public async at(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedParam("shoppingListId")
    shoppingListId: string & tags.Format<"uuid">,
  ): Promise<IRecipeSharingShoppingList> {
    try {
      return await getrecipeSharingRegularUserShoppingListsShoppingListId({
        regularUser,
        shoppingListId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing shopping list by ID.
   *
   * Update an existing shopping list belonging to the authenticated user. This
   * operation allows modifying fields such as the shopping list's name and
   * timestamps while maintaining data integrity and user ownership validation.
   *
   * Security considerations restrict updates to shopping lists owned by the
   * requesting user, ensuring privacy and proper access control.
   *
   * This API endpoint operates on the 'recipe_sharing_shopping_lists' table
   * from the Prisma schema, which maintains shopping lists created for
   * consolidating ingredient quantities needed for meal planning and grocery
   * shopping.
   *
   * Upon successful update, the updated shopping list information is returned.
   *
   * @param connection
   * @param shoppingListId Unique identifier of the shopping list to update
   * @param body Shopping list update data
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":shoppingListId")
  public async update(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedParam("shoppingListId")
    shoppingListId: string,
    @TypedBody()
    body: IRecipeSharingShoppingList.IUpdate,
  ): Promise<IRecipeSharingShoppingList> {
    try {
      return await putrecipeSharingRegularUserShoppingListsShoppingListId({
        regularUser,
        shoppingListId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete a shopping list by ID.
   *
   * Permanently delete a shopping list owned by the authenticated user. This
   * operation removes the shopping list record and all related shopping list
   * items from the database.
   *
   * Security measures ensure only the owner of the shopping list can perform
   * deletion, preventing unauthorized data removal.
   *
   * This API operation corresponds to the 'recipe_sharing_shopping_lists' table
   * in the Prisma Prisma schema, which stores user-generated shopping lists
   * with soft delete support. This delete operation performs a hard delete
   * eliminating the record entirely.
   *
   * No content is returned on successful deletion.
   *
   * @param connection
   * @param shoppingListId Unique identifier of the shopping list to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":shoppingListId")
  public async erase(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedParam("shoppingListId")
    shoppingListId: string,
  ): Promise<void> {
    try {
      return await deleterecipeSharingRegularUserShoppingListsShoppingListId({
        regularUser,
        shoppingListId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Create a new shopping list with specified name and optional list items.
   * Each item specifies ingredient reference, quantity, and unit.
   *
   * The newly created shopping list will be associated with the authenticated
   * 'regularUser'.
   *
   * Validations cover the presence of required data and correct ingredient
   * references.
   *
   * Use this API call to manage grocery shopping linked to meal plans or
   * collections.
   *
   * @param connection
   * @param body Details of the shopping list to create including items
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @RegularuserAuth()
    regularUser: RegularuserPayload,
    @TypedBody()
    body: IRecipeSharingShoppingList.ICreate,
  ): Promise<IRecipeSharingShoppingList> {
    try {
      return await postrecipeSharingRegularUserShoppingLists({
        regularUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
