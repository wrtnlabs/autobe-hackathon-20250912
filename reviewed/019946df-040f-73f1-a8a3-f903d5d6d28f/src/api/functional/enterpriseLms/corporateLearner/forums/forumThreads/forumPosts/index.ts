import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEnterpriseLmsForumPost } from "../../../../../../structures/IEnterpriseLmsForumPost";
import { IPageIEnterpriseLmsForumPost } from "../../../../../../structures/IPageIEnterpriseLmsForumPost";

/**
 * Create a new forum post in a forum thread.
 *
 * Create a new forum post under a specified forum thread using the provided
 * post content and author information.
 *
 * This operation inserts a record into the `enterprise_lms_forum_posts` table,
 * linking the post to the given forum and forum thread.
 *
 * Validation includes verifying thread existence and permission to post. The
 * post content must be a valid textual body.
 *
 * The response returns the freshly created post including its unique ID,
 * timestamps, and author data.
 *
 * Security is enforced to restrict creation to authorized users within the
 * tenant.
 *
 * This operation performs a write action affecting the database state.
 *
 * @param props.connection
 * @param props.forumId Unique identifier of the target forum
 * @param props.forumThreadId Unique identifier of the target forum thread
 * @param props.body New forum post creation data
 * @path /enterpriseLms/corporateLearner/forums/:forumId/forumThreads/:forumThreadId/forumPosts
 * @accessor api.functional.enterpriseLms.corporateLearner.forums.forumThreads.forumPosts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target forum */
    forumId: string & tags.Format<"uuid">;

    /** Unique identifier of the target forum thread */
    forumThreadId: string & tags.Format<"uuid">;

    /** New forum post creation data */
    body: IEnterpriseLmsForumPost.ICreate;
  };
  export type Body = IEnterpriseLmsForumPost.ICreate;
  export type Response = IEnterpriseLmsForumPost;

  export const METADATA = {
    method: "POST",
    path: "/enterpriseLms/corporateLearner/forums/:forumId/forumThreads/:forumThreadId/forumPosts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/corporateLearner/forums/${encodeURIComponent(props.forumId ?? "null")}/forumThreads/${encodeURIComponent(props.forumThreadId ?? "null")}/forumPosts`;
  export const random = (): IEnterpriseLmsForumPost =>
    typia.random<IEnterpriseLmsForumPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forumId")(() => typia.assert(props.forumId));
      assert.param("forumThreadId")(() => typia.assert(props.forumThreadId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve forum posts within a forum thread.
 *
 * Retrieve a list of forum posts within a designated forum thread identified by
 * forumId and forumThreadId.
 *
 * This operation interacts with the `enterprise_lms_forum_posts` table, which
 * contains individual posts authored by corporate learners within forum
 * threads. It enables clients to paginate and filter posts based on criteria
 * such as creation date or author.
 *
 * Security measures ensure only authenticated and authorized users within the
 * tenant can access posts. The parent forum and thread context define the
 * scope.
 *
 * The response includes detailed post information including content body,
 * author id, timestamps, and soft deletion status. This endpoint does not
 * modify data.
 *
 * @param props.connection
 * @param props.forumId Unique identifier of the target forum
 * @param props.forumThreadId Unique identifier of the target forum thread
 * @param props.body Search criteria and pagination parameters for forum posts
 *   filtering
 * @path /enterpriseLms/corporateLearner/forums/:forumId/forumThreads/:forumThreadId/forumPosts
 * @accessor api.functional.enterpriseLms.corporateLearner.forums.forumThreads.forumPosts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the target forum */
    forumId: string & tags.Format<"uuid">;

    /** Unique identifier of the target forum thread */
    forumThreadId: string & tags.Format<"uuid">;

    /** Search criteria and pagination parameters for forum posts filtering */
    body: IEnterpriseLmsForumPost.IRequest;
  };
  export type Body = IEnterpriseLmsForumPost.IRequest;
  export type Response = IPageIEnterpriseLmsForumPost;

  export const METADATA = {
    method: "PATCH",
    path: "/enterpriseLms/corporateLearner/forums/:forumId/forumThreads/:forumThreadId/forumPosts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/corporateLearner/forums/${encodeURIComponent(props.forumId ?? "null")}/forumThreads/${encodeURIComponent(props.forumThreadId ?? "null")}/forumPosts`;
  export const random = (): IPageIEnterpriseLmsForumPost =>
    typia.random<IPageIEnterpriseLmsForumPost>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forumId")(() => typia.assert(props.forumId));
      assert.param("forumThreadId")(() => typia.assert(props.forumThreadId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single forum post by its ID.
 *
 * Fetch detailed information about a specific forum post using its unique
 * identifier forumPostId, within the context of its parent forum and forum
 * thread.
 *
 * The forum post data comes from the `enterprise_lms_forum_posts` table and
 * includes content body, author, timestamps, and soft deletion status.
 *
 * The operation enforces tenant and role-based security to ensure only
 * authorized users can access the post.
 *
 * The response returns the full forum post entity for display or further
 * processing.
 *
 * No modifications occur as this is a read-only operation.
 *
 * @param props.connection
 * @param props.forumId Unique identifier of the target forum
 * @param props.forumThreadId Unique identifier of the target forum thread
 * @param props.forumPostId Unique identifier of the target forum post
 * @path /enterpriseLms/corporateLearner/forums/:forumId/forumThreads/:forumThreadId/forumPosts/:forumPostId
 * @accessor api.functional.enterpriseLms.corporateLearner.forums.forumThreads.forumPosts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target forum */
    forumId: string & tags.Format<"uuid">;

    /** Unique identifier of the target forum thread */
    forumThreadId: string & tags.Format<"uuid">;

    /** Unique identifier of the target forum post */
    forumPostId: string & tags.Format<"uuid">;
  };
  export type Response = IEnterpriseLmsForumPost;

  export const METADATA = {
    method: "GET",
    path: "/enterpriseLms/corporateLearner/forums/:forumId/forumThreads/:forumThreadId/forumPosts/:forumPostId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/corporateLearner/forums/${encodeURIComponent(props.forumId ?? "null")}/forumThreads/${encodeURIComponent(props.forumThreadId ?? "null")}/forumPosts/${encodeURIComponent(props.forumPostId ?? "null")}`;
  export const random = (): IEnterpriseLmsForumPost =>
    typia.random<IEnterpriseLmsForumPost>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forumId")(() => typia.assert(props.forumId));
      assert.param("forumThreadId")(() => typia.assert(props.forumThreadId));
      assert.param("forumPostId")(() => typia.assert(props.forumPostId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing forum post.
 *
 * Update the content and metadata of an existing forum post specified by
 * forumPostId within its parent forum and thread.
 *
 * This write operation modifies the `enterprise_lms_forum_posts` record.
 *
 * It enforces access control to ensure only authorized users, typically authors
 * or admins, can perform the update.
 *
 * The client must provide the complete updated post data.
 *
 * The response returns the updated forum post entity reflecting the changes.
 *
 * Audit logging and concurrency control policies apply.
 *
 * This operation does not perform soft deletion or archival.
 *
 * @param props.connection
 * @param props.forumId Unique identifier of the target forum
 * @param props.forumThreadId Unique identifier of the target forum thread
 * @param props.forumPostId Unique identifier of the target forum post
 * @param props.body Updated forum post information
 * @path /enterpriseLms/corporateLearner/forums/:forumId/forumThreads/:forumThreadId/forumPosts/:forumPostId
 * @accessor api.functional.enterpriseLms.corporateLearner.forums.forumThreads.forumPosts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target forum */
    forumId: string & tags.Format<"uuid">;

    /** Unique identifier of the target forum thread */
    forumThreadId: string & tags.Format<"uuid">;

    /** Unique identifier of the target forum post */
    forumPostId: string & tags.Format<"uuid">;

    /** Updated forum post information */
    body: IEnterpriseLmsForumPost.IUpdate;
  };
  export type Body = IEnterpriseLmsForumPost.IUpdate;
  export type Response = IEnterpriseLmsForumPost;

  export const METADATA = {
    method: "PUT",
    path: "/enterpriseLms/corporateLearner/forums/:forumId/forumThreads/:forumThreadId/forumPosts/:forumPostId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/corporateLearner/forums/${encodeURIComponent(props.forumId ?? "null")}/forumThreads/${encodeURIComponent(props.forumThreadId ?? "null")}/forumPosts/${encodeURIComponent(props.forumPostId ?? "null")}`;
  export const random = (): IEnterpriseLmsForumPost =>
    typia.random<IEnterpriseLmsForumPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("forumId")(() => typia.assert(props.forumId));
      assert.param("forumThreadId")(() => typia.assert(props.forumThreadId));
      assert.param("forumPostId")(() => typia.assert(props.forumPostId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
