import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEnterpriseLmsSystemAdmin } from "../../../../structures/IEnterpriseLmsSystemAdmin";
import { IPageIEnterpriseLmsSystemAdmin } from "../../../../structures/IPageIEnterpriseLmsSystemAdmin";

/**
 * Create a new system administrator user account.
 *
 * This operation validates input data and inserts a new record into the
 * enterprise_lms_systemadmin table.
 *
 * Creation requires unique email, secure password hash, and initial status.
 *
 * Access is restricted to users with systemAdmin role to prevent unauthorized
 * admin account creation.
 *
 * Response returns the newly created systemadmin details including ID and
 * timestamps.
 *
 * Errors include 400 for validation failures, 409 if email already exists, and
 * 403 if unauthorized.
 *
 * @param props.connection
 * @param props.body Details for creating a system administrator account
 * @path /enterpriseLms/systemAdmin/systemadmins
 * @accessor api.functional.enterpriseLms.systemAdmin.systemadmins.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Details for creating a system administrator account */
    body: IEnterpriseLmsSystemAdmin.ICreate;
  };
  export type Body = IEnterpriseLmsSystemAdmin.ICreate;
  export type Response = IEnterpriseLmsSystemAdmin;

  export const METADATA = {
    method: "POST",
    path: "/enterpriseLms/systemAdmin/systemadmins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/enterpriseLms/systemAdmin/systemadmins";
  export const random = (): IEnterpriseLmsSystemAdmin =>
    typia.random<IEnterpriseLmsSystemAdmin>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of system administrators.
 *
 * Retrieve a filtered, paginated list of system administrator accounts.
 *
 * Provides the ability to search, sort, and filter system admins by various
 * criteria such as email, status, and creation date.
 *
 * Access is restricted to systemAdmin roles to protect sensitive global
 * administrative data.
 *
 * This operation fetches data from the enterprise_lms_systemadmin table
 * including user IDs, emails, names, statuses, and timestamps.
 *
 * Request body includes search and pagination parameters to customize results.
 *
 * Response returns paginated summaries suited for admin management UI.
 *
 * Errors include 403 unauthorized and 400 invalid search parameters.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for system
 *   administrators filtering
 * @path /enterpriseLms/systemAdmin/systemadmins
 * @accessor api.functional.enterpriseLms.systemAdmin.systemadmins.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and pagination parameters for system administrators
     * filtering
     */
    body: IEnterpriseLmsSystemAdmin.IRequest;
  };
  export type Body = IEnterpriseLmsSystemAdmin.IRequest;
  export type Response = IPageIEnterpriseLmsSystemAdmin.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/enterpriseLms/systemAdmin/systemadmins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/enterpriseLms/systemAdmin/systemadmins";
  export const random = (): IPageIEnterpriseLmsSystemAdmin.ISummary =>
    typia.random<IPageIEnterpriseLmsSystemAdmin.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve system administrator by ID.
 *
 * Retrieve detailed system administrator information by ID.
 *
 * Access restricted to systemAdmin role due to sensitive nature of the data.
 *
 * Returns full systemadmin entity data from enterprise_lms_systemadmin table
 * including email, status, first and last names, creation and update
 * timestamps.
 *
 * Errors may include 404 if the systemadmin ID does not exist or 403 if
 * unauthorized.
 *
 * Method is GET and no request body is required.
 *
 * @param props.connection
 * @param props.systemadminId Unique identifier of the system administrator
 * @path /enterpriseLms/systemAdmin/systemadmins/:systemadminId
 * @accessor api.functional.enterpriseLms.systemAdmin.systemadmins.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the system administrator */
    systemadminId: string & tags.Format<"uuid">;
  };
  export type Response = IEnterpriseLmsSystemAdmin;

  export const METADATA = {
    method: "GET",
    path: "/enterpriseLms/systemAdmin/systemadmins/:systemadminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/systemAdmin/systemadmins/${encodeURIComponent(props.systemadminId ?? "null")}`;
  export const random = (): IEnterpriseLmsSystemAdmin =>
    typia.random<IEnterpriseLmsSystemAdmin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemadminId")(() => typia.assert(props.systemadminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing System Administrator user.
 *
 * Update a System Administrator user's information within the multi-tenant
 * enterprise LMS. This operation allows authorized users with system
 * administrator roles to modify account details such as email, password hash,
 * first and last names, and account status. Permissions and data validation are
 * enforced to maintain system security and data integrity.
 *
 * The underlying database entity is the enterprise_lms_systemadmin table, which
 * ensures the multi-tenant isolation via tenant_id. The operation requires a
 * system admin role and includes concurrency control via timestamp updates.
 *
 * This operation requires the systemadminId parameter as a path parameter and
 * an update request body conforming to IEnterpriseLmsSystemadmin.IUpdate. The
 * response returns the updated System Administrator user record.
 *
 * Access to this operation is restricted to users with the 'systemAdmin' role
 * to preserve security and integrity within the platform.
 *
 * @param props.connection
 * @param props.systemadminId Unique identifier of the target system
 *   administrator user
 * @param props.body Update data for the System Administrator user
 * @path /enterpriseLms/systemAdmin/systemadmins/:systemadminId
 * @accessor api.functional.enterpriseLms.systemAdmin.systemadmins.updateSystemAdmin
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateSystemAdmin(
  connection: IConnection,
  props: updateSystemAdmin.Props,
): Promise<updateSystemAdmin.Response> {
  return true === connection.simulate
    ? updateSystemAdmin.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateSystemAdmin.METADATA,
          path: updateSystemAdmin.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateSystemAdmin {
  export type Props = {
    /** Unique identifier of the target system administrator user */
    systemadminId: string & tags.Format<"uuid">;

    /** Update data for the System Administrator user */
    body: IEnterpriseLmsSystemAdmin.IUpdate;
  };
  export type Body = IEnterpriseLmsSystemAdmin.IUpdate;
  export type Response = IEnterpriseLmsSystemAdmin;

  export const METADATA = {
    method: "PUT",
    path: "/enterpriseLms/systemAdmin/systemadmins/:systemadminId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/systemAdmin/systemadmins/${encodeURIComponent(props.systemadminId ?? "null")}`;
  export const random = (): IEnterpriseLmsSystemAdmin =>
    typia.random<IEnterpriseLmsSystemAdmin>();
  export const simulate = (
    connection: IConnection,
    props: updateSystemAdmin.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateSystemAdmin.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemadminId")(() => typia.assert(props.systemadminId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a System Administrator user permanently.
 *
 * Permanently erase a System Administrator user from the system. This operation
 * removes the user record completely and all associated session data. Access is
 * limited to system administrators to prevent accidental or unauthorized
 * deletions.
 *
 * It requires the systemadminId path parameter and does not have a request body
 * or response body.
 *
 * The underlying table is enterprise_lms_systemadmin and deletion is hard
 * without a soft delete flag.
 *
 * Authorization is restricted to the 'systemAdmin' role.
 *
 * @param props.connection
 * @param props.systemadminId Unique identifier of the target system
 *   administrator user
 * @path /enterpriseLms/systemAdmin/systemadmins/:systemadminId
 * @accessor api.functional.enterpriseLms.systemAdmin.systemadmins.eraseSystemAdmin
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseSystemAdmin(
  connection: IConnection,
  props: eraseSystemAdmin.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseSystemAdmin.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseSystemAdmin.METADATA,
          path: eraseSystemAdmin.path(props),
          status: null,
        },
      );
}
export namespace eraseSystemAdmin {
  export type Props = {
    /** Unique identifier of the target system administrator user */
    systemadminId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/enterpriseLms/systemAdmin/systemadmins/:systemadminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/systemAdmin/systemadmins/${encodeURIComponent(props.systemadminId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseSystemAdmin.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseSystemAdmin.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("systemadminId")(() => typia.assert(props.systemadminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
