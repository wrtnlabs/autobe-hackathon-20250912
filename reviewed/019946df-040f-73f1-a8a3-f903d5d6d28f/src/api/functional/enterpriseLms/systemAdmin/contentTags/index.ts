import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEnterpriseLmsContentTag } from "../../../../structures/IEnterpriseLmsContentTag";
import { IPageIEnterpriseLmsContentTag } from "../../../../structures/IPageIEnterpriseLmsContentTag";
export * as childTags from "./childTags/index";

/**
 * Create a new content tag for content classification within the enterprise
 * LMS.
 *
 * Security: Only users with roles organizationAdmin, contentCreatorInstructor,
 * or systemAdmin can create tags.
 *
 * Relationships: Tags are tenant specific and bound to the organization.
 *
 * Validation: The code and name must be unique and valid within the tenant.
 *
 * Behavior: Persists the new tag and returns the created entity.
 *
 * Related APIs: List tags, get tag details, update tags.
 *
 * Errors: Returns 400 for validation failures or duplicate codes.
 *
 * @param props.connection
 * @param props.body Content tag creation data
 * @path /enterpriseLms/systemAdmin/contentTags
 * @accessor api.functional.enterpriseLms.systemAdmin.contentTags.createContentTag
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createContentTag(
  connection: IConnection,
  props: createContentTag.Props,
): Promise<createContentTag.Response> {
  return true === connection.simulate
    ? createContentTag.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createContentTag.METADATA,
          path: createContentTag.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createContentTag {
  export type Props = {
    /** Content tag creation data */
    body: IEnterpriseLmsContentTag.ICreate;
  };
  export type Body = IEnterpriseLmsContentTag.ICreate;
  export type Response = IEnterpriseLmsContentTag;

  export const METADATA = {
    method: "POST",
    path: "/enterpriseLms/systemAdmin/contentTags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/enterpriseLms/systemAdmin/contentTags";
  export const random = (): IEnterpriseLmsContentTag =>
    typia.random<IEnterpriseLmsContentTag>();
  export const simulate = (
    connection: IConnection,
    props: createContentTag.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createContentTag.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated list of content tags.
 *
 * Retrieve a paginated list of content tags used to classify content materials.
 * This list supports search, filtering, and sorting to enable efficient content
 * discovery and management.
 *
 * Security: Only users with roles organizationAdmin, contentCreatorInstructor,
 * or systemAdmin may access.
 *
 * Relationships: Tags are tenant specific, ensuring content classification
 * boundaries.
 *
 * Validation: The request body allows filtering by tag properties such as code,
 * name, and description.
 *
 * Behavior: Supports pagination and returns tag summaries for efficient
 * display.
 *
 * Related APIs: Get details of a specific tag, Create a new tag, Update an
 * existing tag.
 *
 * Errors: Returns 400 for invalid search parameters or pagination values.
 *
 * @param props.connection
 * @param props.body Filter and pagination parameters for content tags
 * @path /enterpriseLms/systemAdmin/contentTags
 * @accessor api.functional.enterpriseLms.systemAdmin.contentTags.indexContentTag
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexContentTag(
  connection: IConnection,
  props: indexContentTag.Props,
): Promise<indexContentTag.Response> {
  return true === connection.simulate
    ? indexContentTag.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexContentTag.METADATA,
          path: indexContentTag.path(),
          status: null,
        },
        props.body,
      );
}
export namespace indexContentTag {
  export type Props = {
    /** Filter and pagination parameters for content tags */
    body: IEnterpriseLmsContentTag.IRequest;
  };
  export type Body = IEnterpriseLmsContentTag.IRequest;
  export type Response = IPageIEnterpriseLmsContentTag.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/enterpriseLms/systemAdmin/contentTags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/enterpriseLms/systemAdmin/contentTags";
  export const random = (): IPageIEnterpriseLmsContentTag.ISummary =>
    typia.random<IPageIEnterpriseLmsContentTag.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: indexContentTag.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexContentTag.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a specific content tag.
 *
 * Retrieve detailed information about a specific content tag by its unique
 * identifier.
 *
 * Security: Restricted to users with roles organizationAdmin,
 * contentCreatorInstructor, or systemAdmin.
 *
 * Relationships: The content tag is tenant isolated to ensure data security and
 * privacy.
 *
 * Validation: The tag ID must be a valid UUID.
 *
 * Behavior: Returns the full content tag entity details for display or editing.
 *
 * Related APIs: List content tags, create new tags, update existing tags.
 *
 * Errors: Returns 404 if tag not found, 403 for unauthorized access.
 *
 * @param props.connection
 * @param props.id Unique identifier of the content tag
 * @path /enterpriseLms/systemAdmin/contentTags/:id
 * @accessor api.functional.enterpriseLms.systemAdmin.contentTags.atContentTag
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atContentTag(
  connection: IConnection,
  props: atContentTag.Props,
): Promise<atContentTag.Response> {
  return true === connection.simulate
    ? atContentTag.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atContentTag.METADATA,
          path: atContentTag.path(props),
          status: null,
        },
      );
}
export namespace atContentTag {
  export type Props = {
    /** Unique identifier of the content tag */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IEnterpriseLmsContentTag;

  export const METADATA = {
    method: "GET",
    path: "/enterpriseLms/systemAdmin/contentTags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/systemAdmin/contentTags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IEnterpriseLmsContentTag =>
    typia.random<IEnterpriseLmsContentTag>();
  export const simulate = (
    connection: IConnection,
    props: atContentTag.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atContentTag.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update content tag by ID.
 *
 * Update a content tag by its unique ID.
 *
 * This operation modifies the tag's identifying code, name, and optional
 * description within the content management system.
 *
 * Security and authorization are enforced to allow only system administrators
 * to perform this update operation.
 *
 * The operation aligns with the enterprise_lms_content_tags table structure in
 * the Prisma schema, ensuring data integrity and validation.
 *
 * Errors returned may include invalid UUID format, uniqueness violations of the
 * code, or unauthorized access attempts.
 *
 * @param props.connection
 * @param props.id Unique identifier of the content tag to update
 * @param props.body Update information for the content tag
 * @path /enterpriseLms/systemAdmin/contentTags/:id
 * @accessor api.functional.enterpriseLms.systemAdmin.contentTags.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the content tag to update */
    id: string & tags.Format<"uuid">;

    /** Update information for the content tag */
    body: IEnterpriseLmsContentTag.IUpdate;
  };
  export type Body = IEnterpriseLmsContentTag.IUpdate;
  export type Response = IEnterpriseLmsContentTag;

  export const METADATA = {
    method: "PUT",
    path: "/enterpriseLms/systemAdmin/contentTags/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/enterpriseLms/systemAdmin/contentTags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IEnterpriseLmsContentTag =>
    typia.random<IEnterpriseLmsContentTag>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete content tag by ID.
 *
 * Delete a content tag by its unique ID.
 *
 * This operation performs a permanent hard delete of the specified content tag
 * from the system.
 *
 * Restricted to system administrators for security and governance purposes.
 *
 * Clients should ensure the tag is not referenced by other entities before
 * deletion to avoid referential integrity issues.
 *
 * Errors may occur if the tag does not exist or if dependencies prevent
 * deletion.
 *
 * @param props.connection
 * @param props.id Unique identifier of the content tag to delete
 * @path /enterpriseLms/systemAdmin/contentTags/:id
 * @accessor api.functional.enterpriseLms.systemAdmin.contentTags.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the content tag to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/enterpriseLms/systemAdmin/contentTags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/systemAdmin/contentTags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
