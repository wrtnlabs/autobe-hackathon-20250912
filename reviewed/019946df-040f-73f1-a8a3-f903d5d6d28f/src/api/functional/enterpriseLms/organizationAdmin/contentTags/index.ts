import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IEnterpriseLmsContentTag } from "../../../../structures/IEnterpriseLmsContentTag";
import { IPageIEnterpriseLmsContentTag } from "../../../../structures/IPageIEnterpriseLmsContentTag";
export * as childTags from "./childTags/index";

/**
 * Create a new content tag for content classification within the enterprise
 * LMS.
 *
 * Security: Only users with roles organizationAdmin, contentCreatorInstructor,
 * or systemAdmin can create tags.
 *
 * Relationships: Tags are tenant specific and bound to the organization.
 *
 * Validation: The code and name must be unique and valid within the tenant.
 *
 * Behavior: Persists the new tag and returns the created entity.
 *
 * Related APIs: List tags, get tag details, update tags.
 *
 * Errors: Returns 400 for validation failures or duplicate codes.
 *
 * @param props.connection
 * @param props.body Content tag creation data
 * @path /enterpriseLms/organizationAdmin/contentTags
 * @accessor api.functional.enterpriseLms.organizationAdmin.contentTags.createContentTag
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createContentTag(
  connection: IConnection,
  props: createContentTag.Props,
): Promise<createContentTag.Response> {
  return true === connection.simulate
    ? createContentTag.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createContentTag.METADATA,
          path: createContentTag.path(),
          status: null,
        },
        props.body,
      );
}
export namespace createContentTag {
  export type Props = {
    /** Content tag creation data */
    body: IEnterpriseLmsContentTag.ICreate;
  };
  export type Body = IEnterpriseLmsContentTag.ICreate;
  export type Response = IEnterpriseLmsContentTag;

  export const METADATA = {
    method: "POST",
    path: "/enterpriseLms/organizationAdmin/contentTags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/enterpriseLms/organizationAdmin/contentTags";
  export const random = (): IEnterpriseLmsContentTag =>
    typia.random<IEnterpriseLmsContentTag>();
  export const simulate = (
    connection: IConnection,
    props: createContentTag.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createContentTag.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated list of content tags.
 *
 * Retrieve a paginated list of content tags used to classify content materials.
 * This list supports search, filtering, and sorting to enable efficient content
 * discovery and management.
 *
 * Security: Only users with roles organizationAdmin, contentCreatorInstructor,
 * or systemAdmin may access.
 *
 * Relationships: Tags are tenant specific, ensuring content classification
 * boundaries.
 *
 * Validation: The request body allows filtering by tag properties such as code,
 * name, and description.
 *
 * Behavior: Supports pagination and returns tag summaries for efficient
 * display.
 *
 * Related APIs: Get details of a specific tag, Create a new tag, Update an
 * existing tag.
 *
 * Errors: Returns 400 for invalid search parameters or pagination values.
 *
 * @param props.connection
 * @param props.body Filter and pagination parameters for content tags
 * @path /enterpriseLms/organizationAdmin/contentTags
 * @accessor api.functional.enterpriseLms.organizationAdmin.contentTags.indexContentTag
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexContentTag(
  connection: IConnection,
  props: indexContentTag.Props,
): Promise<indexContentTag.Response> {
  return true === connection.simulate
    ? indexContentTag.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexContentTag.METADATA,
          path: indexContentTag.path(),
          status: null,
        },
        props.body,
      );
}
export namespace indexContentTag {
  export type Props = {
    /** Filter and pagination parameters for content tags */
    body: IEnterpriseLmsContentTag.IRequest;
  };
  export type Body = IEnterpriseLmsContentTag.IRequest;
  export type Response = IPageIEnterpriseLmsContentTag.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/enterpriseLms/organizationAdmin/contentTags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/enterpriseLms/organizationAdmin/contentTags";
  export const random = (): IPageIEnterpriseLmsContentTag.ISummary =>
    typia.random<IPageIEnterpriseLmsContentTag.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: indexContentTag.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexContentTag.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a specific content tag.
 *
 * Retrieve detailed information about a specific content tag by its unique
 * identifier.
 *
 * Security: Restricted to users with roles organizationAdmin,
 * contentCreatorInstructor, or systemAdmin.
 *
 * Relationships: The content tag is tenant isolated to ensure data security and
 * privacy.
 *
 * Validation: The tag ID must be a valid UUID.
 *
 * Behavior: Returns the full content tag entity details for display or editing.
 *
 * Related APIs: List content tags, create new tags, update existing tags.
 *
 * Errors: Returns 404 if tag not found, 403 for unauthorized access.
 *
 * @param props.connection
 * @param props.id Unique identifier of the content tag
 * @path /enterpriseLms/organizationAdmin/contentTags/:id
 * @accessor api.functional.enterpriseLms.organizationAdmin.contentTags.atContentTag
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atContentTag(
  connection: IConnection,
  props: atContentTag.Props,
): Promise<atContentTag.Response> {
  return true === connection.simulate
    ? atContentTag.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atContentTag.METADATA,
          path: atContentTag.path(props),
          status: null,
        },
      );
}
export namespace atContentTag {
  export type Props = {
    /** Unique identifier of the content tag */
    id: string & tags.Format<"uuid">;
  };
  export type Response = IEnterpriseLmsContentTag;

  export const METADATA = {
    method: "GET",
    path: "/enterpriseLms/organizationAdmin/contentTags/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/enterpriseLms/organizationAdmin/contentTags/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): IEnterpriseLmsContentTag =>
    typia.random<IEnterpriseLmsContentTag>();
  export const simulate = (
    connection: IConnection,
    props: atContentTag.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atContentTag.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
