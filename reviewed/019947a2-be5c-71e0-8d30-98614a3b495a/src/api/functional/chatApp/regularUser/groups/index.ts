import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IChatAppGroup } from "../../../../structures/IChatAppGroup";
import { IPageIChatAppGroup } from "../../../../structures/IPageIChatAppGroup";
export * as memberships from "./memberships/index";

/**
 * Create a new community group with specified name, description, and status.
 * Ensures group name uniqueness and initializes creation timestamps.
 *
 * Only authenticated users are permitted to create groups.
 *
 * Returns the full details of the created group for confirmation and further
 * actions.
 *
 * Related operations: listing groups (PATCH /groups) and updating groups (PUT
 * /groups/{groupId}).
 *
 * @param props.connection
 * @param props.body Creation information for a new community group
 * @path /chatApp/regularUser/groups
 * @accessor api.functional.chatApp.regularUser.groups.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Creation information for a new community group */
    body: IChatAppGroup.ICreate;
  };
  export type Body = IChatAppGroup.ICreate;
  export type Response = IChatAppGroup;

  export const METADATA = {
    method: "POST",
    path: "/chatApp/regularUser/groups",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/chatApp/regularUser/groups";
  export const random = (): IChatAppGroup => typia.random<IChatAppGroup>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a filtered, paginated list of community groups.
 *
 * Retrieve a paginated and searchable list of community groups from the
 * chat_app_groups table. This operation supports filtering groups based on
 * name, status, and business-specific status to facilitate user discovery of
 * community groups.
 *
 * Security considerations include role-based access control; generally, read
 * access is open to regular users to facilitate group exploration, but
 * sensitive statuses are protected.
 *
 * The operation returns summaries of community groups optimized for list
 * display, not full details. Response includes group name, status, and creation
 * data.
 *
 * Related operations include creating new groups (POST /groups) and retrieving
 * detailed group information (GET /groups/{groupId}).
 *
 * Invalid or malformed search parameters result in validation errors.
 * Pagination parameters ensure performance even with large group datasets.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for community
 *   groups filtering
 * @path /chatApp/regularUser/groups
 * @accessor api.functional.chatApp.regularUser.groups.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and pagination parameters for community groups
     * filtering
     */
    body: IChatAppGroup.IRequest;
  };
  export type Body = IChatAppGroup.IRequest;
  export type Response = IPageIChatAppGroup.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/chatApp/regularUser/groups",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/chatApp/regularUser/groups";
  export const random = (): IPageIChatAppGroup.ISummary =>
    typia.random<IPageIChatAppGroup.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve specific community group details by ID.
 *
 * Fetch detailed information of a community group by its unique groupId.
 * Includes all group metadata such as name, description, status, business
 * status, and timestamps.
 *
 * This operation ensures that only authorized users can access full group
 * details and supports error handling for non-existing groups.
 *
 * Related to group list (PATCH /groups) and group update (PUT
 * /groups/{groupId}).
 *
 * @param props.connection
 * @param props.groupId Unique identifier of the target community group
 * @path /chatApp/regularUser/groups/:groupId
 * @accessor api.functional.chatApp.regularUser.groups.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target community group */
    groupId: string & tags.Format<"uuid">;
  };
  export type Response = IChatAppGroup;

  export const METADATA = {
    method: "GET",
    path: "/chatApp/regularUser/groups/:groupId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/chatApp/regularUser/groups/${encodeURIComponent(props.groupId ?? "null")}`;
  export const random = (): IChatAppGroup => typia.random<IChatAppGroup>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("groupId")(() => typia.assert(props.groupId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing community group.
 *
 * Update properties of an existing community group by its ID. Includes
 * validation of uniqueness and status fields.
 *
 * Only group admins or authorized users may update the group.
 *
 * The response returns the updated group details.
 *
 * Related to group retrieval (GET /groups/{groupId}) and listing (PATCH
 * /groups).
 *
 * @param props.connection
 * @param props.groupId Unique identifier of the target community group to
 *   update
 * @param props.body Update information for the community group
 * @path /chatApp/regularUser/groups/:groupId
 * @accessor api.functional.chatApp.regularUser.groups.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target community group to update */
    groupId: string & tags.Format<"uuid">;

    /** Update information for the community group */
    body: IChatAppGroup.IUpdate;
  };
  export type Body = IChatAppGroup.IUpdate;
  export type Response = IChatAppGroup;

  export const METADATA = {
    method: "PUT",
    path: "/chatApp/regularUser/groups/:groupId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/chatApp/regularUser/groups/${encodeURIComponent(props.groupId ?? "null")}`;
  export const random = (): IChatAppGroup => typia.random<IChatAppGroup>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("groupId")(() => typia.assert(props.groupId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a community group by its unique identifier.
 *
 * Deletes an existing community group identified by the unique UUID provided as
 * groupId path parameter. This operation permanently removes the group and all
 * associated data such as memberships and messages.
 *
 * Security is enforced by allowing only regular users with appropriate
 * privileges to perform group deletion.
 *
 * The operation targets the chat_app_groups table in Prisma schema and respects
 * cascading deletes. It returns no data upon successful deletion.
 *
 * Errors indicate unauthorized access or non-existent target group.
 *
 * This operation is critical for maintaining data integrity and enforcing group
 * lifecycle management in the system.
 *
 * @param props.connection
 * @param props.groupId Unique identifier of the group to delete
 * @path /chatApp/regularUser/groups/:groupId
 * @accessor api.functional.chatApp.regularUser.groups.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the group to delete */
    groupId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/chatApp/regularUser/groups/:groupId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/chatApp/regularUser/groups/${encodeURIComponent(props.groupId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("groupId")(() => typia.assert(props.groupId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
