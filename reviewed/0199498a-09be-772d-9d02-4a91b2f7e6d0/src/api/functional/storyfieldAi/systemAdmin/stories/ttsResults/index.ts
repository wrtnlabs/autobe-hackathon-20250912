import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IStoryfieldAiTtsResult } from "../../../../../structures/IStoryfieldAiTtsResult";
import { IPageIStoryfieldAiTtsResult } from "../../../../../structures/IPageIStoryfieldAiTtsResult";

/**
 * Create a new story TTS result (storyfield_ai_tts_results table).
 *
 * Creates a new TTS (Text-to-Speech) result for a given story. The client
 * specifies the story, text to synthesize, dialect, and may optionally target a
 * specific story page (for per-page narration). The API validates ownership and
 * input fields: only the authenticated owner of the story (or a systemAdmin for
 * administrative scenarios) may invoke this operation. Soft-deleted or
 * non-existent stories cannot have TTS generated.
 *
 * Upon validation, the system generates audio using the specified dialect,
 * uploads it to S3 (via Spring backend), and saves a new tts_results record
 * containing the audio URI, dialect, and metadata. Output validation ensures
 * full traceability and compliance. If errors arise in synthesis or upload,
 * they are reported and fully logged per compliance policy.
 *
 * Authorization strictly enforced; all insertions are auditable. Related
 * operations include updating TTS records for error recovery, retrieval, or
 * administrative review.
 *
 * @param props.connection
 * @param props.storyId Target story's unique identifier (UUID)
 * @param props.body Parameters for TTS synthesis, including source text,
 *   dialect option, and (optional) page ID.
 * @path /storyfieldAi/systemAdmin/stories/:storyId/ttsResults
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.ttsResults.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Target story's unique identifier (UUID) */
    storyId: string & tags.Format<"uuid">;

    /**
     * Parameters for TTS synthesis, including source text, dialect option,
     * and (optional) page ID.
     */
    body: IStoryfieldAiTtsResult.ICreate;
  };
  export type Body = IStoryfieldAiTtsResult.ICreate;
  export type Response = IStoryfieldAiTtsResult;

  export const METADATA = {
    method: "POST",
    path: "/storyfieldAi/systemAdmin/stories/:storyId/ttsResults",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}/ttsResults`;
  export const random = (): IStoryfieldAiTtsResult =>
    typia.random<IStoryfieldAiTtsResult>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search TTS results for a story (filter/sort/paginate).
 *
 * This API endpoint allows an authenticated user (the owner of a story) or a
 * system administrator to retrieve a paginated, filtered list of TTS
 * (Text-to-Speech) audio generation results associated with a specific story.
 * Filters can include dialect, associated page number, creation date, or other
 * relevant parameters provided by the schema.
 *
 * The operation supports pagination and advanced search features through a
 * structured request body, essential for managing stories with numerous TTS
 * entries, dialect variations, or multi-user scenarios. Only the owner of the
 * story or a system administrator is authorized to access all TTS results for a
 * given story, ensuring security and privacy of generated media.
 *
 * Internally, this operation queries the storyfield_ai_tts_results table with
 * an enforced storyId foreign-key filter. Additional filters and sorting are
 * passed in the request body and mapped to allowable schema fields. The
 * response is a paginated structure of TTS result summary objects, formatted
 * for efficient frontend consumption; errors (such as unauthorized access or
 * invalid storyId) are reported with appropriate status and detailed messages.
 *
 * @param props.connection
 * @param props.storyId Unique identifier of the parent story whose TTS results
 *   are being listed.
 * @param props.body Filtering, sorting, and pagination options for the TTS
 *   results search.
 * @path /storyfieldAi/systemAdmin/stories/:storyId/ttsResults
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.ttsResults.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the parent story whose TTS results are being
     * listed.
     */
    storyId: string & tags.Format<"uuid">;

    /**
     * Filtering, sorting, and pagination options for the TTS results
     * search.
     */
    body: IStoryfieldAiTtsResult.IRequest;
  };
  export type Body = IStoryfieldAiTtsResult.IRequest;
  export type Response = IPageIStoryfieldAiTtsResult.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/storyfieldAi/systemAdmin/stories/:storyId/ttsResults",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}/ttsResults`;
  export const random = (): IPageIStoryfieldAiTtsResult.ISummary =>
    typia.random<IPageIStoryfieldAiTtsResult.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific story TTS result by ID (storyfield_ai_tts_results table).
 *
 * This operation allows clients to retrieve the full details of a single TTS
 * (Text-to-Speech) result attached to a generated story. The TTS result
 * includes fields such as the S3 URI of the audio file, dialect, original
 * source text, and references to the underlying story and story page (if
 * per-page audio).
 *
 * Users must be authenticated and only allowed to access their own TTS results,
 * unless elevated to a systemAdmin role for compliance or support purposes. If
 * the ttsResult has a deleted_at timestamp, standard users are forbidden from
 * accessing it, but systemAdmin may review for audits. Permission checks are
 * strict, and attempts to access others' data are logged and denied.
 *
 * The underlying storyfield_ai_tts_results table supports links to the broader
 * story via storyfield_ai_story_id and, optionally, a single page via
 * storyfield_ai_story_page_id (supporting both full-story and per-page
 * narration use cases). Soft deletion is enforced by filtering records where
 * deleted_at is null for end-users, with full access only for admin review.
 *
 * Error conditions include attempts to access results not owned by the user,
 * referencing non-existent IDs, or accessing soft-deleted records. Access and
 * error events are fully auditable per compliance policy.
 *
 * @param props.connection
 * @param props.storyId Target story's unique identifier (UUID)
 * @param props.ttsResultId The unique ID of the TTS result to retrieve (UUID)
 * @path /storyfieldAi/systemAdmin/stories/:storyId/ttsResults/:ttsResultId
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.ttsResults.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Target story's unique identifier (UUID) */
    storyId: string & tags.Format<"uuid">;

    /** The unique ID of the TTS result to retrieve (UUID) */
    ttsResultId: string & tags.Format<"uuid">;
  };
  export type Response = IStoryfieldAiTtsResult;

  export const METADATA = {
    method: "GET",
    path: "/storyfieldAi/systemAdmin/stories/:storyId/ttsResults/:ttsResultId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}/ttsResults/${encodeURIComponent(props.ttsResultId ?? "null")}`;
  export const random = (): IStoryfieldAiTtsResult =>
    typia.random<IStoryfieldAiTtsResult>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.param("ttsResultId")(() => typia.assert(props.ttsResultId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing story TTS result (storyfield_ai_tts_results table).
 *
 * Enables modification of a previously generated TTS (Text-to-Speech) result.
 * Possible update scenarios include correcting dialect, updating the page
 * association (if per-page), and regenerating TTS with corrected or new source
 * text. The operation will validate the caller's authorization (story owner or
 * systemAdmin), check record existence, and enforce that the TTS result is not
 * soft-deleted.
 *
 * If TTS audio is to be re-generated, the previous audio URI is replaced
 * following a new S3 upload (coordinated via Spring backend). All update
 * actions are logged. Soft delete means updates are only possible for records
 * with null deleted_at field. Error scenarios include attempts to update
 * others' records, soft-deleted results, or unauthorized modifications. The
 * operation enforces consistency between the TTS result and the story/page
 * association.
 *
 * Usage is limited to authorized, non-deleted TTS result entries. All changes
 * are audit-tracked for forensics and compliance.
 *
 * @param props.connection
 * @param props.storyId Target story's unique identifier (UUID)
 * @param props.ttsResultId ID of the TTS result record to update (UUID)
 * @param props.body Fields to update, which may include dialect, text, or page
 *   association.
 * @path /storyfieldAi/systemAdmin/stories/:storyId/ttsResults/:ttsResultId
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.ttsResults.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target story's unique identifier (UUID) */
    storyId: string & tags.Format<"uuid">;

    /** ID of the TTS result record to update (UUID) */
    ttsResultId: string & tags.Format<"uuid">;

    /**
     * Fields to update, which may include dialect, text, or page
     * association.
     */
    body: IStoryfieldAiTtsResult.IUpdate;
  };
  export type Body = IStoryfieldAiTtsResult.IUpdate;
  export type Response = IStoryfieldAiTtsResult;

  export const METADATA = {
    method: "PUT",
    path: "/storyfieldAi/systemAdmin/stories/:storyId/ttsResults/:ttsResultId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}/ttsResults/${encodeURIComponent(props.ttsResultId ?? "null")}`;
  export const random = (): IStoryfieldAiTtsResult =>
    typia.random<IStoryfieldAiTtsResult>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.param("ttsResultId")(() => typia.assert(props.ttsResultId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete (erase) a story TTS result (storyfield_ai_tts_results table).
 *
 * This API operation performs a soft deletion of a TTS (Text-to-Speech) result
 * generated for a user's story, setting the deleted_at timestamp in the
 * storyfield_ai_tts_results table. Only owners of the parent story or
 * systemAdmin accounts may erase a TTS result; unauthorized access is blocked
 * and fully logged. Deleting the TTS result means it will be excluded from
 * standard list and fetch operations for normal users, but remains in the
 * database for audit and possible legal compliance.
 *
 * Upon deletion, the service may also coordinate with the storage layer (such
 * as S3 via Spring backend) to restrict access or physically remove the audio
 * file, if the business and compliance rules require it. Soft deleted records
 * are only accessible by systemAdmin users for compliance review. Attempts to
 * delete already deleted or non-existent records will return clear, actionable
 * error responses and incident logs are generated.
 *
 * Ensures administrative oversight and consistent treatment of all content
 * removal operations, supporting the compliance and traceability requirements
 * of the platform.
 *
 * @param props.connection
 * @param props.storyId Target story's unique identifier (UUID)
 * @param props.ttsResultId ID of the TTS result to erase (UUID)
 * @path /storyfieldAi/systemAdmin/stories/:storyId/ttsResults/:ttsResultId
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.ttsResults.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target story's unique identifier (UUID) */
    storyId: string & tags.Format<"uuid">;

    /** ID of the TTS result to erase (UUID) */
    ttsResultId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/storyfieldAi/systemAdmin/stories/:storyId/ttsResults/:ttsResultId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}/ttsResults/${encodeURIComponent(props.ttsResultId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.param("ttsResultId")(() => typia.assert(props.ttsResultId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
