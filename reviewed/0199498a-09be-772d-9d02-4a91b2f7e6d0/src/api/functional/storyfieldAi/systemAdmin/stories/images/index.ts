import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IStoryfieldAiStoryImage } from "../../../../../structures/IStoryfieldAiStoryImage";
import { IPageIStoryfieldAiStoryImage } from "../../../../../structures/IPageIStoryfieldAiStoryImage";

/**
 * Add an image to a specific fairy tale story.
 *
 * This API endpoint enables authenticated users to upload a new image
 * associated with a particular story. The image is linked to a specific story
 * by UUID and includes properties such as image URI, description, and creation
 * metadata.
 *
 * Security is enforced by ensuring that only the story's owner (authenticated
 * user) or a system administrator has permission to add or manage images, with
 * unauthorized access attempts resulting in immediate denial.
 *
 * The operation interacts directly with the storyfield_ai_story_images table,
 * maintaining relationships with storyfield_ai_stories via the provided
 * storyId. Uploaded image URIs should reference externally stored images (such
 * as S3 pre-signed URLs) and comply with accessibility description best
 * practices. All changes are tracked for compliance and traceability, with soft
 * deletion supported.
 *
 * Validation ensures that the storyId is a valid UUID of an existing story, and
 * uploaded URIs conform to prescribed limits and schema constraints. Any
 * moderation or copyright triggers detected during upload or later review are
 * handled according to compliance and system policy.
 *
 * If an error occurs, such as invalid token, missing story, or file management
 * issue, a detailed error code and message are returned in accordance with
 * system error handling requirements.
 *
 * @param props.connection
 * @param props.storyId Unique identifier of the parent story to which the image
 *   is being added.
 * @param props.body The image URI and optional description to associate with
 *   the story.
 * @path /storyfieldAi/systemAdmin/stories/:storyId/images
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.images.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the parent story to which the image is being
     * added.
     */
    storyId: string & tags.Format<"uuid">;

    /** The image URI and optional description to associate with the story. */
    body: IStoryfieldAiStoryImage.ICreate;
  };
  export type Body = IStoryfieldAiStoryImage.ICreate;
  export type Response = IStoryfieldAiStoryImage;

  export const METADATA = {
    method: "POST",
    path: "/storyfieldAi/systemAdmin/stories/:storyId/images",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}/images`;
  export const random = (): IStoryfieldAiStoryImage =>
    typia.random<IStoryfieldAiStoryImage>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated, filtered list of images for a specific user
 * story (storyfield_ai_story_images table).
 *
 * This operation returns a filtered and paginated view of all images linked to
 * a given AI-generated story. The story is securely identified using the path
 * parameter (UUID), and all results are sourced from the
 * storyfield_ai_story_images table. The response includes image metadata (S3
 * URI, creation time, description, etc.) for story-authoring or illustration
 * management scenarios.
 *
 * The operation supports advanced query features through the request body:
 * search by description, sort by creation/update time, and flexible pagination
 * (page size, index, ordering). Only the owner of the story or a system
 * administrator can access the image list, with ownership checked against the
 * session user or role.
 *
 * All non-deleted (deleted_at is null) images attached to the story are
 * returned. Soft-deleted or orphaned images are excluded from results. The
 * endpoint is suitable for both read (list) and manage (moderation, relinking)
 * workflows. Strict validation is enforced; unauthorized or non-existent
 * resources return business-appropriate errors. Related endpoints include image
 * upload/associate, single-image access, and story retrieval.
 *
 * @param props.connection
 * @param props.storyId UUID for the target story whose associated images will
 *   be retrieved.
 * @param props.body Complex search, sort, and pagination options for retrieving
 *   images attached to the specified story. Uses
 *   IStoryfieldAiStoryImage.IRequest.
 * @path /storyfieldAi/systemAdmin/stories/:storyId/images
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.images.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID for the target story whose associated images will be retrieved. */
    storyId: string & tags.Format<"uuid">;

    /**
     * Complex search, sort, and pagination options for retrieving images
     * attached to the specified story. Uses
     * IStoryfieldAiStoryImage.IRequest.
     */
    body: IStoryfieldAiStoryImage.IRequest;
  };
  export type Body = IStoryfieldAiStoryImage.IRequest;
  export type Response = IPageIStoryfieldAiStoryImage.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/storyfieldAi/systemAdmin/stories/:storyId/images",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}/images`;
  export const random = (): IPageIStoryfieldAiStoryImage.ISummary =>
    typia.random<IPageIStoryfieldAiStoryImage.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific story image by ID, cross-checking against parent story,
 * for detail viewing and edit review (storyfield_ai_story_images table).
 *
 * This operation fetches the full metadata and S3 URI of a specific image
 * attached to a story, referencing the record in the storyfield_ai_story_images
 * table via both the parent story's UUID and the image's UUID. It is designed
 * for situations that require deep review of illustration details, advanced
 * editing workflows, or compliance oversight.
 *
 * Strict access control is enforced: only the authenticated owner of the story
 * or a user holding the systemAdmin role may request this detailed image
 * information. The system verifies that both the story and the image are not
 * soft-deleted, that the image is genuinely owned by the identified story, and
 * that all referential links are intact.
 *
 * Standard error handling covers unauthorized access, missing or deleted
 * image/story, and cross-resource mismatches. This endpoint should be used
 * together with the story image list, story retrieval, and image administration
 * operations. Audit logging is integrated for sensitive or administrative data
 * views.
 *
 * @param props.connection
 * @param props.storyId UUID for the parent story to which the image should
 *   belong.
 * @param props.imageId UUID for the target image to be retrieved in detail
 *   (storyfield_ai_story_images.id).
 * @path /storyfieldAi/systemAdmin/stories/:storyId/images/:imageId
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.images.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID for the parent story to which the image should belong. */
    storyId: string & tags.Format<"uuid">;

    /**
     * UUID for the target image to be retrieved in detail
     * (storyfield_ai_story_images.id).
     */
    imageId: string & tags.Format<"uuid">;
  };
  export type Response = IStoryfieldAiStoryImage;

  export const METADATA = {
    method: "GET",
    path: "/storyfieldAi/systemAdmin/stories/:storyId/images/:imageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): IStoryfieldAiStoryImage =>
    typia.random<IStoryfieldAiStoryImage>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.param("imageId")(() => typia.assert(props.imageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific image's metadata in a story.
 *
 * This API operation allows the authenticated user (the story owner) or a
 * system administrator to update properties of a specified image belonging to a
 * fairy tale story. Supported updates include setting a new image URI, changing
 * the description for accessibility, or updating other relevant fields as
 * permitted by the schema.
 *
 * The endpoint ensures that only authorized users may perform the
 * update—specifically, the owner of the story or a user with systemAdmin role.
 * Attempts to update images not owned by the user or outside their permission
 * scope will be strictly denied, with all actions logged for auditing
 * purposes.
 *
 * Underlying, this operation modifies the storyfield_ai_story_images table,
 * requiring both a valid storyId and imageId as path parameters. Only fields
 * allowed by the update DTO are processed, with improper changes resulting in
 * validation errors. Changes are tracked for compliance and audit, and soft
 * deletion field is handled per schema policy.
 *
 * If invalid identifiers are provided, permissions are lacking, or the image
 * record is already deleted, the operation will fail gracefully with a
 * contextual error message.
 *
 * @param props.connection
 * @param props.storyId Unique identifier of the parent story.
 * @param props.imageId Unique identifier of the image within the story to
 *   update.
 * @param props.body Fields to update for the selected story image (URI,
 *   description, etc.).
 * @path /storyfieldAi/systemAdmin/stories/:storyId/images/:imageId
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.images.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the parent story. */
    storyId: string & tags.Format<"uuid">;

    /** Unique identifier of the image within the story to update. */
    imageId: string & tags.Format<"uuid">;

    /**
     * Fields to update for the selected story image (URI, description,
     * etc.).
     */
    body: IStoryfieldAiStoryImage.IUpdate;
  };
  export type Body = IStoryfieldAiStoryImage.IUpdate;
  export type Response = IStoryfieldAiStoryImage;

  export const METADATA = {
    method: "PUT",
    path: "/storyfieldAi/systemAdmin/stories/:storyId/images/:imageId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): IStoryfieldAiStoryImage =>
    typia.random<IStoryfieldAiStoryImage>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.param("imageId")(() => typia.assert(props.imageId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove an image from a story (soft delete).
 *
 * This endpoint allows an authenticated user (the story's owner) or a system
 * administrator to remove an image from a given fairy tale story. The operation
 * implements a soft delete: the deleted_at field is set to the current
 * timestamp rather than permanently removing the record, in accordance with the
 * schema's compliance policies for recoverability and auditability.
 *
 * Both storyId and imageId path parameters identify the exact image to be
 * removed. Authorization is strictly enforced, ensuring that only the image's
 * associated story owner or a user with systemAdmin privileges can perform the
 * deletion. Attempts by unauthorized users or for non-existent/deleted images
 * are gracefully denied with clear error feedback.
 *
 * The storyfield_ai_story_images table is updated accordingly, with all actions
 * logged for audit, compliance, and potential content recovery workflows.
 * Errors such as invalid IDs, permission failures, or prior deletion are
 * explicitly handled, following the system's documented error and recovery
 * protocols.
 *
 * @param props.connection
 * @param props.storyId Unique identifier of the parent story.
 * @param props.imageId Unique identifier of the image within the story to
 *   delete.
 * @path /storyfieldAi/systemAdmin/stories/:storyId/images/:imageId
 * @accessor api.functional.storyfieldAi.systemAdmin.stories.images.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the parent story. */
    storyId: string & tags.Format<"uuid">;

    /** Unique identifier of the image within the story to delete. */
    imageId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/storyfieldAi/systemAdmin/stories/:storyId/images/:imageId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/stories/${encodeURIComponent(props.storyId ?? "null")}/images/${encodeURIComponent(props.imageId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("storyId")(() => typia.assert(props.storyId));
      assert.param("imageId")(() => typia.assert(props.imageId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
