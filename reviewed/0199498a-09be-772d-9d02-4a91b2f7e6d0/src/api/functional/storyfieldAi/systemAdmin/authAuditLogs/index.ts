import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IStoryfieldAiAuthAuditLog } from "../../../../structures/IStoryfieldAiAuthAuditLog";
import { IPageIStoryfieldAiAuthAuditLog } from "../../../../structures/IPageIStoryfieldAiAuthAuditLog";

/**
 * Search and retrieve paginated authentication/authorization audit events
 * (systemAdmin only; storyfield_ai_auth_audit_logs).
 *
 * Search and retrieve a paginated list of authentication and authorization
 * audit log events from the storyfield_ai_auth_audit_logs table. Designed for
 * use by system administrators, the endpoint provides query, sort, and filter
 * options on typical event audit fields: event type (e.g., issued, revoked,
 * denied), outcome (success/failure), related user/session/admin IDs, source
 * IP, time window, and textual search in event messages. This is vital for
 * tracking security-relevant events and ensuring policy compliance.
 *
 * Because audit logs can reveal sensitive security context, access is
 * restricted to systemAdmin role only, and all audit log access is itself
 * logged. Result summaries are returned for high-volume review: full event
 * information may require a second detail API call.
 *
 * This operation is tightly integrated with incident response, system
 * monitoring, and compliance/forensics workflows. Authorization or query
 * parameter errors are handled with clear error messages. Audit records are
 * append-only and cannot be edited or deleted by this or any other endpoint.
 *
 * @param props.connection
 * @param props.body Query, filtering, and pagination parameters for audit logs,
 *   such as event type, user/admin/session, time window, outcome.
 * @path /storyfieldAi/systemAdmin/authAuditLogs
 * @accessor api.functional.storyfieldAi.systemAdmin.authAuditLogs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Query, filtering, and pagination parameters for audit logs, such as
     * event type, user/admin/session, time window, outcome.
     */
    body: IStoryfieldAiAuthAuditLog.IRequest;
  };
  export type Body = IStoryfieldAiAuthAuditLog.IRequest;
  export type Response = IPageIStoryfieldAiAuthAuditLog.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/storyfieldAi/systemAdmin/authAuditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/storyfieldAi/systemAdmin/authAuditLogs";
  export const random = (): IPageIStoryfieldAiAuthAuditLog.ISummary =>
    typia.random<IPageIStoryfieldAiAuthAuditLog.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * View full detail for a specific authentication/authorization audit log event
 * (systemAdmin only; storyfield_ai_auth_audit_logs).
 *
 * Retrieve the full set of recorded details for a single
 * authentication/authorization audit event from the
 * storyfield_ai_auth_audit_logs table. System administrators can use this to
 * see exactly when, by whom, and with what outcome an authentication event
 * (e.g., login attempt, token refresh, revocation, validation failure)
 * occurred. The record includes actor/user/admin identification, event type,
 * result, contextual message, timestamps, and environment metadata for precise
 * forensic analysis.
 *
 * This operation is restricted to systemAdmin role, and all accesses are
 * themselves tracked for audit purposes. Access control ensures sensitive
 * information is not exposed beyond authorized admins. Typical use cases
 * include incident investigation, suspicious access review, compliance checks,
 * and security audits.
 *
 * Not found or unauthorized access errors are handled transparently per
 * security requirements. No update or deletion of audit events is allowed by
 * this or any API.
 *
 * @param props.connection
 * @param props.authAuditLogId Unique identifier (UUID) of the
 *   authentication/authorization audit log record to retrieve.
 * @path /storyfieldAi/systemAdmin/authAuditLogs/:authAuditLogId
 * @accessor api.functional.storyfieldAi.systemAdmin.authAuditLogs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier (UUID) of the authentication/authorization audit
     * log record to retrieve.
     */
    authAuditLogId: string & tags.Format<"uuid">;
  };
  export type Response = IStoryfieldAiAuthAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/storyfieldAi/systemAdmin/authAuditLogs/:authAuditLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/authAuditLogs/${encodeURIComponent(props.authAuditLogId ?? "null")}`;
  export const random = (): IStoryfieldAiAuthAuditLog =>
    typia.random<IStoryfieldAiAuthAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("authAuditLogId")(() => typia.assert(props.authAuditLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
