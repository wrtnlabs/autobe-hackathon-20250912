import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IStoryfieldAiSystemPolicy } from "../../../../structures/IStoryfieldAiSystemPolicy";
import { IPageIStoryfieldAiSystemPolicy } from "../../../../structures/IPageIStoryfieldAiSystemPolicy";

/**
 * Create a new system policy record (storyfield_ai_system_policies table).
 *
 * This API operation enables system administrators to define and register a new
 * global system policy within the 'storyfield_ai_system_policies' table. Each
 * system policy holds technical, business, or compliance rules, and serves as a
 * runtime-enforced parameter across StoryField AI platform components.
 *
 * When executed, the operation validates the provided policy code (must be
 * unique across the table), ensures descriptive documentation for traceability,
 * and validates value/type according to runtime enforcement requirements. The
 * policy is immediately active unless further toggling is required
 * post-creation. All active system policies become integral to operational
 * behavior (e.g., feature toggling, timeouts, quotas, or maintenance mode).
 *
 * Only users with 'systemAdmin' privileges may create, update, or delete system
 * policies. Required fields include a unique policy_code, name, value,
 * description, active flag, and type. Business validation enforces uniqueness
 * of the policy_code and clarity of the description to avoid misconfiguration
 * or accidental override. Errors are provided for validation failure, policy
 * conflicts, or loss of administrative privilege. Change history is audited for
 * compliance.
 *
 * Typical use cases: enabling maintenance, deploying a new feature toggle,
 * setting global quota, or changing the operational window for maintenance with
 * compliance obligations.
 *
 * This operation should be paired with update and delete endpoints for
 * comprehensive policy lifecycle management and includes error handling for
 * inputs like duplicate policy_code, missing description, or value-type
 * mismatch.
 *
 * @param props.connection
 * @param props.body Policy creation payload, including policy code, name,
 *   description, value, type, active flag, and documentation.
 * @path /storyfieldAi/systemAdmin/systemPolicies
 * @accessor api.functional.storyfieldAi.systemAdmin.systemPolicies.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Policy creation payload, including policy code, name, description,
     * value, type, active flag, and documentation.
     */
    body: IStoryfieldAiSystemPolicy.ICreate;
  };
  export type Body = IStoryfieldAiSystemPolicy.ICreate;
  export type Response = IStoryfieldAiSystemPolicy;

  export const METADATA = {
    method: "POST",
    path: "/storyfieldAi/systemAdmin/systemPolicies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/storyfieldAi/systemAdmin/systemPolicies";
  export const random = (): IStoryfieldAiSystemPolicy =>
    typia.random<IStoryfieldAiSystemPolicy>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Admin search and listing of system policy records in
 * storyfield_ai_system_policies.
 *
 * System administrators use this endpoint to retrieve a paginated, filterable
 * list of all policy records governing the Storyfield AI service. Policy
 * records define global business, technical, feature toggle, and compliance
 * rules. The results may be filtered by fields such as policy_code, name, type
 * (data type), 'active' state, or creation date. Sorting and pagination options
 * are supported, allowing efficient review and auditing.
 *
 * Strong access control is enforced; only users with systemAdmin role may
 * access this method, given the high potential business or security impact of
 * policy review and change. This operation directly reflects the business and
 * technical policy definitions stored in storyfield_ai_system_policies, indexed
 * by policy_code, active, created_at, and other key fields. Administrative
 * workflows for policy governance, change approval, and rollout rely on this
 * search function as a core capability.
 *
 * @param props.connection
 * @param props.body System policy search/filtering and pagination criteria.
 * @path /storyfieldAi/systemAdmin/systemPolicies
 * @accessor api.functional.storyfieldAi.systemAdmin.systemPolicies.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** System policy search/filtering and pagination criteria. */
    body: IStoryfieldAiSystemPolicy.IRequest;
  };
  export type Body = IStoryfieldAiSystemPolicy.IRequest;
  export type Response = IPageIStoryfieldAiSystemPolicy.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/storyfieldAi/systemAdmin/systemPolicies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/storyfieldAi/systemAdmin/systemPolicies";
  export const random = (): IPageIStoryfieldAiSystemPolicy.ISummary =>
    typia.random<IPageIStoryfieldAiSystemPolicy.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detail of a specific system policy from
 * storyfield_ai_system_policies.
 *
 * System administrators can use this endpoint to access the complete definition
 * and lifecycle attributes of a particular platform policy, including code,
 * type, descriptive name, current value, type, enforcement (active), and all
 * relevant modification timestamps. The result includes any archival (soft
 * deleted) state for historic records, as well as compliance notes in the
 * description field.
 *
 * The endpoint requires systemAdmin privileges due to the highly sensitive and
 * operationally impactful nature of policy data. Typical use cases include
 * compliance audits, configuration troubleshooting, or rollback review. All
 * requests validate that the policyId refers to a real and accessible policy,
 * returning not-found or access-denied errors for missing or restricted
 * records. This forms part of the platform's governance and controls dashboard
 * for senior technical staff.
 *
 * @param props.connection
 * @param props.policyId Unique identifier (UUID) for the system policy record
 *   to retrieve.
 * @path /storyfieldAi/systemAdmin/systemPolicies/:policyId
 * @accessor api.functional.storyfieldAi.systemAdmin.systemPolicies.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) for the system policy record to retrieve. */
    policyId: string & tags.Format<"uuid">;
  };
  export type Response = IStoryfieldAiSystemPolicy;

  export const METADATA = {
    method: "GET",
    path: "/storyfieldAi/systemAdmin/systemPolicies/:policyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/systemPolicies/${encodeURIComponent(props.policyId ?? "null")}`;
  export const random = (): IStoryfieldAiSystemPolicy =>
    typia.random<IStoryfieldAiSystemPolicy>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a system policy by ID (storyfield_ai_system_policies table).
 *
 * This API endpoint enables modification of an existing system policy in the
 * 'storyfield_ai_system_policies' table, identified by its unique primary key
 * policyId. System policies control critical runtime behavior, feature
 * toggling, and compliance constraints, so careful validation is required on
 * input.
 *
 * Administrators must provide the desired updates, which may include the
 * policy's human-readable name, value, description, type, or active status. The
 * operation enforces audit logging and will verify that the path parameter
 * policyId matches a known policy. If a record is not found, an error is
 * returned. Uniqueness of policy_code is preserved (policy_code itself is
 * generally immutable after creation), and any changes to operationally
 * sensitive fields (value, type, active flag) are immediately enforced by the
 * platform.
 *
 * Role authorization is restricted to systemAdmin users. The change history is
 * tracked with timestamps for compliance purposes. The operation supports
 * dynamic change scenarios, such as toggling maintenance mode or adjusting
 * resource quotas, and is typically paired with creation and delete endpoints
 * as part of policy lifecycle management.
 *
 * @param props.connection
 * @param props.policyId Unique identifier (UUID) for the system policy to
 *   update.
 * @param props.body Policy update input with fields to be changed (excluding
 *   immutable policy code).
 * @path /storyfieldAi/systemAdmin/systemPolicies/:policyId
 * @accessor api.functional.storyfieldAi.systemAdmin.systemPolicies.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) for the system policy to update. */
    policyId: string & tags.Format<"uuid">;

    /**
     * Policy update input with fields to be changed (excluding immutable
     * policy code).
     */
    body: IStoryfieldAiSystemPolicy.IUpdate;
  };
  export type Body = IStoryfieldAiSystemPolicy.IUpdate;
  export type Response = IStoryfieldAiSystemPolicy;

  export const METADATA = {
    method: "PUT",
    path: "/storyfieldAi/systemAdmin/systemPolicies/:policyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/storyfieldAi/systemAdmin/systemPolicies/${encodeURIComponent(props.policyId ?? "null")}`;
  export const random = (): IStoryfieldAiSystemPolicy =>
    typia.random<IStoryfieldAiSystemPolicy>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Deactivate/soft-delete a system policy by ID (storyfield_ai_system_policies
 * table).
 *
 * This API operation allows a system administrator to deactivate (soft delete)
 * a system policy in the 'storyfield_ai_system_policies' table, using the
 * unique policyId. When invoked, the operation sets the deleted_at field to the
 * current timestamp, rendering the policy logically inactive but retaining the
 * record for compliance and potential audit review.
 *
 * No physical deletion from the database occurs; the policy remains available
 * for historical review or temporary reactivation by privileged users. Business
 * integrity, compliance, and traceability are preserved by audit logs and
 * change history. The operation is strictly limited to systemAdmin role, and
 * deactivated policies become unavailable for runtime enforcement or visibility
 * in active system settings endpoints.
 *
 * Errors are provided if the record is missing, already deactivated, or if the
 * user lacks appropriate privileges. This operation is typically paired with
 * creation and update endpoints for full policy lifecycle management.
 *
 * @param props.connection
 * @param props.policyId Unique identifier (UUID) of the system policy to be
 *   soft deleted.
 * @path /storyfieldAi/systemAdmin/systemPolicies/:policyId
 * @accessor api.functional.storyfieldAi.systemAdmin.systemPolicies.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier (UUID) of the system policy to be soft deleted. */
    policyId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/storyfieldAi/systemAdmin/systemPolicies/:policyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/storyfieldAi/systemAdmin/systemPolicies/${encodeURIComponent(props.policyId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
