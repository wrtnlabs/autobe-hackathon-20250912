import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformAppointmentReminder } from "../../../../../structures/IHealthcarePlatformAppointmentReminder";
import { IPageIHealthcarePlatformAppointmentReminder } from "../../../../../structures/IPageIHealthcarePlatformAppointmentReminder";

/**
 * Schedule a new reminder for an appointment
 * (healthcare_platform_appointment_reminders).
 *
 * Register a new reminder to be sent prior to the specified appointment,
 * including details such as reminder time, recipient role/type, delivery
 * channel (e.g., SMS, email), and message content/subject.
 *
 * Business logic validates that the appointment exists and is not cancelled,
 * that the requested recipient and channel are allowed for this organization,
 * and that the scheduled time for the reminder is within acceptable business
 * windows (no reminders in the past, respects minimum scheduling lead time,
 * etc).
 *
 * Security: Only users with sufficient credentials (e.g., staff assigned to the
 * appointment or scheduling admin roles) may create reminders; the system
 * checks permissions, role bindings, and appointment status before allowing
 * creation. All creation attempts—success or failure—are logged for compliance
 * and audit tracking.
 *
 * Related APIs: This creation operation is part of the larger appointment
 * management workflow and should be used in conjunction with the GET and PUT
 * endpoints for reminders. The parent appointment serves as the workflow
 * boundary, and reminder records are not managed outside of their appointment’s
 * lifecycle.
 *
 * @param props.connection
 * @param props.appointmentId Unique identifier for the appointment associated
 *   with this reminder.
 * @param props.body Information required to create a new appointment reminder,
 *   including target delivery time, recipient, channel, and content.
 * @path /healthcarePlatform/departmentHead/appointments/:appointmentId/reminders
 * @accessor api.functional.healthcarePlatform.departmentHead.appointments.reminders.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier for the appointment associated with this reminder. */
    appointmentId: string & tags.Format<"uuid">;

    /**
     * Information required to create a new appointment reminder, including
     * target delivery time, recipient, channel, and content.
     */
    body: IHealthcarePlatformAppointmentReminder.ICreate;
  };
  export type Body = IHealthcarePlatformAppointmentReminder.ICreate;
  export type Response = IHealthcarePlatformAppointmentReminder;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/departmentHead/appointments/:appointmentId/reminders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/departmentHead/appointments/${encodeURIComponent(props.appointmentId ?? "null")}/reminders`;
  export const random = (): IHealthcarePlatformAppointmentReminder =>
    typia.random<IHealthcarePlatformAppointmentReminder>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appointmentId")(() => typia.assert(props.appointmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List reminder notifications for an appointment (paginated/filterable).
 *
 * Retrieves all reminders (notification events) associated with a specific
 * appointment ID. Returned results may be filtered/paginated and include all
 * sent/pending/failed reminders, complete with recipient information, delivery
 * status, and notification metadata. Used for staff to monitor and troubleshoot
 * notification workflows, verify SLA compliance, or support patient/provider
 * inquiries.
 *
 * Business logic ensures that only users with access rights to the appointment
 * (receptionist, provider, organization admin, etc.) can access the reminder
 * history. The returned records provide audit support and can be leveraged for
 * notification monitoring, patient service, or regulatory review. Errors
 * include access denied, invalid appointment, or no reminders found.
 *
 * @param props.connection
 * @param props.appointmentId Unique identifier of the target appointment whose
 *   reminders to list
 * @param props.body Search, filter, and pagination criteria for reminder
 *   retrieval (status, delivery channel, recipient, time window, paging).
 * @path /healthcarePlatform/departmentHead/appointments/:appointmentId/reminders
 * @accessor api.functional.healthcarePlatform.departmentHead.appointments.reminders.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the target appointment whose reminders to list */
    appointmentId: string & tags.Format<"uuid">;

    /**
     * Search, filter, and pagination criteria for reminder retrieval
     * (status, delivery channel, recipient, time window, paging).
     */
    body: IHealthcarePlatformAppointmentReminder.IRequest;
  };
  export type Body = IHealthcarePlatformAppointmentReminder.IRequest;
  export type Response = IPageIHealthcarePlatformAppointmentReminder;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/departmentHead/appointments/:appointmentId/reminders",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/departmentHead/appointments/${encodeURIComponent(props.appointmentId ?? "null")}/reminders`;
  export const random = (): IPageIHealthcarePlatformAppointmentReminder =>
    typia.random<IPageIHealthcarePlatformAppointmentReminder>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appointmentId")(() => typia.assert(props.appointmentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific appointment reminder by ID for review or audit
 * (healthcare_platform_appointment_reminders).
 *
 * Retrieve notification reminder information for a specific appointment
 * reminder identified by appointmentId and reminderId. This enables
 * organizational staff or the recipient (e.g. patient) to query the status and
 * content of reminders sent prior to an appointment—including delivery time,
 * channel, status (sent, failed, pending), and recipient details.
 *
 * Security is enforced to ensure only users associated with the organization,
 * appointment, or as the recipient can access the reminder details. Sensitive
 * fields like delivery channel, user, or content may be masked for unauthorized
 * access attempts or if restricted by organizational policy.
 *
 * Reminder entities in this table are subsidiary and not manipulated directly
 * outside of the parent appointment lifecycle, fitting strictly within business
 * and audit flows. All reads are logged for compliance tracking and SLA
 * monitoring.
 *
 * Error handling: If the reminderId or appointmentId are invalid, or if the
 * user lacks permission, the system will respond with an appropriate error
 * message and log the access attempt for audit. Soft-deleted reminders are not
 * visible in standard queries.
 *
 * @param props.connection
 * @param props.appointmentId Unique identifier for the appointment to which
 *   this reminder belongs.
 * @param props.reminderId Unique identifier of the reminder to retrieve.
 * @path /healthcarePlatform/departmentHead/appointments/:appointmentId/reminders/:reminderId
 * @accessor api.functional.healthcarePlatform.departmentHead.appointments.reminders.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the appointment to which this reminder belongs. */
    appointmentId: string & tags.Format<"uuid">;

    /** Unique identifier of the reminder to retrieve. */
    reminderId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformAppointmentReminder;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/departmentHead/appointments/:appointmentId/reminders/:reminderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/departmentHead/appointments/${encodeURIComponent(props.appointmentId ?? "null")}/reminders/${encodeURIComponent(props.reminderId ?? "null")}`;
  export const random = (): IHealthcarePlatformAppointmentReminder =>
    typia.random<IHealthcarePlatformAppointmentReminder>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appointmentId")(() => typia.assert(props.appointmentId));
      assert.param("reminderId")(() => typia.assert(props.reminderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing appointment reminder
 * (healthcare_platform_appointment_reminders).
 *
 * Modify scheduling or content for an existing reminder attached to an
 * appointment, identified by appointmentId and reminderId. Typical updates
 * include: rescheduling reminder delivery time, updating recipient
 * user/channel, or changing the notification message or escalation policy.
 *
 * Business and compliance logic ensures that only reminders in statuses
 * permitting modification (e.g., not yet delivered or expired) may be updated,
 * and that changes comply with organization calendar and SLA constraints.
 * Attempts to update reminders for appointments that are cancelled, in the
 * past, or soft-deleted will be rejected.
 *
 * Security: Only authorized staff (e.g., appointment scheduler, org admin) can
 * modify reminders. All successful and failed attempts are logged for audit.
 * Soft-deleted or already-delivered reminders cannot be edited.
 *
 * Error handling includes role and status checks (405 or 403 if not editable or
 * unauthorized) and clear validation errors for scheduling windows, recipient,
 * or channel issues.
 *
 * @param props.connection
 * @param props.appointmentId Unique identifier for the appointment to which
 *   this reminder belongs.
 * @param props.reminderId Unique identifier for the reminder to update.
 * @param props.body The update information for the appointment reminder (e.g.,
 *   new time, recipient, or content).
 * @path /healthcarePlatform/departmentHead/appointments/:appointmentId/reminders/:reminderId
 * @accessor api.functional.healthcarePlatform.departmentHead.appointments.reminders.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the appointment to which this reminder belongs. */
    appointmentId: string & tags.Format<"uuid">;

    /** Unique identifier for the reminder to update. */
    reminderId: string & tags.Format<"uuid">;

    /**
     * The update information for the appointment reminder (e.g., new time,
     * recipient, or content).
     */
    body: IHealthcarePlatformAppointmentReminder.IUpdate;
  };
  export type Body = IHealthcarePlatformAppointmentReminder.IUpdate;
  export type Response = IHealthcarePlatformAppointmentReminder;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/departmentHead/appointments/:appointmentId/reminders/:reminderId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/departmentHead/appointments/${encodeURIComponent(props.appointmentId ?? "null")}/reminders/${encodeURIComponent(props.reminderId ?? "null")}`;
  export const random = (): IHealthcarePlatformAppointmentReminder =>
    typia.random<IHealthcarePlatformAppointmentReminder>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appointmentId")(() => typia.assert(props.appointmentId));
      assert.param("reminderId")(() => typia.assert(props.reminderId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete an appointment reminder
 * (healthcare_platform_appointment_reminders).
 *
 * Remove (soft-delete) an appointment reminder, identified by appointmentId and
 * reminderId. The operation marks the record as deleted by setting the
 * deleted_at field but does not physically erase reminder data, preserving all
 * audit and compliance information in accordance with healthcare regulatory
 * requirements.
 *
 * Security: Only users with explicit assignment (e.g., admin, scheduler) may
 * delete a reminder, and cannot delete reminders already delivered or archived
 * unless performing an escalated, reviewed action. The system logs all delete
 * events (both successful and failed attempts), including user, reason, and
 * timestamp for regulatory review.
 *
 * Related operations: This endpoint is closely tied to appointment management
 * and notification systems; hard deletes are not permitted via this interface.
 * Restore or audit review of deleted notifications requires a separate process,
 * managed by compliance or IT admins.
 *
 * @param props.connection
 * @param props.appointmentId Unique identifier for the appointment from which
 *   to delete the reminder.
 * @param props.reminderId Unique identifier for the reminder to delete.
 * @path /healthcarePlatform/departmentHead/appointments/:appointmentId/reminders/:reminderId
 * @accessor api.functional.healthcarePlatform.departmentHead.appointments.reminders.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier for the appointment from which to delete the
     * reminder.
     */
    appointmentId: string & tags.Format<"uuid">;

    /** Unique identifier for the reminder to delete. */
    reminderId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/departmentHead/appointments/:appointmentId/reminders/:reminderId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/departmentHead/appointments/${encodeURIComponent(props.appointmentId ?? "null")}/reminders/${encodeURIComponent(props.reminderId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("appointmentId")(() => typia.assert(props.appointmentId));
      assert.param("reminderId")(() => typia.assert(props.reminderId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
