import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformBillingDiscountPolicy } from "../../../../structures/IHealthcarePlatformBillingDiscountPolicy";
import { IPageIHealthcarePlatformBillingDiscountPolicy } from "../../../../structures/IPageIHealthcarePlatformBillingDiscountPolicy";

/**
 * Create a new billing discount policy in
 * healthcare_platform_billing_discount_policies.
 *
 * This operation allows organizationAdmins to add a new billing discount policy
 * to their organization's configuration via the
 * healthcare_platform_billing_discount_policies table. The policy defines
 * available/approved discount logic, display names, and description for
 * financial workflows.
 *
 * POST body requires all fields necessary per the
 * IHealthcarePlatformBillingDiscountPolicy.ICreate schema, including
 * policy_name, discount_type, description (optional), and is_active flag.
 * Created policies are subject to compliance review and business rules about
 * uniqueness and policy rationale. Only admins with financial permissions can
 * execute this operation according to the Prisma model's description and RBAC
 * boundary.
 *
 * Failure modes include attempts to duplicate a policy_name within the same
 * organization, inadequate permissions, or invalid data. On success, the new
 * policy record is returned for reference and further management.
 *
 * @param props.connection
 * @param props.body New billing discount policy data as defined by the ICreate
 *   DTO.
 * @path /healthcarePlatform/organizationAdmin/billingDiscountPolicies
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingDiscountPolicies.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** New billing discount policy data as defined by the ICreate DTO. */
    body: IHealthcarePlatformBillingDiscountPolicy.ICreate;
  };
  export type Body = IHealthcarePlatformBillingDiscountPolicy.ICreate;
  export type Response = IHealthcarePlatformBillingDiscountPolicy;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/billingDiscountPolicies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/billingDiscountPolicies";
  export const random = (): IHealthcarePlatformBillingDiscountPolicy =>
    typia.random<IHealthcarePlatformBillingDiscountPolicy>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Paginated search for billing discount policies
 * (healthcare_platform_billing_discount_policies).
 *
 * This API enables organization admins to search, filter, and paginate through
 * all billing discount policy records within their organization. The
 * healthcare_platform_billing_discount_policies table defines all allowed
 * discounting schemes (e.g., charity, sliding scale, policy-driven discounts)
 * and their business activation status. Clients may use criteria such as policy
 * name, type, organization, or status to narrow the result set.
 *
 * Full response includes all policy metadata, descriptions, activation status,
 * and timestamps, supporting administrative review, policy compliance checks,
 * and downstream integration with other billing flows (such as invoice
 * adjustments or plan setup). The operation is strictly for
 * organizationAdmin-level access, with robust input validation for query
 * filters on policy_name, status, and activation. Paginated results ensure
 * efficient management of large policy catalogs in major organizations.
 *
 * Errors are clearly returned for permission failures, malformed queries, or
 * pagination parameter issues. The endpoint integrates with other billing
 * administration APIs for comprehensive financial policy management workflows.
 *
 * @param props.connection
 * @param props.body Filter, sort, and pagination parameters for discount policy
 *   search, using IHealthcarePlatformBillingDiscountPolicy.IRequest structure.
 * @path /healthcarePlatform/organizationAdmin/billingDiscountPolicies
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingDiscountPolicies.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter, sort, and pagination parameters for discount policy search,
     * using IHealthcarePlatformBillingDiscountPolicy.IRequest structure.
     */
    body: IHealthcarePlatformBillingDiscountPolicy.IRequest;
  };
  export type Body = IHealthcarePlatformBillingDiscountPolicy.IRequest;
  export type Response = IPageIHealthcarePlatformBillingDiscountPolicy.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/billingDiscountPolicies",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/billingDiscountPolicies";
  export const random =
    (): IPageIHealthcarePlatformBillingDiscountPolicy.ISummary =>
      typia.random<IPageIHealthcarePlatformBillingDiscountPolicy.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific billing discount policy by ID from
 * healthcare_platform_billing_discount_policies.
 *
 * Fetches the full record for a billing discount policy as defined in the
 * healthcare_platform_billing_discount_policies table. This operation is
 * essential for admins and billing staff who need to review the details and
 * current status of a particular discount policyâ€”such as charity care,
 * hardship, or staff discounts.
 *
 * The API requires the billingDiscountPolicyId as a UUID path parameter.
 * Security and organizational RBAC boundaries are enforced; only
 * organizationAdmins (and above) may fetch policies for their own organization.
 * Sensitive configuration and is_active flags are included for compliance/audit
 * review.
 *
 * Returns all non-deleted fields, including business logic description, policy
 * type, discount method (percentage/fixed), and timestamps for creation and
 * last update. Errors are provided if the ID is not found or if access is
 * denied by the RBAC model.
 *
 * @param props.connection
 * @param props.billingDiscountPolicyId Unique identifier for the billing
 *   discount policy record to retrieve.
 * @path /healthcarePlatform/organizationAdmin/billingDiscountPolicies/:billingDiscountPolicyId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingDiscountPolicies.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the billing discount policy record to retrieve. */
    billingDiscountPolicyId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformBillingDiscountPolicy;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/billingDiscountPolicies/:billingDiscountPolicyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/billingDiscountPolicies/${encodeURIComponent(props.billingDiscountPolicyId ?? "null")}`;
  export const random = (): IHealthcarePlatformBillingDiscountPolicy =>
    typia.random<IHealthcarePlatformBillingDiscountPolicy>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingDiscountPolicyId")(() =>
        typia.assert(props.billingDiscountPolicyId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing billing discount policy by ID in
 * healthcare_platform_billing_discount_policies.
 *
 * This operation allows organization-level administrators to modify an existing
 * billing discount policy, such as updating whether it is active, changing
 * description or names, or altering business logic for allowed financial
 * discounts.
 *
 * The target policy is specified by billingDiscountPolicyId (UUID path
 * parameter). The PUT body uses the
 * IHealthcarePlatformBillingDiscountPolicy.IUpdate DTO, which supports patching
 * policy_name, discount_type, description, or is_active flags. Full audit
 * trails and compliance checks are enforced to track changes.
 *
 * Validation ensures policy integrity, uniqueness (no duplicate names within
 * the same organization), and prevents modification if the record is
 * soft-deleted. Only authorized organizationAdmins may perform updates. Returns
 * the updated policy record on success, or errors for permission/validation
 * failures.
 *
 * @param props.connection
 * @param props.billingDiscountPolicyId Unique identifier of the billing
 *   discount policy to update.
 * @param props.body The updated billing discount policy fields. All updatable
 *   fields per IUpdate DTO.
 * @path /healthcarePlatform/organizationAdmin/billingDiscountPolicies/:billingDiscountPolicyId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingDiscountPolicies.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the billing discount policy to update. */
    billingDiscountPolicyId: string & tags.Format<"uuid">;

    /**
     * The updated billing discount policy fields. All updatable fields per
     * IUpdate DTO.
     */
    body: IHealthcarePlatformBillingDiscountPolicy.IUpdate;
  };
  export type Body = IHealthcarePlatformBillingDiscountPolicy.IUpdate;
  export type Response = IHealthcarePlatformBillingDiscountPolicy;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/billingDiscountPolicies/:billingDiscountPolicyId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/billingDiscountPolicies/${encodeURIComponent(props.billingDiscountPolicyId ?? "null")}`;
  export const random = (): IHealthcarePlatformBillingDiscountPolicy =>
    typia.random<IHealthcarePlatformBillingDiscountPolicy>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingDiscountPolicyId")(() =>
        typia.assert(props.billingDiscountPolicyId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a billing discount policy by ID from
 * healthcare_platform_billing_discount_policies.
 *
 * This operation allows organization-level administrators to perform a
 * soft-delete on a billing discount policy using its billingDiscountPolicyId
 * (UUID). It marks the policy as deleted for audit and compliance without
 * physical removal from the database, maintaining retention and honoring
 * legal/investigation requirements.
 *
 * The operation enforces RBAC so that only authorized admins may archive
 * policies belonging to their organization. Soft-delete is performed by setting
 * deleted_at. All references, such as invoices and adjustments, will respect
 * this policy's is_active and deleted_at status. Deletion is blocked if the
 * policy is referenced by active financial operations. Returns a confirmation
 * on success or appropriate validation error on dependency or permission
 * failure.
 *
 * @param props.connection
 * @param props.billingDiscountPolicyId Unique identifier of the billing
 *   discount policy to soft-delete.
 * @path /healthcarePlatform/organizationAdmin/billingDiscountPolicies/:billingDiscountPolicyId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingDiscountPolicies.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the billing discount policy to soft-delete. */
    billingDiscountPolicyId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/organizationAdmin/billingDiscountPolicies/:billingDiscountPolicyId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/billingDiscountPolicies/${encodeURIComponent(props.billingDiscountPolicyId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingDiscountPolicyId")(() =>
        typia.assert(props.billingDiscountPolicyId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
