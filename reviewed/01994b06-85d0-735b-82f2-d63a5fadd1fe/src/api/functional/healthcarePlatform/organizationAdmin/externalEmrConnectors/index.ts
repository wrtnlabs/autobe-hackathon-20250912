import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformExternalEmrConnector } from "../../../../structures/IHealthcarePlatformExternalEmrConnector";
import { IPageIHealthcarePlatformExternalEmrConnector } from "../../../../structures/IPageIHealthcarePlatformExternalEmrConnector";

/**
 * Create a new external EMR connector record for interoperability (table:
 * healthcare_platform_external_emr_connectors).
 *
 * Register a new external EMR connector configuration in the system, specifying
 * all required fields for integration with an EMR/EHR vendor. The request body
 * must include organization mapping, connector type/vendor, connection
 * endpoint, and initial status. Upon creation, the configuration is stored in
 * healthcare_platform_external_emr_connectors and made available for
 * monitoring, health checks, system dashboards, and integration workflows.
 *
 * Input validation is strict: the combination of organization and connector
 * type must be unique, required fields (URI, status, etc.) must be present and
 * valid, and compliance policies such as secure credential handling are
 * enforced. Only system and organization admins may create new connectors.
 * Error handling covers uniqueness violations, validation errors, and
 * compliance policy enforcement.
 *
 * The operation is typically paired with configuration management UX for
 * onboarding external EMR/EHR systems and supports readiness for operational
 * dashboards and compliance audits.
 *
 * @param props.connection
 * @param props.body Detailed data for creating a new external EMR connector
 *   record.
 * @path /healthcarePlatform/organizationAdmin/externalEmrConnectors
 * @accessor api.functional.healthcarePlatform.organizationAdmin.externalEmrConnectors.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Detailed data for creating a new external EMR connector record. */
    body: IHealthcarePlatformExternalEmrConnector.ICreate;
  };
  export type Body = IHealthcarePlatformExternalEmrConnector.ICreate;
  export type Response = IHealthcarePlatformExternalEmrConnector;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/externalEmrConnectors",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/externalEmrConnectors";
  export const random = (): IHealthcarePlatformExternalEmrConnector =>
    typia.random<IHealthcarePlatformExternalEmrConnector>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of external EMR connector
 * configurations (table: healthcare_platform_external_emr_connectors).
 *
 * Retrieve a paginated and filtered list of external EMR connector
 * configurations from the healthcare_platform_external_emr_connectors table,
 * supporting filtering by organization, vendor type, operational status, or
 * last sync time. This list is essential for administrators managing the
 * interoperability landscape of the healthcare platform—allowing proactive
 * readiness review, troubleshooting, and cross-organization audit.
 *
 * Query parameters and request body allow for complex search, sorting, and
 * paging. Security ensures only users with platform or organization admin roles
 * can enumerate connectors. Access logging and compliance requirements are
 * enforced, with sensitive integration credentials never returned via API.
 *
 * Typical use cases include configuration audits, visualization in integration
 * dashboards, or pre-checks for onboarding new organizations. The endpoint
 * interacts closely with monitoring and system health logic, ensuring that
 * platform reliability is maintained across integrations with EMR vendors.
 *
 * @param props.connection
 * @param props.body Query and pagination parameters for searching external EMR
 *   connectors.
 * @path /healthcarePlatform/organizationAdmin/externalEmrConnectors
 * @accessor api.functional.healthcarePlatform.organizationAdmin.externalEmrConnectors.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Query and pagination parameters for searching external EMR
     * connectors.
     */
    body: IHealthcarePlatformExternalEmrConnector.IRequest;
  };
  export type Body = IHealthcarePlatformExternalEmrConnector.IRequest;
  export type Response = IPageIHealthcarePlatformExternalEmrConnector.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/externalEmrConnectors",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/externalEmrConnectors";
  export const random =
    (): IPageIHealthcarePlatformExternalEmrConnector.ISummary =>
      typia.random<IPageIHealthcarePlatformExternalEmrConnector.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch the complete configuration details for a specific external EMR
 * connector by ID (table: healthcare_platform_external_emr_connectors).
 *
 * Fetch detailed configuration and status information for a single external EMR
 * connector record, using its connector ID as the lookup key from
 * healthcare_platform_external_emr_connectors. The returned information
 * includes vendor type, connection endpoints, status, last synchronization
 * date, and related metadata relevant for administration, auditing, and
 * troubleshooting.
 *
 * Security and access are tightly controlled—the endpoint is available only to
 * system and organization administrators, ensuring role-based visibility
 * boundaries in accordance with multi-tenant platform standards. Sensitive
 * fields, such as credentials or internal tokens, are either excluded or masked
 * from API output by implementation policy.
 *
 * The operation supports operational monitoring, compliance readiness, and
 * integration lifecycle management for connected EMR/EHR vendors. All access
 * events are logged for security and compliance review.
 *
 * @param props.connection
 * @param props.externalEmrConnectorId Unique identifier (UUID) of the external
 *   EMR connector to retrieve.
 * @path /healthcarePlatform/organizationAdmin/externalEmrConnectors/:externalEmrConnectorId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.externalEmrConnectors.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the external EMR connector to retrieve. */
    externalEmrConnectorId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformExternalEmrConnector;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/externalEmrConnectors/:externalEmrConnectorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/externalEmrConnectors/${encodeURIComponent(props.externalEmrConnectorId ?? "null")}`;
  export const random = (): IHealthcarePlatformExternalEmrConnector =>
    typia.random<IHealthcarePlatformExternalEmrConnector>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("externalEmrConnectorId")(() =>
        typia.assert(props.externalEmrConnectorId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an external EMR connector configuration
 * (healthcare_platform_external_emr_connectors).
 *
 * Updates the configuration or metadata of an existing external EMR (Electronic
 * Medical Record) connector, corresponding to a specific connector record in
 * the healthcare_platform_external_emr_connectors table. This operation allows
 * administrative users to change properties such as connector type, connection
 * URI, operational status, last sync time, or custom parameters for integration
 * with third-party EMR/EHR systems.
 *
 * Strict platform and organizational checks apply for this endpoint, which is
 * limited to users with administrative roles due to the potential impact on
 * global health data flows and compliance boundaries.
 *
 * All changes are subject to audit trail requirements, and validation logic
 * must ensure that status transitions, connector types, and endpoints conform
 * to allowed values. The operation should fail gracefully with proper messages
 * if the connector ID is missing, invalid, soft-deleted, or if the update would
 * cause loss of audit data or breach interoperability constraints.
 *
 * Related operations may include creation and deletion of EMR connectors,
 * querying available connectors, and system-wide health checks on connector
 * status.
 *
 * @param props.connection
 * @param props.externalEmrConnectorId Unique identifier of the external EMR
 *   connector to update.
 * @param props.body Update information for an external EMR connector, such as
 *   connection_uri, status, or connector_type.
 * @path /healthcarePlatform/organizationAdmin/externalEmrConnectors/:externalEmrConnectorId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.externalEmrConnectors.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the external EMR connector to update. */
    externalEmrConnectorId: string & tags.Format<"uuid">;

    /**
     * Update information for an external EMR connector, such as
     * connection_uri, status, or connector_type.
     */
    body: IHealthcarePlatformExternalEmrConnector.IUpdate;
  };
  export type Body = IHealthcarePlatformExternalEmrConnector.IUpdate;
  export type Response = IHealthcarePlatformExternalEmrConnector;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/externalEmrConnectors/:externalEmrConnectorId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/externalEmrConnectors/${encodeURIComponent(props.externalEmrConnectorId ?? "null")}`;
  export const random = (): IHealthcarePlatformExternalEmrConnector =>
    typia.random<IHealthcarePlatformExternalEmrConnector>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("externalEmrConnectorId")(() =>
        typia.assert(props.externalEmrConnectorId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete (hard remove) an external EMR connector
 * (healthcare_platform_external_emr_connectors).
 *
 * Permanently removes an external EMR connector configuration record from the
 * database by its unique identifier. The operation is mapped to the
 * healthcare_platform_external_emr_connectors table and is intended for use
 * only by highly privileged systemAdmin or organizationAdmin roles.
 *
 * All deletions must be recorded in the audit log, and the system must confirm
 * that the specified connector exists and is not already deleted. The removal
 * should fail with a meaningful error if the ID does not exist or the connector
 * is linked to active processes. There are no soft delete semantics for this
 * operation, and the record will be eliminated from persistent storage.
 *
 * This endpoint is complementary to operations for connector creation and
 * update and should only be used in scenarios of connector decommission or
 * critical incident remediation.
 *
 * @param props.connection
 * @param props.externalEmrConnectorId Unique identifier of the external EMR
 *   connector to delete.
 * @path /healthcarePlatform/organizationAdmin/externalEmrConnectors/:externalEmrConnectorId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.externalEmrConnectors.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the external EMR connector to delete. */
    externalEmrConnectorId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/organizationAdmin/externalEmrConnectors/:externalEmrConnectorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/externalEmrConnectors/${encodeURIComponent(props.externalEmrConnectorId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("externalEmrConnectorId")(() =>
        typia.assert(props.externalEmrConnectorId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
