import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformConfiguration } from "../../../../structures/IHealthcarePlatformConfiguration";
import { IPageIHealthcarePlatformConfiguration } from "../../../../structures/IPageIHealthcarePlatformConfiguration";

/**
 * Create a new configuration record in the healthcare_platform_configuration
 * table.
 *
 * Create a new configuration setting in the healthcarePlatform. The
 * configuration may be specific to an organization (if organization_id is
 * provided), or global for all tenants (if omitted/null). Administrators define
 * the configuration key, its value, and provide a human-readable description of
 * its impact or business purpose. This API restricts creation to operational
 * and technical settings—storing clinical or PHI data here is not supported and
 * may result in validation errors.
 *
 * Appropriate permissions are required to invoke this API, typically platform
 * administrators or organization administrators with configuration privileges.
 * The configuration key must be unique per organization; attempts to duplicate
 * will result in an error. The newly created configuration can be updated or
 * soft-deleted later through related endpoints.
 *
 * On success, the new configuration record is returned, including its
 * system-generated UUID, creation and update timestamps, and all supplied
 * fields. Timestamps assist in tracking configuration changes for audit and
 * rollback. This endpoint is integral for supporting tenant-level customizing,
 * feature flags, business logic toggles, and compliance-related technical
 * parameters.
 *
 * @param props.connection
 * @param props.body Details of the configuration to be created, including
 *   optional organization, key, value, and description.
 * @path /healthcarePlatform/organizationAdmin/configuration
 * @accessor api.functional.healthcarePlatform.organizationAdmin.configuration.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Details of the configuration to be created, including optional
     * organization, key, value, and description.
     */
    body: IHealthcarePlatformConfiguration.ICreate;
  };
  export type Body = IHealthcarePlatformConfiguration.ICreate;
  export type Response = IHealthcarePlatformConfiguration;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/configuration",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/configuration";
  export const random = (): IHealthcarePlatformConfiguration =>
    typia.random<IHealthcarePlatformConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search, filter, and paginate configuration records
 * (healthcare_platform_configuration).
 *
 * Enables platform/system administrators and authorized organization
 * administrators to retrieve a filtered, paginated list of configuration
 * records for the entire platform or by tenant. Supports advanced searching on
 * configuration keys, values, and organizational scoping.
 *
 * This endpoint powers configuration UI screens, platform policy review, and
 * operational troubleshooting. Search criteria may include key patterns,
 * partial matches, and date filtering based on changed/created/updated
 * timestamps. Authorization and filtering respect tenant boundaries, and only
 * system-wide global configs or the caller's organization are shown per user
 * privileges.
 *
 * The returned records are suitable for admin console views and configuration
 * audit workflows. Related endpoints include individual configuration
 * get/update by id. All access events are audit-logged for compliance. Improper
 * or unauthorized queries result in explicit errors and no data leakage across
 * tenant boundaries.
 *
 * @param props.connection
 * @param props.body Search and filter options for configuration retrieval.
 * @path /healthcarePlatform/organizationAdmin/configuration
 * @accessor api.functional.healthcarePlatform.organizationAdmin.configuration.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search and filter options for configuration retrieval. */
    body: IHealthcarePlatformConfiguration.IRequest;
  };
  export type Body = IHealthcarePlatformConfiguration.IRequest;
  export type Response = IPageIHealthcarePlatformConfiguration;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/configuration",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/organizationAdmin/configuration";
  export const random = (): IPageIHealthcarePlatformConfiguration =>
    typia.random<IPageIHealthcarePlatformConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a single configuration record by id
 * (healthcare_platform_configuration).
 *
 * Allows a platform/system admin or an authorized org admin to retrieve a
 * specific configuration setting by its unique ID. This supports admin UI
 * detail screens, platform/business logic injection, and real-time verification
 * of organization or global settings.
 *
 * Retrieved records are filtered by organizational scope and permission; system
 * admins may access global and tenant-owned configs, while org admins only see
 * their own org's configs. Related endpoints include list/index/search and
 * configuration update endpoints. Attempts to access non-existent or
 * unauthorized configuration IDs result in explicit compliance error responses.
 * All access attempts are audit-logged for regulatory review and security
 * investigation.
 *
 * @param props.connection
 * @param props.configurationId Unique identifier for the configuration record
 *   to retrieve.
 * @path /healthcarePlatform/organizationAdmin/configuration/:configurationId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.configuration.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier for the configuration record to retrieve. */
    configurationId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformConfiguration;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/configuration/:configurationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/configuration/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): IHealthcarePlatformConfiguration =>
    typia.random<IHealthcarePlatformConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a configuration record by UUID in the
 * healthcare_platform_configuration table.
 *
 * Update an existing configuration setting identified by its UUID. Only
 * organization or system administrators are permitted to invoke this API, and
 * upon execution, the system ensures that the configuration key and target
 * organization uniqueness constraints are enforced. The operation allows
 * updating fields such as key, value, or description, but prohibits clinical or
 * PHI values.
 *
 * The update operation will only affect active (non-soft-deleted) records.
 * Attempts to modify keys/values resulting in logic conflicts (such as
 * duplicate key/org pairs) will trigger error responses. All updates are
 * timestamped for audit purposes. This API is primarily used for technical,
 * operational, and business logic settings that may require periodic
 * modification due to policy or feature changes.
 *
 * The modified configuration record is returned—including its updated fields
 * and audit timestamps—enabling downstream systems to react to updated
 * configurations as needed.
 *
 * @param props.connection
 * @param props.configurationId UUID of the configuration setting to update.
 * @param props.body New values for key, value, or description of the
 *   configuration setting.
 * @path /healthcarePlatform/organizationAdmin/configuration/:configurationId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.configuration.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the configuration setting to update. */
    configurationId: string & tags.Format<"uuid">;

    /**
     * New values for key, value, or description of the configuration
     * setting.
     */
    body: IHealthcarePlatformConfiguration.IUpdate;
  };
  export type Body = IHealthcarePlatformConfiguration.IUpdate;
  export type Response = IHealthcarePlatformConfiguration;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/configuration/:configurationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/configuration/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): IHealthcarePlatformConfiguration =>
    typia.random<IHealthcarePlatformConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a configuration record by UUID, using the deleted_at field for
 * compliance.
 *
 * Soft-delete a configuration setting by marking its deleted_at field (logical
 * deletion), ensuring the entry is excluded from active configuration queries
 * but retained in the database for audit/compliance. This operation is limited
 * to active configuration records and cannot be applied to already-deleted
 * records. The delete action is restricted to users with appropriate privileges
 * and will be fully audited, including deletion timestamp and the deleting
 * user's identity.
 *
 * Soft-deleted configurations do not participate in business or operational
 * logic but remain available for audit and possible restoration as per
 * compliance and business policy. Permanent deletion from the table is not
 * supported from the API to ensure regulatory compliance for audit, rollback,
 * or post-mortem purposes.
 *
 * @param props.connection
 * @param props.configurationId UUID of the configuration setting to be
 *   soft-deleted.
 * @path /healthcarePlatform/organizationAdmin/configuration/:configurationId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.configuration.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the configuration setting to be soft-deleted. */
    configurationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/organizationAdmin/configuration/:configurationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/configuration/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
