import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformBillingItem } from "../../../../../structures/IHealthcarePlatformBillingItem";
import { IPageIHealthcarePlatformBillingItem } from "../../../../../structures/IPageIHealthcarePlatformBillingItem";

/**
 * Create a billing item for an invoice (IHealthcarePlatformBillingItem).
 *
 * This operation enables authorized billing or administrative users to create a
 * new billing item under a given invoice, as stored in the
 * healthcare_platform_billing_items table. Required details generally include
 * the billing code, quantity, item description, price, and calculation logic as
 * defined in schema columns.
 *
 * Business validation ensures that item creation is allowed only when the
 * parent invoice is active and appropriate organization and billing permissions
 * are in effect. Item creation must be fully auditable, with pre- and
 * post-validation states recorded for compliance review.
 *
 * Only authorized roles (billing staff, administrators, department heads) may
 * perform this operation. This action is typically part of broader invoice
 * creation, amendment, or post-encounter correction workflows. Related
 * endpoints are the list (PATCH), detail (GET), and update (PUT) operations.
 *
 * @param props.connection
 * @param props.billingInvoiceId Unique identifier of the billing invoice to
 *   which the new item will be added.
 * @param props.body Data for new billing item to be created under the specified
 *   invoice.
 * @path /healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingItems
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingInvoices.billingItems.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the billing invoice to which the new item will
     * be added.
     */
    billingInvoiceId: string & tags.Format<"uuid">;

    /** Data for new billing item to be created under the specified invoice. */
    body: IHealthcarePlatformBillingItem.ICreate;
  };
  export type Body = IHealthcarePlatformBillingItem.ICreate;
  export type Response = IHealthcarePlatformBillingItem;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/billingInvoices/${encodeURIComponent(props.billingInvoiceId ?? "null")}/billingItems`;
  export const random = (): IHealthcarePlatformBillingItem =>
    typia.random<IHealthcarePlatformBillingItem>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingInvoiceId")(() =>
        typia.assert(props.billingInvoiceId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve and search billing items for a specific invoice
 * (IHealthcarePlatformBillingItem).
 *
 * Retrieves a filtered, paginated list of billing items tied to a given billing
 * invoice, as defined in the healthcare_platform_billing_items table. Filtering
 * options enable staff to locate billing items by service code, amount, date,
 * item status, and other searchable fields. Paging and result ordering are
 * required for workflows handling large, complex invoices.
 *
 * Access to this operation should be controlled so only administrators, billing
 * staff, or auditors of the organization associated with the invoice can use
 * it. Audit logs must be maintained for all access events. Related endpoints
 * include detail retrieval (GET
 * /billingInvoices/{billingInvoiceId}/billingItems/{billingItemId}), creation
 * (POST), and update (PUT).
 *
 * All filtering and sorting logic leverages column definitions and index
 * strategies from the billing items schema, providing response formats suitable
 * for UI tabular display and export.
 *
 * @param props.connection
 * @param props.billingInvoiceId Unique identifier for the billing invoice whose
 *   items are to be retrieved.
 * @param props.body Search and pagination options for billing items within a
 *   given invoice.
 * @path /healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingItems
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingInvoices.billingItems.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier for the billing invoice whose items are to be
     * retrieved.
     */
    billingInvoiceId: string & tags.Format<"uuid">;

    /**
     * Search and pagination options for billing items within a given
     * invoice.
     */
    body: IHealthcarePlatformBillingItem.IRequest;
  };
  export type Body = IHealthcarePlatformBillingItem.IRequest;
  export type Response = IPageIHealthcarePlatformBillingItem;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingItems",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/billingInvoices/${encodeURIComponent(props.billingInvoiceId ?? "null")}/billingItems`;
  export const random = (): IPageIHealthcarePlatformBillingItem =>
    typia.random<IPageIHealthcarePlatformBillingItem>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingInvoiceId")(() =>
        typia.assert(props.billingInvoiceId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information for a specific billing item
 * (IHealthcarePlatformBillingItem).
 *
 * This operation fetches all the detailed attributes of a single billing item
 * as defined in the healthcare_platform_billing_items table, for the given
 * invoice. It is intended for use by billing administrators, organization
 * admins, finance, or compliance staff who need to review the complete
 * structure of the item—including service code, description, quantity, pricing,
 * and adjustment links.
 *
 * Authorization is restricted to organization administrators, designated
 * department heads, and other roles with invoice/billing access. Audit logging
 * is performed for all access.
 *
 * This endpoint supports workflows for invoice review, dispute resolution, and
 * compliance audit. Related operations include list retrieval (PATCH), creation
 * (POST), and update (PUT).
 *
 * @param props.connection
 * @param props.billingInvoiceId Unique identifier of the parent billing
 *   invoice.
 * @param props.billingItemId Unique identifier of the billing item to retrieve.
 * @path /healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingItems/:billingItemId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingInvoices.billingItems.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the parent billing invoice. */
    billingInvoiceId: string & tags.Format<"uuid">;

    /** Unique identifier of the billing item to retrieve. */
    billingItemId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformBillingItem;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingItems/:billingItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/billingInvoices/${encodeURIComponent(props.billingInvoiceId ?? "null")}/billingItems/${encodeURIComponent(props.billingItemId ?? "null")}`;
  export const random = (): IHealthcarePlatformBillingItem =>
    typia.random<IHealthcarePlatformBillingItem>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingInvoiceId")(() =>
        typia.assert(props.billingInvoiceId),
      );
      assert.param("billingItemId")(() => typia.assert(props.billingItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing billing item linked to an invoice
 * (IHealthcarePlatformBillingItem).
 *
 * Applies updates to a billing item, referenced by its ID and parent invoice,
 * in the healthcare_platform_billing_items table. Permitted fields for update
 * include description, quantity, item code, pricing, and adjustment
 * details—subject to business logic and compliance review. Edits are logged for
 * full auditability, with before/after comparison and justification (if
 * required).
 *
 * Only billing staff, department heads, or organization administrators with the
 * correct permissions may use this operation. The endpoint supports workflows
 * for error correction, regulatory compliance, post-payment reconciliation, and
 * dispute resolution. Related endpoints include detail retrieval (GET),
 * bulk/list (PATCH), and creation (POST) operations.
 *
 * @param props.connection
 * @param props.billingInvoiceId Unique identifier of the parent billing
 *   invoice.
 * @param props.billingItemId Unique identifier of the billing item to update.
 * @param props.body Fields for the billing item update, such as new quantity,
 *   code, description, or pricing.
 * @path /healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingItems/:billingItemId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingInvoices.billingItems.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the parent billing invoice. */
    billingInvoiceId: string & tags.Format<"uuid">;

    /** Unique identifier of the billing item to update. */
    billingItemId: string & tags.Format<"uuid">;

    /**
     * Fields for the billing item update, such as new quantity, code,
     * description, or pricing.
     */
    body: IHealthcarePlatformBillingItem.IUpdate;
  };
  export type Body = IHealthcarePlatformBillingItem.IUpdate;
  export type Response = IHealthcarePlatformBillingItem;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingItems/:billingItemId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/billingInvoices/${encodeURIComponent(props.billingInvoiceId ?? "null")}/billingItems/${encodeURIComponent(props.billingItemId ?? "null")}`;
  export const random = (): IHealthcarePlatformBillingItem =>
    typia.random<IHealthcarePlatformBillingItem>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingInvoiceId")(() =>
        typia.assert(props.billingInvoiceId),
      );
      assert.param("billingItemId")(() => typia.assert(props.billingItemId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a billing item from a specific billing invoice
 * (healthcare_platform_billing_items table).
 *
 * This API operation deletes a single billing item from the invoice in the
 * healthcare_platform_billing_items table. It is used by billing administrators
 * or organization finance staff to remove billing lines that were added in
 * error, are disputed, or need correction due to compliance or audit
 * requirements.
 *
 * Security is enforced to ensure only users with sufficient privileges (e.g.,
 * organizationAdmin or higher) can perform this action, and successful deletion
 * is logged for audit trails in accordance with organizational and legal
 * policy. If the schema defines a soft delete field (deleted_at), the deletion
 * is logical; otherwise, the item is removed permanently. Deletions may impact
 * invoice totals, insurance claims, and downstream financial analytics, so
 * system logic MUST ensure affected invoice and claim records are accurately
 * recalculated or marked pending review after item removal.
 *
 * Expected errors include attempting to delete an item not linked to the
 * specified invoice, deleting an item from a finalized or locked invoice, or
 * permission violations. No data is returned on successful deletion, but
 * compliance logs should track the event.
 *
 * This resource is only available to users with appropriate billing/finance
 * roles. Related operations: creating or updating billing items, viewing
 * invoice details, and adjusting invoice totals or payment plans.
 *
 * @param props.connection
 * @param props.billingInvoiceId Unique identifier for the target billing
 *   invoice (UUID format)
 * @param props.billingItemId Unique identifier for the billing item to delete
 *   (UUID format)
 * @path /healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingItems/:billingItemId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingInvoices.billingItems.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the target billing invoice (UUID format) */
    billingInvoiceId: string & tags.Format<"uuid">;

    /** Unique identifier for the billing item to delete (UUID format) */
    billingItemId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingItems/:billingItemId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/billingInvoices/${encodeURIComponent(props.billingInvoiceId ?? "null")}/billingItems/${encodeURIComponent(props.billingItemId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingInvoiceId")(() =>
        typia.assert(props.billingInvoiceId),
      );
      assert.param("billingItemId")(() => typia.assert(props.billingItemId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
