import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformBillingPayment } from "../../../../../structures/IHealthcarePlatformBillingPayment";
import { IPageIHealthcarePlatformBillingPayment } from "../../../../../structures/IPageIHealthcarePlatformBillingPayment";

/**
 * Create a new billing payment for a billing invoice
 * (healthcare_platform_billing_payments).
 *
 * Adds a new payment record for the specified billing invoice. This API is used
 * when payments (by patient, insurer, or other payer) are received and need to
 * be formally recorded against an invoice. Required information includes
 * payment amount, currency, status, method, and date, with all entries
 * validated for accuracy and compliance.
 *
 * On creation, the payment is fully linked to the invoice and subject to all
 * data retention, audit, and reconciliation logic enforced by the platform.
 * Financial audit logs are automatically generated, and all creation attempts
 * are validated for duplicate, overpayment, or misattributed payments.
 *
 * Typically restricted to finance staff (organizationAdmin) with all actions
 * logged for compliance. The API enforces business rules such as not exceeding
 * invoice totals and ensuring the invoice is in a payable state.
 *
 * @param props.connection
 * @param props.billingInvoiceId Unique identifier of the billing invoice to
 *   which the new payment will be attached
 * @param props.body Details required to create a billing payment including
 *   payee, payment method, amount, date, and status
 * @path /healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingPayments
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingInvoices.billingPayments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the billing invoice to which the new payment
     * will be attached
     */
    billingInvoiceId: string & tags.Format<"uuid">;

    /**
     * Details required to create a billing payment including payee, payment
     * method, amount, date, and status
     */
    body: IHealthcarePlatformBillingPayment.ICreate;
  };
  export type Body = IHealthcarePlatformBillingPayment.ICreate;
  export type Response = IHealthcarePlatformBillingPayment;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingPayments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/billingInvoices/${encodeURIComponent(props.billingInvoiceId ?? "null")}/billingPayments`;
  export const random = (): IHealthcarePlatformBillingPayment =>
    typia.random<IHealthcarePlatformBillingPayment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingInvoiceId")(() =>
        typia.assert(props.billingInvoiceId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve billing payments for a billing invoice
 * (healthcare_platform_billing_payments).
 *
 * Search and retrieve a paginated list of billing payment records linked to a
 * specific billing invoice. This API supports comprehensive filtering by
 * payment status, date range, currency, payee, and other dimensions for
 * financial audits and account management.
 *
 * Response contains payment summary data, including transaction details,
 * amounts, and reconciliation status. The query operation is optimized for
 * audit trail purposes, compliance reporting, and patient or administrative
 * review of payments applied to an invoice.
 *
 * Access is typically granted to finance staff (organizationAdmin, billing) and
 * all accesses are logged for both security and compliance purposes. Supports
 * business logic for missed, failed, or partially successful payments and
 * includes pagination/sorting as necessary for financial reporting dashboards.
 *
 * @param props.connection
 * @param props.billingInvoiceId Unique identifier of the billing invoice for
 *   which payment search is conducted
 * @param props.body Criteria for searching billing payments, supporting filters
 *   such as payment status, date ranges, amount, and pagination parameters
 * @path /healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingPayments
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingInvoices.billingPayments.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the billing invoice for which payment search is
     * conducted
     */
    billingInvoiceId: string & tags.Format<"uuid">;

    /**
     * Criteria for searching billing payments, supporting filters such as
     * payment status, date ranges, amount, and pagination parameters
     */
    body: IHealthcarePlatformBillingPayment.IRequest;
  };
  export type Body = IHealthcarePlatformBillingPayment.IRequest;
  export type Response = IPageIHealthcarePlatformBillingPayment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingPayments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/billingInvoices/${encodeURIComponent(props.billingInvoiceId ?? "null")}/billingPayments`;
  export const random = (): IPageIHealthcarePlatformBillingPayment.ISummary =>
    typia.random<IPageIHealthcarePlatformBillingPayment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingInvoiceId")(() =>
        typia.assert(props.billingInvoiceId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a billing payment by ID for a billing invoice
 * (healthcare_platform_billing_payments).
 *
 * Fetches detailed information for a single billing payment record under a
 * particular invoice. This endpoint is used by finance staff and organization
 * administrators to view transaction details, audit status, payer/payee data,
 * method used, status, and all metadata required for audit and compliance
 * reviews.
 *
 * The response includes transaction record, payee, payment method, any
 * reconciliation data, posting and update timestamps, and any related reference
 * numbers or memos. The endpoint validates the linkage between the invoice and
 * payment record before returning details.
 *
 * Access is typically limited to organization-admin roles to maintain financial
 * security and protect PHI. Response is optimized for audit, compliance, and
 * reporting, with all accesses logged appropriately for traceability.
 *
 * @param props.connection
 * @param props.billingInvoiceId Unique identifier of the billing invoice to
 *   which the payment belongs
 * @param props.billingPaymentId Unique identifier of the billing payment to
 *   retrieve
 * @path /healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingPayments/:billingPaymentId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingInvoices.billingPayments.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the billing invoice to which the payment belongs */
    billingInvoiceId: string & tags.Format<"uuid">;

    /** Unique identifier of the billing payment to retrieve */
    billingPaymentId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformBillingPayment;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingPayments/:billingPaymentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/billingInvoices/${encodeURIComponent(props.billingInvoiceId ?? "null")}/billingPayments/${encodeURIComponent(props.billingPaymentId ?? "null")}`;
  export const random = (): IHealthcarePlatformBillingPayment =>
    typia.random<IHealthcarePlatformBillingPayment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingInvoiceId")(() =>
        typia.assert(props.billingInvoiceId),
      );
      assert.param("billingPaymentId")(() =>
        typia.assert(props.billingPaymentId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing payment record for a billing invoice
 * (healthcare_platform_billing_payments table) in the healthcare platform.
 *
 * This operation allows authorized billing, finance, or administrative staff to
 * update a specific payment entry for a billing invoice. Example use cases
 * include correcting payment status (e.g., posted, voided, returned), updating
 * memo fields for audit traceability, or correcting the payment amount after
 * reconciliation with patient/insurer or financial records.
 *
 * Role-based access control must be enforced strictly. Only users with proper
 * privileges (e.g., organizationAdmin, billingStaff) may perform this update.
 * All changes are audit-logged with before/after state, reason, and user
 * identity for compliance with HIPAA and SOC2 financial audit trail standards.
 * Attempts to modify immutable or locked payment fields (e.g., when a payment
 * is completely reconciled, refunded, or under investigation) should be
 * rejected with descriptive errors.
 *
 * Schema adherence is mandatory: only allowed fields can be updated, and data
 * validation (format, allowable transitions) is required. Foreign keys (such as
 * payment method, invoice ID) cannot be reassigned via update; attempts to do
 * so should be blocked. This operation is related to payment record creation
 * and payment record retrieval operations. If errors occur, details should
 * include constraint violation or permission cause.
 *
 * @param props.connection
 * @param props.billingInvoiceId Unique identifier of the billing invoice to
 *   which this payment belongs.
 * @param props.billingPaymentId Unique identifier of the billing payment record
 *   to update.
 * @param props.body Data to update existing billing payment record (amount,
 *   memo, status, payment method, date, etc.).
 * @path /healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingPayments/:billingPaymentId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingInvoices.billingPayments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the billing invoice to which this payment
     * belongs.
     */
    billingInvoiceId: string & tags.Format<"uuid">;

    /** Unique identifier of the billing payment record to update. */
    billingPaymentId: string & tags.Format<"uuid">;

    /**
     * Data to update existing billing payment record (amount, memo, status,
     * payment method, date, etc.).
     */
    body: IHealthcarePlatformBillingPayment.IUpdate;
  };
  export type Body = IHealthcarePlatformBillingPayment.IUpdate;
  export type Response = IHealthcarePlatformBillingPayment;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingPayments/:billingPaymentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/billingInvoices/${encodeURIComponent(props.billingInvoiceId ?? "null")}/billingPayments/${encodeURIComponent(props.billingPaymentId ?? "null")}`;
  export const random = (): IHealthcarePlatformBillingPayment =>
    typia.random<IHealthcarePlatformBillingPayment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingInvoiceId")(() =>
        typia.assert(props.billingInvoiceId),
      );
      assert.param("billingPaymentId")(() =>
        typia.assert(props.billingPaymentId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently deletes a billing payment record from a billing invoice
 * (healthcare_platform_billing_payments table) in the healthcare platform.
 *
 * This operation enables authorized administrative users to permanently delete
 * a billing payment record from the system, as long as it is not locked,
 * reconciled, posted, or otherwise restricted by audit policies. Common use
 * cases include correction of accidental double entry, removal of test data, or
 * elimination of erroneous payment receipts before they become part of a
 * permanent financial/audit record.
 *
 * Strict role enforcement is required: only organizationAdmin or
 * billingSuperuser roles may erase payments, and a detailed audit message must
 * be recorded for all deletion events. The operation validates the payment's
 * state before deletion—if the record has been posted, audited, or is linked to
 * a final invoice closeout, the erase operation must be denied to preserve
 * compliance. Soft deletion is not used; this is a hard delete per schema.
 *
 * Related endpoints include payment creation, payment update, and payment
 * retrieval for auditing purposes. Error responses specify the reason for
 * deletion prohibition (e.g., already reconciled or under historical audit
 * hold).
 *
 * @param props.connection
 * @param props.billingInvoiceId Unique identifier of the billing invoice to
 *   which the payment belongs.
 * @param props.billingPaymentId Unique identifier of the billing payment record
 *   to delete.
 * @path /healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingPayments/:billingPaymentId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.billingInvoices.billingPayments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the billing invoice to which the payment
     * belongs.
     */
    billingInvoiceId: string & tags.Format<"uuid">;

    /** Unique identifier of the billing payment record to delete. */
    billingPaymentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/organizationAdmin/billingInvoices/:billingInvoiceId/billingPayments/:billingPaymentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/billingInvoices/${encodeURIComponent(props.billingInvoiceId ?? "null")}/billingPayments/${encodeURIComponent(props.billingPaymentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("billingInvoiceId")(() =>
        typia.assert(props.billingInvoiceId),
      );
      assert.param("billingPaymentId")(() =>
        typia.assert(props.billingPaymentId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
