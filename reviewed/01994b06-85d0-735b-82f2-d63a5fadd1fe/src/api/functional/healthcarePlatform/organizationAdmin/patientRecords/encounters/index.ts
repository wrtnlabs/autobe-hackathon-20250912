import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformEhrEncounter } from "../../../../../structures/IHealthcarePlatformEhrEncounter";
import { IPageIHealthcarePlatformEhrEncounter } from "../../../../../structures/IPageIHealthcarePlatformEhrEncounter";
export * as labResults from "./labResults/index";

/**
 * Create a new EHR encounter for a specific patient record.
 *
 * This endpoint allows an authorized clinical user to create a new encounter
 * event for a patient record, writing a new row in the
 * healthcare_platform_ehr_encounters schema. Required input includes encounter
 * type (office_visit, inpatient, telemedicine, emergency, etc.), provider
 * assignment, start/end times, status, and any initial clinical notes or
 * context. The operation enforces all business validation, including role-based
 * initiation checks and regulatory field completeness (e.g., provider ID,
 * encounter type, clinical summary as applicable).
 *
 * Sensitive logic such as workflow/encounter status, assignment, and audit
 * trail integration are executed in accordance with the business rules cited in
 * the requirements analysis. The endpoint returns the newly created encounter,
 * including the generated encounterId and all initial data fields, for
 * immediate reference by the care team and schedule.
 *
 * This operation is strictly permissioned to clinical roles (doctors, nurses)
 * or organization/department leadership, according to RBAC and
 * patient/department assignment. All creation attempts are logged according to
 * audit/compliance strategy.
 *
 * @param props.connection
 * @param props.patientRecordId Unique identifier of the patient record to which
 *   the new encounter will be added.
 * @param props.body Data required to create a new clinical or administrative
 *   EHR encounter for the patient record.
 * @path /healthcarePlatform/organizationAdmin/patientRecords/:patientRecordId/encounters
 * @accessor api.functional.healthcarePlatform.organizationAdmin.patientRecords.encounters.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique identifier of the patient record to which the new encounter
     * will be added.
     */
    patientRecordId: string & tags.Format<"uuid">;

    /**
     * Data required to create a new clinical or administrative EHR
     * encounter for the patient record.
     */
    body: IHealthcarePlatformEhrEncounter.ICreate;
  };
  export type Body = IHealthcarePlatformEhrEncounter.ICreate;
  export type Response = IHealthcarePlatformEhrEncounter;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/organizationAdmin/patientRecords/:patientRecordId/encounters",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/patientRecords/${encodeURIComponent(props.patientRecordId ?? "null")}/encounters`;
  export const random = (): IHealthcarePlatformEhrEncounter =>
    typia.random<IHealthcarePlatformEhrEncounter>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientRecordId")(() =>
        typia.assert(props.patientRecordId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated, filterable list of patient encounters.
 *
 * This API endpoint allows authorized users to retrieve all EHR encounters for
 * a given patient record as a paginated and searchable list. It references the
 * healthcare_platform_ehr_encounters table and includes parameters such as
 * encounter type (office_visit, telemedicine, inpatient), provider, status, and
 * time window. The operation supports sorting and pagination to efficiently
 * browse extensive encounter histories.
 *
 * Access to this endpoint is restricted based on RBAC and patient consent
 * status, with additional compliance requirements for audit trail and access
 * purpose logging (as described in the schema and regulatory requirements).
 * Sensitive patient data is redacted or filtered depending on the requester's
 * role. The response provides only summary information per encounter for list
 * views; detailed clinical data is available at the encounter detail endpoint.
 * All queries on this resource are indexed for performance and compliance
 * review.
 *
 * The operation fully aligns with the business logic and audit requirements
 * described in the requirements analysis, enforcing privacy, compliance, and
 * role-based data access for longitudinal patient record navigation.
 *
 * @param props.connection
 * @param props.patientRecordId Unique identifier of the patient record whose
 *   encounters are being queried.
 * @param props.body Search and pagination criteria for EHR encounter listing
 *   (e.g., date ranges, types, providers, status).
 * @path /healthcarePlatform/organizationAdmin/patientRecords/:patientRecordId/encounters
 * @accessor api.functional.healthcarePlatform.organizationAdmin.patientRecords.encounters.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the patient record whose encounters are being
     * queried.
     */
    patientRecordId: string & tags.Format<"uuid">;

    /**
     * Search and pagination criteria for EHR encounter listing (e.g., date
     * ranges, types, providers, status).
     */
    body: IHealthcarePlatformEhrEncounter.IRequest;
  };
  export type Body = IHealthcarePlatformEhrEncounter.IRequest;
  export type Response = IPageIHealthcarePlatformEhrEncounter.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/organizationAdmin/patientRecords/:patientRecordId/encounters",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/patientRecords/${encodeURIComponent(props.patientRecordId ?? "null")}/encounters`;
  export const random = (): IPageIHealthcarePlatformEhrEncounter.ISummary =>
    typia.random<IPageIHealthcarePlatformEhrEncounter.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientRecordId")(() =>
        typia.assert(props.patientRecordId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a specific patient encounter by ID.
 *
 * This API endpoint allows authorized users to access full details for a single
 * EHR encounter belonging to a patient record, referencing the
 * healthcare_platform_ehr_encounters schema and associated foreign key data
 * (provider, notes, encounter type, timestamps, and audit metadata). The
 * endpoint returns all available structured and narrative data for the
 * encounter, used for medical/legal review, care coordination, and compliance
 * audits.
 *
 * Access controls are enforced by role (medicalDoctor, nurse,
 * organizationAdmin) and on the basis of patient consent and regulatory
 * requirements. Only appropriate users may view detailed records; sensitive or
 * restricted information is filtered for non-clinical requesters. This endpoint
 * complements the encounter index/list operation, providing drill-down detail
 * for a specific clinical event, and triggers access logging/auditing per
 * compliance policy described in the requirements documentation and schema
 * comments.
 *
 * Error handling includes clear responses for unauthorized access, not found,
 * or record lock/workflow conflicts. All detail retrievals are logged for
 * downstream audit, and response schema always matches current EHR encounter
 * detail structure.
 *
 * @param props.connection
 * @param props.patientRecordId Unique identifier of the patient record
 *   containing the encounter.
 * @param props.encounterId Unique identifier of the EHR encounter to retrieve.
 * @path /healthcarePlatform/organizationAdmin/patientRecords/:patientRecordId/encounters/:encounterId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.patientRecords.encounters.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the patient record containing the encounter. */
    patientRecordId: string & tags.Format<"uuid">;

    /** Unique identifier of the EHR encounter to retrieve. */
    encounterId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformEhrEncounter;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/organizationAdmin/patientRecords/:patientRecordId/encounters/:encounterId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/organizationAdmin/patientRecords/${encodeURIComponent(props.patientRecordId ?? "null")}/encounters/${encodeURIComponent(props.encounterId ?? "null")}`;
  export const random = (): IHealthcarePlatformEhrEncounter =>
    typia.random<IHealthcarePlatformEhrEncounter>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientRecordId")(() =>
        typia.assert(props.patientRecordId),
      );
      assert.param("encounterId")(() => typia.assert(props.encounterId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details of an existing EHR encounter for a patient record.
 *
 * This API endpoint allows an authorized user to amend or update an existing
 * EHR encounter for a patient record, identified by patientRecordId and
 * encounterId. The operation references the healthcare_platform_ehr_encounters
 * schema, supporting updates to encounter type, timing, provider assignment,
 * clinical notes, and status. All changes trigger a new version (tracked in EHR
 * versions) and comprehensive audit logging in accordance with business and
 * regulatory policy.
 *
 * Role-based access controls ensure that only clinicians, nurses, or
 * departmental/organizational leadership can perform modification. Validation
 * logic includes status workflow checks (e.g., completed, locked, in-review),
 * field completeness, and approval where applicable. All update attempts are
 * logged with user identity and rationale per the audit/compliance framework.
 * Errors for business rule violations, locked records, or audit holds are
 * returned with actionable remediation.
 *
 * On success, the endpoint returns the updated encounter object reflecting all
 * modifications and the new effective state. This operation is critical for
 * accurate, auditable, and legal recordkeeping as detailed in the requirements
 * documentation and schema.
 *
 * @param props.connection
 * @param props.patientRecordId Unique identifier of the patient record
 *   containing the encounter to update.
 * @param props.encounterId Unique identifier of the EHR encounter to be
 *   updated.
 * @param props.body Fields to amend or update on the existing encounter (type,
 *   timing, status, provider, clinical notes, etc).
 * @path /healthcarePlatform/organizationAdmin/patientRecords/:patientRecordId/encounters/:encounterId
 * @accessor api.functional.healthcarePlatform.organizationAdmin.patientRecords.encounters.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the patient record containing the encounter to
     * update.
     */
    patientRecordId: string & tags.Format<"uuid">;

    /** Unique identifier of the EHR encounter to be updated. */
    encounterId: string & tags.Format<"uuid">;

    /**
     * Fields to amend or update on the existing encounter (type, timing,
     * status, provider, clinical notes, etc).
     */
    body: IHealthcarePlatformEhrEncounter.IUpdate;
  };
  export type Body = IHealthcarePlatformEhrEncounter.IUpdate;
  export type Response = IHealthcarePlatformEhrEncounter;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/organizationAdmin/patientRecords/:patientRecordId/encounters/:encounterId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/organizationAdmin/patientRecords/${encodeURIComponent(props.patientRecordId ?? "null")}/encounters/${encodeURIComponent(props.encounterId ?? "null")}`;
  export const random = (): IHealthcarePlatformEhrEncounter =>
    typia.random<IHealthcarePlatformEhrEncounter>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientRecordId")(() =>
        typia.assert(props.patientRecordId),
      );
      assert.param("encounterId")(() => typia.assert(props.encounterId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
