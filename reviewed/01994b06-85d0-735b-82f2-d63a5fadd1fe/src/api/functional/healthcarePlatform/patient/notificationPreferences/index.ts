import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformNotificationPreference } from "../../../../structures/IHealthcarePlatformNotificationPreference";

/**
 * Update a notification preference record for a user
 * (healthcare_platform_notification_preferences table).
 *
 * This API operation permits the update of an individual notification
 * preference setting for a user or staff member. The preference record
 * determines how notifications are delivered (e.g., by email, SMS, in-app,
 * etc.), as well as whether certain types of notifications (reminders, alerts,
 * escalations) are enabled or muted per organization and notification type.
 *
 * The request is subject to business logic validating that the specified
 * notificationPreferenceId exists, is owned by the acting user or modifiable by
 * an administrator, and adheres to organizational policy. Changes to
 * notification preference may require audit logging for compliance with user
 * opt-in/opt-out rights and organizational escalation rules. The endpoint
 * supports changes to mute windows (DND), escalation routing, and explicit
 * enable/disable per channel and type.
 *
 * Only authorized roles (the notificationPreference owner or organization admin
 * with explicit privilege) can modify notification preferences for a user.
 * System-wide or org-level notification defaults are enforced as fallback if no
 * user preference exists.
 *
 * Related operations include creating a new preference (POST), retrieving all
 * preferences for a user (GET/PATCH), or deleting a preference (DELETE). Error
 * scenarios include invalid IDs, attempts to modify preferences outside a
 * user's org context, or violating business rules for critical notifications.
 *
 * @param props.connection
 * @param props.notificationPreferenceId Unique identifier for the notification
 *   preference record to update.
 * @param props.body Notification preference update payload, including channel,
 *   type, mute window, enable state, etc.
 * @path /healthcarePlatform/patient/notificationPreferences/:notificationPreferenceId
 * @accessor api.functional.healthcarePlatform.patient.notificationPreferences.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier for the notification preference record to update. */
    notificationPreferenceId: string & tags.Format<"uuid">;

    /**
     * Notification preference update payload, including channel, type, mute
     * window, enable state, etc.
     */
    body: IHealthcarePlatformNotificationPreference.IUpdate;
  };
  export type Body = IHealthcarePlatformNotificationPreference.IUpdate;
  export type Response = IHealthcarePlatformNotificationPreference;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/patient/notificationPreferences/:notificationPreferenceId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/patient/notificationPreferences/${encodeURIComponent(props.notificationPreferenceId ?? "null")}`;
  export const random = (): IHealthcarePlatformNotificationPreference =>
    typia.random<IHealthcarePlatformNotificationPreference>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationPreferenceId")(() =>
        typia.assert(props.notificationPreferenceId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (soft-delete) a notification preference record for a user
 * (healthcare_platform_notification_preferences table).
 *
 * This API operation allows a user or administrator to delete a specific
 * notification preference record, reverting notification delivery to the
 * organization-level or system default configuration for channel, mute, and
 * escalation policies. The operation marks the preference entry as deleted
 * (soft delete via deleted_at), preserving it for audit and compliance review
 * per policy.
 *
 * Proper authorization is enforced - only the preference owner or an
 * organization admin with privilege can delete a preference. Soft deletion
 * ensures historical opt-in/opt-out records are available for regulatory
 * queries. Open reminders or notifications are unaffected; future messages will
 * follow fallback notification rules.
 *
 * Error scenarios include invalid notificationPreferenceId, attempts to delete
 * records outside the user's org, or system-protected notification types which
 * cannot be disabled due to criticality or regulatory policy. The operation
 * does not physically remove records immediately to comply with audit
 * standards.
 *
 * Related operations include creating/updating preferences, retrieving the full
 * preference set for a user, or restoring/re-enabling deleted preferences for
 * audit recourse.
 *
 * @param props.connection
 * @param props.notificationPreferenceId Unique identifier for the notification
 *   preference record to delete.
 * @path /healthcarePlatform/patient/notificationPreferences/:notificationPreferenceId
 * @accessor api.functional.healthcarePlatform.patient.notificationPreferences.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the notification preference record to delete. */
    notificationPreferenceId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/patient/notificationPreferences/:notificationPreferenceId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/patient/notificationPreferences/${encodeURIComponent(props.notificationPreferenceId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("notificationPreferenceId")(() =>
        typia.assert(props.notificationPreferenceId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
