import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformInsuranceApiIntegration } from "../../../../structures/IHealthcarePlatformInsuranceApiIntegration";
import { IPageIHealthcarePlatformInsuranceApiIntegration } from "../../../../structures/IPageIHealthcarePlatformInsuranceApiIntegration";

/**
 * Create a new insurance API integration configuration for an organization.
 *
 * Create a new insurance API integration for a specific healthcare
 * organization, providing details such as the insurance vendor code, API
 * connection URI, supported transaction types (e.g., eligibility, claims), and
 * operational status. This operation supports onboarding new insurance vendors
 * or changing integration configuration while ensuring compliance with the
 * organization's boundary and audit requirements.
 *
 * The operation enforces data integrity by requiring a unique combination of
 * organization ID and insurance vendor code. Status must be appropriate to the
 * deployment state (active, test, failed, etc), and connection URIs are
 * validated for reachability and standards compliance. Only systemAdmins or
 * organizationAdmins may perform this action, as insurance integrations affect
 * compliance and external communications.
 *
 * After successful creation, the new integration becomes available for workflow
 * automation, including claims and eligibility checks. Failure scenarios
 * include uniqueness violations or invalid configuration, in which case errors
 * detail the required correction.
 *
 * @param props.connection
 * @param props.body Information required to create an insurance API integration
 *   configuration
 * @path /healthcarePlatform/systemAdmin/insuranceApiIntegrations
 * @accessor api.functional.healthcarePlatform.systemAdmin.insuranceApiIntegrations.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information required to create an insurance API integration
     * configuration
     */
    body: IHealthcarePlatformInsuranceApiIntegration.ICreate;
  };
  export type Body = IHealthcarePlatformInsuranceApiIntegration.ICreate;
  export type Response = IHealthcarePlatformInsuranceApiIntegration;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/systemAdmin/insuranceApiIntegrations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/systemAdmin/insuranceApiIntegrations";
  export const random = (): IHealthcarePlatformInsuranceApiIntegration =>
    typia.random<IHealthcarePlatformInsuranceApiIntegration>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve filtered and paginated list of insurance API integrations
 * (healthcare_platform_insurance_api_integrations).
 *
 * Retrieve a filtered, paginated, and optionally sorted list of insurance API
 * integration configuration records from the
 * healthcare_platform_insurance_api_integrations table.
 *
 * This endpoint supports advanced searching by integration type, status,
 * organization, supported transaction types, or other properties to enable
 * audit, compliance, and troubleshooting of insurance-related workflows and
 * payer data exchange setups. Only authorized administrative or system users
 * can retrieve this information due to the sensitivity of payer integration
 * metadata and API secrets.
 *
 * The operation returns configuration details, including unique connection
 * URIs, insurance vendor codes, status, and supported transaction types for
 * each integration. No write, update, or delete operation is supported in this
 * endpoint: integration creation and modification are managed through
 * restricted or back-office workflows outside this API.
 *
 * Pagination parameters allow efficient access and display of many
 * configuration records with summary metadata. This endpoint is critical for
 * compliance, payer integration monitoring, and operational readiness reviews
 * for both system and organization administrators.
 *
 * @param props.connection
 * @param props.body Search filters and pagination/sorting criteria for
 *   insurance API integration query.
 * @path /healthcarePlatform/systemAdmin/insuranceApiIntegrations
 * @accessor api.functional.healthcarePlatform.systemAdmin.insuranceApiIntegrations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search filters and pagination/sorting criteria for insurance API
     * integration query.
     */
    body: IHealthcarePlatformInsuranceApiIntegration.IRequest;
  };
  export type Body = IHealthcarePlatformInsuranceApiIntegration.IRequest;
  export type Response = IPageIHealthcarePlatformInsuranceApiIntegration;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/systemAdmin/insuranceApiIntegrations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/systemAdmin/insuranceApiIntegrations";
  export const random = (): IPageIHealthcarePlatformInsuranceApiIntegration =>
    typia.random<IPageIHealthcarePlatformInsuranceApiIntegration>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details for a single insurance API integration
 * (healthcare_platform_insurance_api_integrations).
 *
 * Retrieve the detail for a single insurance API integration configuration from
 * the healthcare_platform_insurance_api_integrations table using its unique
 * identifier.
 *
 * This endpoint provides comprehensive detail on the insurance API integration,
 * including organization reference, payer/vendor code, connection URI,
 * supported transaction types (e.g., eligibility, claims, realtime), current
 * status, and configuration change/audit history if applicable.
 *
 * These records are highly sensitive and must be restricted to administrative
 * or back-office user roles due to the presence of API credentials or
 * security-relevant metadata; access is not available to general users. All
 * configuration management or change workflows are managed outside this API:
 * usage here is strictly read-only for operational review, troubleshooting, or
 * audit.
 *
 * This endpoint supports compliance requirements, integration lifecycle
 * management, and system health monitoring for insurance API integrations
 * across the multi-tenant environment.
 *
 * @param props.connection
 * @param props.insuranceApiIntegrationId Unique identifier for the insurance
 *   API integration record to retrieve.
 * @path /healthcarePlatform/systemAdmin/insuranceApiIntegrations/:insuranceApiIntegrationId
 * @accessor api.functional.healthcarePlatform.systemAdmin.insuranceApiIntegrations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier for the insurance API integration record to
     * retrieve.
     */
    insuranceApiIntegrationId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformInsuranceApiIntegration;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/systemAdmin/insuranceApiIntegrations/:insuranceApiIntegrationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/insuranceApiIntegrations/${encodeURIComponent(props.insuranceApiIntegrationId ?? "null")}`;
  export const random = (): IHealthcarePlatformInsuranceApiIntegration =>
    typia.random<IHealthcarePlatformInsuranceApiIntegration>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("insuranceApiIntegrationId")(() =>
        typia.assert(props.insuranceApiIntegrationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update configuration of an existing insurance API integration.
 *
 * Update an existing insurance API integration configuration record, allowing
 * reconfiguration of vendor code, connection URI, supported transaction types,
 * or operational status. This operation ensures that only one integration per
 * vendor per organization exists and prevents accidental overwrites.
 *
 * Security is enforced via administrator-level roles, with write-access limited
 * to systemAdmins and organizationAdmins of the relevant tenant. Invalid input,
 * such as an incorrect URI format or unsupported transaction type, results in
 * actionable validation errors. Configuration changes are immediately auditable
 * in system logs and take effect upon next integration use.
 *
 * If an integration is marked as inactive, it is excluded from eligibility or
 * claim submissions until reactivated by administrators.
 *
 * @param props.connection
 * @param props.insuranceApiIntegrationId Unique identifier of the insurance API
 *   integration to update
 * @param props.body Updated configuration for the insurance API integration
 * @path /healthcarePlatform/systemAdmin/insuranceApiIntegrations/:insuranceApiIntegrationId
 * @accessor api.functional.healthcarePlatform.systemAdmin.insuranceApiIntegrations.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the insurance API integration to update */
    insuranceApiIntegrationId: string & tags.Format<"uuid">;

    /** Updated configuration for the insurance API integration */
    body: IHealthcarePlatformInsuranceApiIntegration.IUpdate;
  };
  export type Body = IHealthcarePlatformInsuranceApiIntegration.IUpdate;
  export type Response = IHealthcarePlatformInsuranceApiIntegration;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/systemAdmin/insuranceApiIntegrations/:insuranceApiIntegrationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/systemAdmin/insuranceApiIntegrations/${encodeURIComponent(props.insuranceApiIntegrationId ?? "null")}`;
  export const random = (): IHealthcarePlatformInsuranceApiIntegration =>
    typia.random<IHealthcarePlatformInsuranceApiIntegration>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("insuranceApiIntegrationId")(() =>
        typia.assert(props.insuranceApiIntegrationId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete an insurance API integration configuration.
 *
 * Delete an insurance API integration configuration record from the system.
 * This operation removes the record entirely from the
 * healthcare_platform_insurance_api_integrations table, including connection
 * details and configuration.
 *
 * Due to the risk of disrupting insurance workflows, delete operations are
 * restricted to systemAdmins and organizationAdmins. Prior to deletion, any
 * associations with outstanding claims or transactions should be reviewed to
 * avoid workflow impact.
 *
 * This operation is a hard delete; after execution, the integration cannot be
 * recovered. The action is logged in the audit trail for regulatory
 * compliance.
 *
 * @param props.connection
 * @param props.insuranceApiIntegrationId Unique identifier of the insurance API
 *   integration to be deleted
 * @path /healthcarePlatform/systemAdmin/insuranceApiIntegrations/:insuranceApiIntegrationId
 * @accessor api.functional.healthcarePlatform.systemAdmin.insuranceApiIntegrations.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the insurance API integration to be deleted */
    insuranceApiIntegrationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/systemAdmin/insuranceApiIntegrations/:insuranceApiIntegrationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/insuranceApiIntegrations/${encodeURIComponent(props.insuranceApiIntegrationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("insuranceApiIntegrationId")(() =>
        typia.assert(props.insuranceApiIntegrationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
