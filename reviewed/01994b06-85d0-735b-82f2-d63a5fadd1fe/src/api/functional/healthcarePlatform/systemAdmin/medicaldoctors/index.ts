import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformMedicalDoctor } from "../../../../structures/IHealthcarePlatformMedicalDoctor";
import { IPageIHealthcarePlatformMedicalDoctor } from "../../../../structures/IPageIHealthcarePlatformMedicalDoctor";

/**
 * Create a new medical doctor record (healthcare_platform_medicaldoctors).
 *
 * Create a new medical doctor profile and add them to the healthcare platform.
 * Consumers must supply all mandatory fields as defined by the
 * healthcare_platform_medicaldoctors table, such as email, full name, NPI
 * number, and other professional details. On successful creation, the provider
 * record will be accessible for further assignment to departments, clinical
 * scheduling, or license validation.
 *
 * Only authorized users (system admins or organization admins) can execute this
 * operation. The input request is validated for uniqueness constraints (email,
 * NPI number) and field formats. Business logic may trigger credential
 * verification and onboarding workflows as part of post-processing.
 *
 * Related API operations include updating a doctor's profile, assigning
 * provider to organizations/departments, or starting credential validation
 * sequences. All creation actions are fully audited.
 *
 * @param props.connection
 * @param props.body Information required to create a new medical doctor
 *   profile, including required credential and contact fields.
 * @path /healthcarePlatform/systemAdmin/medicaldoctors
 * @accessor api.functional.healthcarePlatform.systemAdmin.medicaldoctors.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information required to create a new medical doctor profile,
     * including required credential and contact fields.
     */
    body: IHealthcarePlatformMedicalDoctor.ICreate;
  };
  export type Body = IHealthcarePlatformMedicalDoctor.ICreate;
  export type Response = IHealthcarePlatformMedicalDoctor;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/systemAdmin/medicaldoctors",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/systemAdmin/medicaldoctors";
  export const random = (): IHealthcarePlatformMedicalDoctor =>
    typia.random<IHealthcarePlatformMedicalDoctor>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Paginated search/filter for Medical Doctors (table:
 * healthcare_platform_medicaldoctors).
 *
 * This operation enables platform administrators and organization
 * administrators with appropriate privileges to perform advanced, paginated
 * search across the full set of Medical Doctor records in the system. Search
 * may leverage any combination of fields such as email, NPI number, clinical
 * specialty, or name for authentication, administrative assignment, and
 * clinical compliance reporting purposes. Only authorized roles may access
 * these capabilities due to the sensitive nature of provider records and
 * licensure data.
 *
 * The operation supports pagination and flexible filtering, with return
 * structures optimized for administrative dashboards, analytics, and resource
 * management. Secure auditing is ensured for all queries, and access is
 * restricted to prevent inappropriate exposure of credential information.
 * Responses may be filtered based on role scope (system-wide or
 * organization-specific). Error states include invalid search parameters or
 * permission errors. Operation is compliant with regulatory requirements for
 * auditing provider access and credential reviews.
 *
 * @param props.connection
 * @param props.body Search criteria and paging/filter options for searching
 *   Medical Doctors
 * @path /healthcarePlatform/systemAdmin/medicaldoctors
 * @accessor api.functional.healthcarePlatform.systemAdmin.medicaldoctors.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and paging/filter options for searching Medical
     * Doctors
     */
    body: IHealthcarePlatformMedicalDoctor.IRequest;
  };
  export type Body = IHealthcarePlatformMedicalDoctor.IRequest;
  export type Response = IPageIHealthcarePlatformMedicalDoctor.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/systemAdmin/medicaldoctors",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/systemAdmin/medicaldoctors";
  export const random = (): IPageIHealthcarePlatformMedicalDoctor.ISummary =>
    typia.random<IPageIHealthcarePlatformMedicalDoctor.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information for a specific medical doctor profile
 * (healthcare_platform_medicaldoctors).
 *
 * Retrieve detailed information about a single medical doctor based on their
 * unique identifier. This operation provides access to the full profile,
 * credentials, and attributes as defined in the
 * healthcare_platform_medicaldoctors table of the Prisma schema, ensuring
 * up-to-date data for authorized consumers.
 *
 * Security considerations demand strict role-based access control, as viewing
 * doctor information is reserved for users with appropriate clinical,
 * administrative, or system-level rights. All access is logged for compliance
 * and audit, and data may be filtered or masked in accordance with organization
 * or regulatory policy.
 *
 * Returned properties include legal name, NPI number, specialty, email, phone,
 * and timestamps for creation, update, and soft deletion status. Any attempt to
 * access a record that is marked deleted or does not exist shall result in an
 * access error. Other business logic such as data masking might apply based on
 * caller's role or organization.
 *
 * Related API operations include searching for providers, updating or
 * deactivating profiles, and credential/license verification. For related
 * actions, refer to provider search and assignment endpoints.
 *
 * @param props.connection
 * @param props.medicalDoctorId The unique identifier (UUID) of the target
 *   medical doctor to retrieve.
 * @path /healthcarePlatform/systemAdmin/medicaldoctors/:medicalDoctorId
 * @accessor api.functional.healthcarePlatform.systemAdmin.medicaldoctors.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * The unique identifier (UUID) of the target medical doctor to
     * retrieve.
     */
    medicalDoctorId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformMedicalDoctor;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/systemAdmin/medicaldoctors/:medicalDoctorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/medicaldoctors/${encodeURIComponent(props.medicalDoctorId ?? "null")}`;
  export const random = (): IHealthcarePlatformMedicalDoctor =>
    typia.random<IHealthcarePlatformMedicalDoctor>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("medicalDoctorId")(() =>
        typia.assert(props.medicalDoctorId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing medical doctor profile by ID
 * (healthcare_platform_medicaldoctors).
 *
 * Update an existing medical doctor's profile using their unique identifier.
 * The payload must adhere to the update schema defined for the
 * healthcare_platform_medicaldoctors table, supporting partial or complete
 * edits to fields such as contact info, specialty, or other business
 * attributes.
 *
 * This operation is restricted to system admins and organization admins,
 * subject to RBAC, and all changes are audited for compliance. Depending on the
 * field, updates may trigger downstream business logic such as credential
 * re-validation or workflow assignment.
 *
 * If the specified medical doctor does not exist or is marked as deleted, the
 * operation will return an error response. Related endpoints include creating a
 * provider, viewing details, or deactivating their record. Audit trails will
 * track who made the update, what fields changed, and when.
 *
 * @param props.connection
 * @param props.medicalDoctorId The unique identifier (UUID) of the medical
 *   doctor to update.
 * @param props.body Fields and values to update in the target medical doctor's
 *   profile. Only allowed and non-immutable fields may be modified.
 * @path /healthcarePlatform/systemAdmin/medicaldoctors/:medicalDoctorId
 * @accessor api.functional.healthcarePlatform.systemAdmin.medicaldoctors.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier (UUID) of the medical doctor to update. */
    medicalDoctorId: string & tags.Format<"uuid">;

    /**
     * Fields and values to update in the target medical doctor's profile.
     * Only allowed and non-immutable fields may be modified.
     */
    body: IHealthcarePlatformMedicalDoctor.IUpdate;
  };
  export type Body = IHealthcarePlatformMedicalDoctor.IUpdate;
  export type Response = IHealthcarePlatformMedicalDoctor;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/systemAdmin/medicaldoctors/:medicalDoctorId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/systemAdmin/medicaldoctors/${encodeURIComponent(props.medicalDoctorId ?? "null")}`;
  export const random = (): IHealthcarePlatformMedicalDoctor =>
    typia.random<IHealthcarePlatformMedicalDoctor>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("medicalDoctorId")(() =>
        typia.assert(props.medicalDoctorId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a medical doctor record by ID
 * (healthcare_platform_medicaldoctors).
 *
 * Delete (soft delete) a specific medical doctor profile by unique ID. Instead
 * of physically removing the provider record, this operation sets the
 * deleted_at field to indicate logical deletion, in accordance with compliance
 * retention policy. The profile will be excluded from routine queries but
 * retained in the database for audit and recovery purposes.
 *
 * Execution of this operation requires system admin or organization
 * administrator privileges. Business logic checks will prevent deletion if the
 * medical doctor is tied to active clinical assignments, regulatory holds, or
 * ongoing credentialing processes. All deletion actions are recorded in the
 * audit trail, and restoration is possible via dedicated recovery workflows.
 *
 * If the record does not exist or is already deleted, a not found or idempotent
 * success response is returned. Related API operations include restoration,
 * fetching active/deleted doctors, and compliance audit reporting.
 *
 * @param props.connection
 * @param props.medicalDoctorId The unique identifier (UUID) of the medical
 *   doctor to delete.
 * @path /healthcarePlatform/systemAdmin/medicaldoctors/:medicalDoctorId
 * @accessor api.functional.healthcarePlatform.systemAdmin.medicaldoctors.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The unique identifier (UUID) of the medical doctor to delete. */
    medicalDoctorId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/systemAdmin/medicaldoctors/:medicalDoctorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/medicaldoctors/${encodeURIComponent(props.medicalDoctorId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("medicalDoctorId")(() =>
        typia.assert(props.medicalDoctorId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
