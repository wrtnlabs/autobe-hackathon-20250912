import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformPermission } from "../../../../structures/IHealthcarePlatformPermission";
import { IPageIHealthcarePlatformPermission } from "../../../../structures/IPageIHealthcarePlatformPermission";

/**
 * Create a new permission entry in the healthcare_platform_permissions table.
 *
 * Creates a new permission in the system RBAC database by accepting details
 * such as code, name, description, scope_type, and status. The POST request
 * validates all required fields and implements uniqueness checks (e.g.,
 * code/scope_type pair) as enforced in the Prisma schema. All permission
 * creation actions are strictly limited to users with 'systemAdmin' role to
 * prevent unauthorized privilege escalation or RBAC modifications.
 *
 * On successful creation, the detailed permission record is returned. If the
 * provided code or scope_type is not unique, or input validation fails, an
 * error is returned. Related operations include viewing, updating, listing, or
 * deleting permissions as part of RBAC configuration and audit routines. All
 * creation events must be audit-logged for compliance.
 *
 * @param props.connection
 * @param props.body Fields required for creation of a permission definition.
 * @path /healthcarePlatform/systemAdmin/permissions
 * @accessor api.functional.healthcarePlatform.systemAdmin.permissions.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Fields required for creation of a permission definition. */
    body: IHealthcarePlatformPermission.ICreate;
  };
  export type Body = IHealthcarePlatformPermission.ICreate;
  export type Response = IHealthcarePlatformPermission;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/systemAdmin/permissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/systemAdmin/permissions";
  export const random = (): IHealthcarePlatformPermission =>
    typia.random<IHealthcarePlatformPermission>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Filter, search, and paginate RBAC permission definitions for mapping.
 *
 * Retrieve a paginated and filtered list of available RBAC permissions in the
 * system. Permissions define discrete actionable functions or scopes granted to
 * roles. This endpoint supports advanced filtering by permission code, name,
 * scope_type, and status to allow administrators to understand, review, and
 * manage available permissions.
 *
 * Security: This operation is limited to authenticated system or organization
 * administrators, ensuring only privileged users can review and map system
 * permissions. Business logic enforces role-based restrictions per the
 * organization context, as defined in the Prisma schema.
 *
 * Relationship: Permissions retrieved via this operation are mapped to roles
 * using the roles interface. Permission status, description, and allowed
 * scope_type are included in the response for administrators to perform
 * accurate role-based mapping and audits.
 *
 * Validation: Filtering supports partial and case-insensitive matching. Results
 * are paginated for large systems; administrators should use pagination
 * controls for efficient data discovery. Attempting to access without required
 * RBAC context returns a 403 error.
 *
 * This operation is typically used as a precursor to the assignment or update
 * of role permissions in organization or platform setup workflows.
 *
 * @param props.connection
 * @param props.body Filter, search, and pagination parameters for permission
 *   retrieval.
 * @path /healthcarePlatform/systemAdmin/permissions
 * @accessor api.functional.healthcarePlatform.systemAdmin.permissions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter, search, and pagination parameters for permission retrieval. */
    body: IHealthcarePlatformPermission.IRequest;
  };
  export type Body = IHealthcarePlatformPermission.IRequest;
  export type Response = IPageIHealthcarePlatformPermission.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/systemAdmin/permissions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/systemAdmin/permissions";
  export const random = (): IPageIHealthcarePlatformPermission.ISummary =>
    typia.random<IPageIHealthcarePlatformPermission.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific permission definition from the
 * healthcare_platform_permissions table.
 *
 * Retrieves information for a single permission, identified by its unique
 * permissionId. This permission may be associated with a given scope such as
 * platform, organization, or department, and includes all fields defined in the
 * permissions table, such as code, name, description, scope_type, and status.
 *
 * Only authorized users with platform or organization-level administrative
 * rights may view permission definitions to prevent unauthorized enumeration of
 * sensitive permission codes. Path parameter validation must ensure a valid
 * UUID is supplied. Returns the full permission record if found, or an
 * appropriate error if not found or access is denied.
 *
 * Permission records are foundational to the system's RBAC design and may be
 * referenced by role/permission assignment features. Related operations include
 * listing all permissions, creating new permissions, updating existing
 * permissions, and deleting permissions.
 *
 * @param props.connection
 * @param props.permissionId Unique identifier for the permission record to
 *   retrieve (UUID format).
 * @path /healthcarePlatform/systemAdmin/permissions/:permissionId
 * @accessor api.functional.healthcarePlatform.systemAdmin.permissions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier for the permission record to retrieve (UUID
     * format).
     */
    permissionId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformPermission;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/systemAdmin/permissions/:permissionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/permissions/${encodeURIComponent(props.permissionId ?? "null")}`;
  export const random = (): IHealthcarePlatformPermission =>
    typia.random<IHealthcarePlatformPermission>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("permissionId")(() => typia.assert(props.permissionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing permission entry in the healthcare_platform_permissions
 * table.
 *
 * Updates the definition of a specific permission identified by permissionId.
 * All updates are restricted to users with 'systemAdmin' rights to prevent
 * unauthorized RBAC manipulation. Update requests allow changes to any of the
 * modifiable fields as per the schema and require validation that the new
 * code/scope_type pair remains unique.
 *
 * The underlying implementation should handle both full and partial updates,
 * but as per the design, PUT is used for full updates of the permission entry.
 * Returns the updated permission object upon success. Errors arise if the
 * permissionId is not found, validation fails, or uniqueness constraints are
 * violated. All updates must be recorded in the audit log for compliance
 * tracking.
 *
 * @param props.connection
 * @param props.permissionId Target permission's unique identifier (UUID
 *   format).
 * @param props.body All modifiable fields for the targeted permission (code,
 *   name, description, scope_type, status, etc).
 * @path /healthcarePlatform/systemAdmin/permissions/:permissionId
 * @accessor api.functional.healthcarePlatform.systemAdmin.permissions.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target permission's unique identifier (UUID format). */
    permissionId: string & tags.Format<"uuid">;

    /**
     * All modifiable fields for the targeted permission (code, name,
     * description, scope_type, status, etc).
     */
    body: IHealthcarePlatformPermission.IUpdate;
  };
  export type Body = IHealthcarePlatformPermission.IUpdate;
  export type Response = IHealthcarePlatformPermission;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/systemAdmin/permissions/:permissionId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/systemAdmin/permissions/${encodeURIComponent(props.permissionId ?? "null")}`;
  export const random = (): IHealthcarePlatformPermission =>
    typia.random<IHealthcarePlatformPermission>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("permissionId")(() => typia.assert(props.permissionId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a permission entry from the healthcare_platform_permissions
 * table.
 *
 * Marks a permission as deleted by setting the deleted_at timestamp, allowing
 * for logical removal from access control flows while maintaining historical
 * and compliance traceability. This operation enforces all business constraints
 * regarding deletion, including preventing deletion of permissions currently
 * assigned to roles. Strictly limited to 'systemAdmin' role users. If the
 * permission cannot be deleted due to policy, the operation returns an error
 * with an explanatory message.
 *
 * This operation is part of the permission lifecycle management and must ensure
 * all relevant references and audit trails remain intact. The actual record
 * remains available for compliance retrieval as required by enterprise
 * healthcare audit policy.
 *
 * @param props.connection
 * @param props.permissionId Unique identifier for the permission entry to be
 *   deleted (UUID format).
 * @path /healthcarePlatform/systemAdmin/permissions/:permissionId
 * @accessor api.functional.healthcarePlatform.systemAdmin.permissions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier for the permission entry to be deleted (UUID
     * format).
     */
    permissionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/systemAdmin/permissions/:permissionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/permissions/${encodeURIComponent(props.permissionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("permissionId")(() => typia.assert(props.permissionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
