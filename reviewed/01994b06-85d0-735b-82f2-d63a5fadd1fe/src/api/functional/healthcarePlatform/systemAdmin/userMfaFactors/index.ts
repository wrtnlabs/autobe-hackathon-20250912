import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformUserMfaFactor } from "../../../../structures/IHealthcarePlatformUserMfaFactor";
import { IPageIHealthcarePlatformUserMfaFactor } from "../../../../structures/IPageIHealthcarePlatformUserMfaFactor";

/**
 * Create a new user MFA factor for a user (TOTP, SMS, email, etc).
 *
 * Create a new user MFA factor record by providing the user, type, factor
 * value, priority, and status. The operation validates business logic—ensuring
 * only one primary factor per type, appropriate credential security, and
 * correct scoping by user type. It enforces RBAC: only admin-level roles can
 * add MFA factors for users/scenarios such as user onboarding, compliance
 * rollout, or factor replacement after credential expiry/misuse.
 *
 * Returns the created MFA factor's configuration and metadata, with the
 * credential field redacted. If duplicate or conflicting factors are requested,
 * a business error is returned with remediation direction.
 *
 * Audit logs record all MFA factor creation for compliance.
 *
 * @param props.connection
 * @param props.body MFA factor creation data—user, type, value, priority, and
 *   settings.
 * @path /healthcarePlatform/systemAdmin/userMfaFactors
 * @accessor api.functional.healthcarePlatform.systemAdmin.userMfaFactors.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** MFA factor creation data—user, type, value, priority, and settings. */
    body: IHealthcarePlatformUserMfaFactor.ICreate;
  };
  export type Body = IHealthcarePlatformUserMfaFactor.ICreate;
  export type Response = IHealthcarePlatformUserMfaFactor;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/systemAdmin/userMfaFactors",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/systemAdmin/userMfaFactors";
  export const random = (): IHealthcarePlatformUserMfaFactor =>
    typia.random<IHealthcarePlatformUserMfaFactor>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list user MFA factors for security and compliance review.
 *
 * Retrieve a list of user MFA factors, supporting complex search, filtering,
 * and pagination on the healthcare_platform_user_mfa_factors table. The
 * operation is available to system administrators and organization
 * administrators for conducting compliance reviews or managing user MFA
 * configurations.
 *
 * Returns paginated data, allowing filtering by factor type, user type,
 * priority, is_active status, and creation/update ranges. The response enables
 * downstream UI and reporting features for security audits. Sensitive
 * credential values are never returned.
 *
 * Security is strictly enforced: only users with admin privileges may list MFA
 * factors, and sensitive credential secrets are always redacted. Large result
 * sets are paginated for scalability and performance. Errors for insufficient
 * permissions or invalid filters return clear, actionable details.
 *
 * @param props.connection
 * @param props.body Query/filter criteria and pagination options for searching
 *   user MFA factors.
 * @path /healthcarePlatform/systemAdmin/userMfaFactors
 * @accessor api.functional.healthcarePlatform.systemAdmin.userMfaFactors.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Query/filter criteria and pagination options for searching user MFA
     * factors.
     */
    body: IHealthcarePlatformUserMfaFactor.IRequest;
  };
  export type Body = IHealthcarePlatformUserMfaFactor.IRequest;
  export type Response = IPageIHealthcarePlatformUserMfaFactor;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/systemAdmin/userMfaFactors",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/systemAdmin/userMfaFactors";
  export const random = (): IPageIHealthcarePlatformUserMfaFactor =>
    typia.random<IPageIHealthcarePlatformUserMfaFactor>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get full detail of a user MFA factor by ID.
 *
 * Retrieve full configuration and metadata for a specific MFA factor record,
 * addressed by userMfaFactorId (UUID primary key) in
 * healthcare_platform_user_mfa_factors. Intended for system or organization
 * admins reviewing MFA history or handling user access issues.
 *
 * Returns factor type, status, creation/update info, and associated user
 * context, never exposing the credential secret. If the record does not exist,
 * a standardized not-found error is returned.
 *
 * Strict RBAC is enforced. Only admins with permitted scope may access details.
 *
 * @param props.connection
 * @param props.userMfaFactorId UUID of the user MFA factor record to retrieve.
 * @path /healthcarePlatform/systemAdmin/userMfaFactors/:userMfaFactorId
 * @accessor api.functional.healthcarePlatform.systemAdmin.userMfaFactors.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the user MFA factor record to retrieve. */
    userMfaFactorId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformUserMfaFactor;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/systemAdmin/userMfaFactors/:userMfaFactorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/userMfaFactors/${encodeURIComponent(props.userMfaFactorId ?? "null")}`;
  export const random = (): IHealthcarePlatformUserMfaFactor =>
    typia.random<IHealthcarePlatformUserMfaFactor>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userMfaFactorId")(() =>
        typia.assert(props.userMfaFactorId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update user MFA factor configuration and settings.
 *
 * Modify an existing user MFA factor record, addressed by userMfaFactorId (UUID
 * primary key). Allows for changes to factor type, value, status, priority, and
 * other configuration due to user request, credential rotation, or compliance
 * enforcement. The operation strictly enforces security rules—redacting
 * secrets, preventing privilege escalation, and allowing only permitted fields
 * for update depending on admin role.
 *
 * On success, returns the updated MFA factor record with masked credential
 * info. Handles not-found errors, insufficient permissions, and business rule
 * violations with clear error responses. All update actions are appended to
 * audit logs for full traceability.
 *
 * @param props.connection
 * @param props.userMfaFactorId UUID of the MFA factor record to update.
 * @param props.body New configuration data for the user MFA factor (type,
 *   status, value, priority).
 * @path /healthcarePlatform/systemAdmin/userMfaFactors/:userMfaFactorId
 * @accessor api.functional.healthcarePlatform.systemAdmin.userMfaFactors.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the MFA factor record to update. */
    userMfaFactorId: string & tags.Format<"uuid">;

    /**
     * New configuration data for the user MFA factor (type, status, value,
     * priority).
     */
    body: IHealthcarePlatformUserMfaFactor.IUpdate;
  };
  export type Body = IHealthcarePlatformUserMfaFactor.IUpdate;
  export type Response = IHealthcarePlatformUserMfaFactor;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/systemAdmin/userMfaFactors/:userMfaFactorId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/systemAdmin/userMfaFactors/${encodeURIComponent(props.userMfaFactorId ?? "null")}`;
  export const random = (): IHealthcarePlatformUserMfaFactor =>
    typia.random<IHealthcarePlatformUserMfaFactor>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userMfaFactorId")(() =>
        typia.assert(props.userMfaFactorId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a user MFA factor by ID from the
 * healthcare_platform_user_mfa_factors table.
 *
 * This API operation is designed to facilitate the permanent deletion of a
 * specific MFA (multi-factor authentication) factor from a user's security
 * profile in the healthcarePlatform system. MFA factors increase login
 * security, and users may have more than one factor registered (such as TOTP
 * apps, SMS numbers, or email codes). When users lose access to one of these
 * factors, switch devices, or an administrator detects a potential security
 * issue, it may be necessary to remove the MFA factor record from the
 * database.
 *
 * Deleting an MFA factor is a sensitive operation requiring audit and
 * authentication. All delete actions should be accompanied by a reason in the
 * audit log and must comply with organizational retention and recovery
 * policies. This deletion is hard (the factor record and its credentials are
 * not recoverable) unless regulatory requirements dictate otherwise. Attempting
 * to delete a non-existent or already-deleted factor should result in an error
 * explaining the missing resource.
 *
 * This endpoint uses the unique UUID identifier userMfaFactorId and will
 * enforce permissions based on the role of the actor and the relationship to
 * the user.
 *
 * Other critical considerations include checking that the factor is not the
 * last active factor for the user when organization policy requires multifactor
 * authentication, and ensuring the operation is performed by an authorized
 * administrator or support user. All actions must be fully auditable as per
 * requirements and schema.
 *
 * @param props.connection
 * @param props.userMfaFactorId Unique identifier for the MFA factor to delete.
 * @path /healthcarePlatform/systemAdmin/userMfaFactors/:userMfaFactorId
 * @accessor api.functional.healthcarePlatform.systemAdmin.userMfaFactors.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier for the MFA factor to delete. */
    userMfaFactorId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/systemAdmin/userMfaFactors/:userMfaFactorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/userMfaFactors/${encodeURIComponent(props.userMfaFactorId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userMfaFactorId")(() =>
        typia.assert(props.userMfaFactorId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
