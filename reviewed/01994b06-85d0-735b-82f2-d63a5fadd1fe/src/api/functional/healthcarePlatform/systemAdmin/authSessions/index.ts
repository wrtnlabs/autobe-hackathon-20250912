import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformAuthSession } from "../../../../structures/IHealthcarePlatformAuthSession";
import { IPageIHealthcarePlatformAuthSession } from "../../../../structures/IPageIHealthcarePlatformAuthSession";

/**
 * Search, paginate, and filter authentication sessions from
 * healthcare_platform_auth_sessions.
 *
 * This endpoint is responsible for advanced session search and monitoring. It
 * operates on the 'healthcare_platform_auth_sessions' table, which tracks
 * issued tokens (JWT/refresh), session state, expiry, revocation info, user
 * agent, and IP address for all resource owners (any user type: systemadmin,
 * orgadmin, doctor, etc).
 *
 * Patch requests allow for provided filters such as user_id, session_token,
 * user_type, status (active, revoked), date ranges (issued_at, expires_at),
 * device fingerprints, and network source (IP). Pagination and sorting options
 * enable navigation through high-volume session data, crucial for operational
 * support and regulatory audit trails.
 *
 * Access is restricted to privileged system administrators due to the
 * sensitivity of session information. All query events must themselves be
 * logged for audit review. Typical use cases include auditing login history,
 * investigating suspicious activity, or forcibly inspecting expired/revoked
 * sessions. Related operations may include detail retrieval or deletion via
 * GET/DELETE on /authSessions/{authSessionId}.
 *
 * @param props.connection
 * @param props.body Session query/search and pagination parameters to filter
 *   list of authentication sessions.
 * @path /healthcarePlatform/systemAdmin/authSessions
 * @accessor api.functional.healthcarePlatform.systemAdmin.authSessions.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Session query/search and pagination parameters to filter list of
     * authentication sessions.
     */
    body: IHealthcarePlatformAuthSession.IRequest;
  };
  export type Body = IHealthcarePlatformAuthSession.IRequest;
  export type Response = IPageIHealthcarePlatformAuthSession.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/systemAdmin/authSessions",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/systemAdmin/authSessions";
  export const random = (): IPageIHealthcarePlatformAuthSession.ISummary =>
    typia.random<IPageIHealthcarePlatformAuthSession.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed information about a specific authentication session by
 * session ID from healthcare_platform_auth_sessions.
 *
 * This endpoint obtains the full metadata for a specific authentication session
 * by its session ID (authSessionId). The 'healthcare_platform_auth_sessions'
 * table records all session-related information, such as session_token,
 * user_id, user_type, revoked_at timestamp for forced terminations, device
 * signature, and IP address (if available).
 *
 * The operation is restricted to system administrators, ensuring only
 * authorized roles may query sensitive session detail. Use cases include
 * confirming whether a session is active or revoked, investigating login from a
 * suspicious device, or reviewing access context for compliance audit.
 *
 * If the session is not found or the ID is malformed or expired, the endpoint
 * must return an error response with appropriate logging for regulatory
 * reviews. This API may be used together with the search or deletion operations
 * for full lifecycle session control.
 *
 * @param props.connection
 * @param props.authSessionId Unique identifier (UUID) for the target
 *   authentication session record.
 * @path /healthcarePlatform/systemAdmin/authSessions/:authSessionId
 * @accessor api.functional.healthcarePlatform.systemAdmin.authSessions.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier (UUID) for the target authentication session
     * record.
     */
    authSessionId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformAuthSession;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/systemAdmin/authSessions/:authSessionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/authSessions/${encodeURIComponent(props.authSessionId ?? "null")}`;
  export const random = (): IHealthcarePlatformAuthSession =>
    typia.random<IHealthcarePlatformAuthSession>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("authSessionId")(() => typia.assert(props.authSessionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete (revoke) a specific authentication session record and immediately
 * terminate access, only permitted for system administrators.
 *
 * This endpoint irrevocably deletes or revokes an authentication session record
 * selected by its authSessionId, targeting entries in the
 * 'healthcare_platform_auth_sessions' table. Each session represents active,
 * expired, or revoked token state for resource owner logins across any user
 * type (systemadmin/orgadmin/doctor/etc.).
 *
 * Session revocation or force deletion is typically used for security
 * enforcement: forcibly logging out users in case of credential compromise,
 * disciplinary action, or as part of account deactivation workflows. Events
 * must be fully auditable for regulatory and incident response requirements.
 *
 * If a non-existent or already-revoked session is specified, the operation
 * should signal a clear error while logging the action for compliance reasons.
 * Related operations include session listing, retrieval, or searching for
 * tokens.
 *
 * This action is always restricted to systemAdmin roles following least
 * privilege policy.
 *
 * @param props.connection
 * @param props.authSessionId Unique identifier (UUID) for the target
 *   authentication session to revoke/delete.
 * @path /healthcarePlatform/systemAdmin/authSessions/:authSessionId
 * @accessor api.functional.healthcarePlatform.systemAdmin.authSessions.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier (UUID) for the target authentication session to
     * revoke/delete.
     */
    authSessionId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/systemAdmin/authSessions/:authSessionId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/authSessions/${encodeURIComponent(props.authSessionId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("authSessionId")(() => typia.assert(props.authSessionId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
