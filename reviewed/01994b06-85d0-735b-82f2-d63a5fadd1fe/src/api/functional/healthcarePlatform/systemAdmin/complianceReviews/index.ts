import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformComplianceReview } from "../../../../structures/IHealthcarePlatformComplianceReview";
import { IPageIHealthcarePlatformComplianceReview } from "../../../../structures/IPageIHealthcarePlatformComplianceReview";

/**
 * Create a new compliance review (healthcare_platform_compliance_reviews
 * table).
 *
 * Create a new compliance review entry to initiate formal audit or compliance
 * review workflows within the healthcare_platform_compliance_reviews table. The
 * operation ensures all required properties are supplied as per schemaâ€”linking
 * to either a legal hold or risk assessment, assigning the reviewer role,
 * providing method and status, and attaching all relevant metadata and initial
 * comments. Only authorized personnel (system or organization admins with
 * compliance privileges) are permitted to use this operation.
 *
 * Security and business rules enforce uniqueness where needed (e.g., only one
 * active compliance review per hold/risk assessment/period), validate reviewer
 * assignments, and capture systematic audit logs for the review's creation.
 * Comprehensive error handling covers domain validation failures and permission
 * issues.
 *
 * Upon successful creation, the complete new compliance review entity is
 * returned, ready for workflow progression and further updates by assigned
 * users.
 *
 * @param props.connection
 * @param props.body Data required to create a new compliance review record,
 *   following the IHealthcarePlatformComplianceReview.ICreate request body
 *   specification.
 * @path /healthcarePlatform/systemAdmin/complianceReviews
 * @accessor api.functional.healthcarePlatform.systemAdmin.complianceReviews.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Data required to create a new compliance review record, following the
     * IHealthcarePlatformComplianceReview.ICreate request body
     * specification.
     */
    body: IHealthcarePlatformComplianceReview.ICreate;
  };
  export type Body = IHealthcarePlatformComplianceReview.ICreate;
  export type Response = IHealthcarePlatformComplianceReview;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/systemAdmin/complianceReviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/systemAdmin/complianceReviews";
  export const random = (): IHealthcarePlatformComplianceReview =>
    typia.random<IHealthcarePlatformComplianceReview>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate compliance review events
 * (healthcare_platform_compliance_reviews).
 *
 * Performs advanced search and retrieval of compliance review records in the
 * healthcarePlatform. This may include reviews for legal holds, risk
 * assessments, periodic audits, regulatory investigations, or internal
 * compliance checks. Users provide a request body specifying complex search
 * filters (review status, type, organization, reviewer, date ranges, outcomes,
 * etc.) and pagination controls.
 *
 * Security: Only users with systemAdmin, organizationAdmin, or
 * compliance-specific roles can access this API. The operation enforces strict
 * filtering to ensure users only see reviews within their organization or
 * department scope. Data is returned in paginated form; each review exposes
 * full audit/compliance metadata.
 *
 * Integration: Often used by compliance teams to aggregate results prior to
 * reporting or regulatory export. Related APIs include legalHold and
 * riskAssessment operations, audit log exports, and notifications for new
 * review findings.
 *
 * @param props.connection
 * @param props.body Search/filter and pagination criteria for compliance review
 *   aggregation.
 * @path /healthcarePlatform/systemAdmin/complianceReviews
 * @accessor api.functional.healthcarePlatform.systemAdmin.complianceReviews.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search/filter and pagination criteria for compliance review
     * aggregation.
     */
    body: IHealthcarePlatformComplianceReview.IRequest;
  };
  export type Body = IHealthcarePlatformComplianceReview.IRequest;
  export type Response = IPageIHealthcarePlatformComplianceReview;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/systemAdmin/complianceReviews",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/healthcarePlatform/systemAdmin/complianceReviews";
  export const random = (): IPageIHealthcarePlatformComplianceReview =>
    typia.random<IPageIHealthcarePlatformComplianceReview>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a compliance review by its ID
 * (healthcare_platform_compliance_reviews table).
 *
 * Retrieve a single compliance review record by its unique identifier from the
 * healthcare_platform_compliance_reviews table. This operation is intended for
 * users such as compliance officers, organization admins, or assigned reviewers
 * who need full visibility into a particular compliance review's metadata,
 * method, scope, status, and audit trail linkage.
 *
 * Security controls require that the operation is only accessible to users with
 * explicit audit, compliance, or administrative permissions. Every access is
 * logged for traceability and compliance monitoring according to HIPAA and
 * internal audit standards. All fields returned reflect the underlying Prisma
 * schema for the compliance review entity, ensuring that sensitive notes and
 * recommendations are properly presented based on the user's authorization and
 * organizational context.
 *
 * This operation is expected to be used in conjunction with listing endpoints
 * (for browsing reviews) and workflow endpoints (for progressing the review's
 * lifecycle). When the requested record is not found or the caller lacks
 * sufficient permissions, an appropriate error message and audit event are
 * generated.
 *
 * @param props.connection
 * @param props.complianceReviewId Unique identifier (UUID) of the compliance
 *   review record to retrieve.
 * @path /healthcarePlatform/systemAdmin/complianceReviews/:complianceReviewId
 * @accessor api.functional.healthcarePlatform.systemAdmin.complianceReviews.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the compliance review record to retrieve. */
    complianceReviewId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformComplianceReview;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/systemAdmin/complianceReviews/:complianceReviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/complianceReviews/${encodeURIComponent(props.complianceReviewId ?? "null")}`;
  export const random = (): IHealthcarePlatformComplianceReview =>
    typia.random<IHealthcarePlatformComplianceReview>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("complianceReviewId")(() =>
        typia.assert(props.complianceReviewId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a compliance review record by its ID
 * (healthcare_platform_compliance_reviews table).
 *
 * Update the details of an existing compliance review. This operation is
 * intended for compliance staff, administrators, or assigned reviewers who need
 * to progress a review's workflow, finalize status, document outcome, or add
 * recommendations based on new information.
 *
 * Strong validation logic is applied: only fields permitted by the record's
 * current lifecycle status may be updated, and changes are constrained to avoid
 * accidental loss of regulatory or audit-critical data. Each update triggers a
 * new audit log entry, and all field changes are captured with timestamps.
 *
 * Operation errors include validation for immutable or restricted fields,
 * permission checks, and UUID-based record not-found scenarios.
 *
 * @param props.connection
 * @param props.complianceReviewId Unique identifier (UUID) of the compliance
 *   review record to update.
 * @param props.body Fields to update in the compliance review record, following
 *   IHealthcarePlatformComplianceReview.IUpdate specification.
 * @path /healthcarePlatform/systemAdmin/complianceReviews/:complianceReviewId
 * @accessor api.functional.healthcarePlatform.systemAdmin.complianceReviews.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier (UUID) of the compliance review record to update. */
    complianceReviewId: string & tags.Format<"uuid">;

    /**
     * Fields to update in the compliance review record, following
     * IHealthcarePlatformComplianceReview.IUpdate specification.
     */
    body: IHealthcarePlatformComplianceReview.IUpdate;
  };
  export type Body = IHealthcarePlatformComplianceReview.IUpdate;
  export type Response = IHealthcarePlatformComplianceReview;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/systemAdmin/complianceReviews/:complianceReviewId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/systemAdmin/complianceReviews/${encodeURIComponent(props.complianceReviewId ?? "null")}`;
  export const random = (): IHealthcarePlatformComplianceReview =>
    typia.random<IHealthcarePlatformComplianceReview>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("complianceReviewId")(() =>
        typia.assert(props.complianceReviewId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Erase (soft delete) a compliance review record by ID
 * (healthcare_platform_compliance_reviews table).
 *
 * Soft delete (erase) a compliance review by its unique identifier (UUID). The
 * operation marks the compliance review record as deleted by setting its
 * deleted_at field, without actually removing it from the database. This design
 * aligns with regulatory and audit requirements for data retention and review,
 * ensuring that soft-deleted records remain available for audit but are hidden
 * from standard lists and UIs.
 *
 * The erasure is only permitted for users with explicit
 * administrative/compliance privileges, and every deletion event is logged for
 * compliance review. Soft deleted records can be restored if policy allows, but
 * generally cannot be erased permanently except by explicit compliance
 * processes. Errors generated include non-existent records, lack of sufficient
 * privilege, or attempts to delete reviews that are locked for active legal or
 * regulatory action.
 *
 * @param props.connection
 * @param props.complianceReviewId Unique identifier (UUID) of the compliance
 *   review record to erase (soft delete).
 * @path /healthcarePlatform/systemAdmin/complianceReviews/:complianceReviewId
 * @accessor api.functional.healthcarePlatform.systemAdmin.complianceReviews.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier (UUID) of the compliance review record to erase
     * (soft delete).
     */
    complianceReviewId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/systemAdmin/complianceReviews/:complianceReviewId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/complianceReviews/${encodeURIComponent(props.complianceReviewId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("complianceReviewId")(() =>
        typia.assert(props.complianceReviewId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
