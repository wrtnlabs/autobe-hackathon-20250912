import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformOrganizationAdmin } from "../../../../structures/IHealthcarePlatformOrganizationAdmin";
import { IPageIHealthcarePlatformOrganizationadmin } from "../../../../structures/IPageIHealthcarePlatformOrganizationadmin";

/**
 * Create a new Organization Admin user account in the
 * healthcare_platform_organizationadmins table.
 *
 * Use this operation to create a new Organization Admin user within the
 * healthcarePlatform system. It inserts a fresh record into
 * healthcare_platform_organizationadmins, assigning required identity, contact,
 * and status fields. Organization Admins are responsible for managing their
 * organization's users, policies, billing, reporting, and compliance
 * operations.
 *
 * The request body must provide a business email, full name, and other required
 * fields as specified in the schema. Optional fields such as phone can also be
 * included. The endpoint enforces uniqueness of email and legal full name as
 * per healthcarePlatform business policies. On successful creation, a new
 * record is returned representing the newly onboarded Organization Admin user.
 *
 * Caller must be a System Admin (or possess equivalent permissions), as
 * OrgAdmin creation is a sensitive platform operation. Input validation, audit
 * logging, and user notification flows are all triggered. Errors are returned
 * on uniqueness violation, invalid input, or insufficient authorization.
 *
 * This operation is designed to be part of onboarding, role assignment, and
 * multi-tenant configuration workflows. It is complemented by search, read,
 * update, and erase endpoints for full organization admin lifecycle management.
 * System-level audit and compliance requirements are enforced for all creation
 * actions.
 *
 * @param props.connection
 * @param props.body Account creation details for new Organization Admin user.
 * @path /healthcarePlatform/systemAdmin/organizationadmins
 * @accessor api.functional.healthcarePlatform.systemAdmin.organizationadmins.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Account creation details for new Organization Admin user. */
    body: IHealthcarePlatformOrganizationAdmin.ICreate;
  };
  export type Body = IHealthcarePlatformOrganizationAdmin.ICreate;
  export type Response = IHealthcarePlatformOrganizationAdmin;

  export const METADATA = {
    method: "POST",
    path: "/healthcarePlatform/systemAdmin/organizationadmins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/systemAdmin/organizationadmins";
  export const random = (): IHealthcarePlatformOrganizationAdmin =>
    typia.random<IHealthcarePlatformOrganizationAdmin>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve Organization Admin user records with advanced filtering
 * and pagination.
 *
 * Use this operation to retrieve a filtered, paginated list of Organization
 * Admin accounts within the healthcarePlatform system. This enables global and
 * system administrators to locate, audit, or manage organziational admins,
 * supporting scenarios such as compliance review and bulk updates.
 *
 * The healthcare_platform_organizationadmins schema tracks the identity,
 * contact, and status of each organization admin. Filters available include
 * full name, email, account status, and date range. Results can be sorted and
 * paginated for scalability. Sensitive fields and audit references are
 * protected based on caller's role/privileges.
 *
 * Security rules restrict access to high-privilege roles, ensuring that only
 * authorized actors with platform-wide or compliance responsibilities can
 * request this data. The endpoint supports complex search requirements but does
 * not expose raw credentials or unrelated organizational context details.
 *
 * Error handling ensures invalid filters, pagination errors, or misuse will be
 * rejected with clear feedback. The operation is typically used in conjunction
 * with user detail retrieval and account management endpoints, providing an
 * efficient backbone for administrative workflows.
 *
 * @param props.connection
 * @param props.body Filter, pagination, and sorting criteria for Organization
 *   Admin search queries.
 * @path /healthcarePlatform/systemAdmin/organizationadmins
 * @accessor api.functional.healthcarePlatform.systemAdmin.organizationadmins.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filter, pagination, and sorting criteria for Organization Admin
     * search queries.
     */
    body: IHealthcarePlatformOrganizationAdmin.IRequest;
  };
  export type Body = IHealthcarePlatformOrganizationAdmin.IRequest;
  export type Response = IPageIHealthcarePlatformOrganizationadmin.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/systemAdmin/organizationadmins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () =>
    "/healthcarePlatform/systemAdmin/organizationadmins";
  export const random =
    (): IPageIHealthcarePlatformOrganizationadmin.ISummary =>
      typia.random<IPageIHealthcarePlatformOrganizationadmin.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed profile for specific Organization Admin by
 * organizationAdminId.
 *
 * This API returns the detailed profile of a single Organization Admin account
 * from the healthcarePlatform system, including display name, email, status,
 * and contact information. It is based on the
 * healthcare_platform_organizationadmins schema, which governs
 * organization-specific admin users responsible for staff, compliance, billing,
 * and reporting management.
 *
 * Authorization is restricted to privileged roles with business or compliance
 * need. The account is looked up by organizationAdminId (UUID). All returned
 * data respects platform privacy and audit constraints and omits sensitive
 * credential information.
 *
 * The endpoint throws errors for invalid, deleted, or non-existent
 * organizationAdminId records, and is designed to complement organization admin
 * search, creation, and update endpoints. Used in administrative UIs and
 * automated audit/compliance workflows.
 *
 * @param props.connection
 * @param props.organizationAdminId Unique identifier (UUID) of the Organization
 *   Admin user to retrieve.
 * @path /healthcarePlatform/systemAdmin/organizationadmins/:organizationAdminId
 * @accessor api.functional.healthcarePlatform.systemAdmin.organizationadmins.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the Organization Admin user to retrieve. */
    organizationAdminId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformOrganizationAdmin;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/systemAdmin/organizationadmins/:organizationAdminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/organizationadmins/${encodeURIComponent(props.organizationAdminId ?? "null")}`;
  export const random = (): IHealthcarePlatformOrganizationAdmin =>
    typia.random<IHealthcarePlatformOrganizationAdmin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("organizationAdminId")(() =>
        typia.assert(props.organizationAdminId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an organization administrator (healthcare_platform_organizationadmins)
 * record by its ID.
 *
 * Updates a specific organization administrator's information, including their
 * full legal name, business email, and phone number as stored in the
 * 'healthcare_platform_organizationadmins' table. This operation is subject to
 * strict audit trails and can only be performed by users with suitable
 * privileges within the healthcare organization.
 *
 * On successful update, the response includes all current record fields and
 * verification of the changes. The operation logs the update timestamp and
 * ensures all business compliance workflows related to administrator updates
 * are followed.
 *
 * Validation checks include email uniqueness, required fields, and enforcement
 * of business logic for organization admin privileges. Conflict or access
 * errors return clear business-oriented error messages. Only fields existent in
 * the schema are used or returned. The update can only be performed if the
 * record is not marked as deleted (soft-deleted).
 *
 * @param props.connection
 * @param props.organizationAdminId The unique identifier (UUID) of the
 *   organization administrator to update.
 * @param props.body Payload containing updatable fields for the organization
 *   admin, such as full_name, email, phone.
 * @path /healthcarePlatform/systemAdmin/organizationadmins/:organizationAdminId
 * @accessor api.functional.healthcarePlatform.systemAdmin.organizationadmins.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * The unique identifier (UUID) of the organization administrator to
     * update.
     */
    organizationAdminId: string & tags.Format<"uuid">;

    /**
     * Payload containing updatable fields for the organization admin, such
     * as full_name, email, phone.
     */
    body: IHealthcarePlatformOrganizationAdmin.IUpdate;
  };
  export type Body = IHealthcarePlatformOrganizationAdmin.IUpdate;
  export type Response = IHealthcarePlatformOrganizationAdmin;

  export const METADATA = {
    method: "PUT",
    path: "/healthcarePlatform/systemAdmin/organizationadmins/:organizationAdminId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/systemAdmin/organizationadmins/${encodeURIComponent(props.organizationAdminId ?? "null")}`;
  export const random = (): IHealthcarePlatformOrganizationAdmin =>
    typia.random<IHealthcarePlatformOrganizationAdmin>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("organizationAdminId")(() =>
        typia.assert(props.organizationAdminId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Erase (hard-delete) an organization administrator by ID
 * (healthcare_platform_organizationadmins).
 *
 * Permanently removes the specified organization admin entry from the database,
 * fully erasing associated administrator details. Access is restricted to
 * system or organization administrators with the highest level permissions in
 * the healthcarePlatform.
 *
 * Upon completion, the operation ensures the record can no longer be referenced
 * or recovered and initiates a platform-wide audit log event. All access
 * constraints and dependencies must be resolved before deletion. If the
 * specified record is missing, already deleted, or protected by policy (active
 * assignments or investigatory lock), the operation returns clear error
 * messages.
 *
 * No soft-deletion is performed for this operation, and care should be taken to
 * comply with security and privacy best practices, including audit compliance
 * for privileged actor actions.
 *
 * @param props.connection
 * @param props.organizationAdminId The unique identifier (UUID) of the
 *   organization administrator to erase.
 * @path /healthcarePlatform/systemAdmin/organizationadmins/:organizationAdminId
 * @accessor api.functional.healthcarePlatform.systemAdmin.organizationadmins.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * The unique identifier (UUID) of the organization administrator to
     * erase.
     */
    organizationAdminId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/healthcarePlatform/systemAdmin/organizationadmins/:organizationAdminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/organizationadmins/${encodeURIComponent(props.organizationAdminId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("organizationAdminId")(() =>
        typia.assert(props.organizationAdminId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
