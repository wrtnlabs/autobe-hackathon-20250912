import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformRecordAuditTrail } from "../../../../../structures/IHealthcarePlatformRecordAuditTrail";
import { IPageIHealthcarePlatformRecordAuditTrail } from "../../../../../structures/IPageIHealthcarePlatformRecordAuditTrail";

/**
 * Search and retrieve a filtered, paginated list of audit trail entries for a
 * specific patient record (healthcare_platform_record_audit_trails table).
 *
 * This endpoint allows authorized users (typically compliance officers, admins,
 * or clinicians with audit privilege) to search and review audit trail entries
 * for a given patient record identified by patientRecordId. It operates on the
 * healthcare_platform_record_audit_trails table.
 *
 * Search parameters, pagination, and sorting options can be provided in the
 * request body, following the IHealthcarePlatformRecordAuditTrail.IRequest DTO
 * contract, to enable targeted review of events such as access, updates,
 * lock/unlock, deletions, and emergency overrides. All access to this endpoint
 * should itself be recorded for full traceability.
 *
 * Results are returned in a paginated format, type
 * IPageIHealthcarePlatformRecordAuditTrail, including event metadata for each
 * entry. Business logic must ensure only users with sufficient privileges and
 * organizational scope may execute this operation, and sensitive details are
 * redacted in accordance with legal audit requirements. Related APIs include
 * single entry lookups and actions on recordAmendments and recordLocks.
 *
 * @param props.connection
 * @param props.patientRecordId Unique identifier of the patient record whose
 *   audit trail is being queried (UUID).
 * @param props.body Search and pagination criteria for filtering patient record
 *   audit logs.
 * @path /healthcarePlatform/systemAdmin/patientRecords/:patientRecordId/recordAuditTrails
 * @accessor api.functional.healthcarePlatform.systemAdmin.patientRecords.recordAuditTrails.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Unique identifier of the patient record whose audit trail is being
     * queried (UUID).
     */
    patientRecordId: string & tags.Format<"uuid">;

    /**
     * Search and pagination criteria for filtering patient record audit
     * logs.
     */
    body: IHealthcarePlatformRecordAuditTrail.IRequest;
  };
  export type Body = IHealthcarePlatformRecordAuditTrail.IRequest;
  export type Response = IPageIHealthcarePlatformRecordAuditTrail;

  export const METADATA = {
    method: "PATCH",
    path: "/healthcarePlatform/systemAdmin/patientRecords/:patientRecordId/recordAuditTrails",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/healthcarePlatform/systemAdmin/patientRecords/${encodeURIComponent(props.patientRecordId ?? "null")}/recordAuditTrails`;
  export const random = (): IPageIHealthcarePlatformRecordAuditTrail =>
    typia.random<IPageIHealthcarePlatformRecordAuditTrail>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientRecordId")(() =>
        typia.assert(props.patientRecordId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detailed single audit log entry for a patient record
 * (healthcare_platform_record_audit_trails table).
 *
 * This endpoint allows authorized administrative or compliance personnel to
 * view details for a single patient-related audit log entry identified by
 * recordAuditTrailId under a given patient record (patientRecordId). The
 * healthcare_platform_record_audit_trails table provides comprehensive,
 * immutable forensic logging of actions (access, update, lock/unlock, etc.) on
 * medical records.
 *
 * The endpoint enforces strict permission checks, returning all permitted
 * details about the audited event, supporting legal investigation and security
 * monitoring workflows. If the recordAuditTrailId does not exist or the
 * requesting user lacks sufficient privilege, a not-found or unauthorized error
 * is returned, with all access attempts logged for regulatory compliance.
 * Typical use cases include confirming compliance actions, investigating
 * suspicious events, or generating legal reports.
 *
 * @param props.connection
 * @param props.patientRecordId Unique identifier of the patient record with the
 *   audit trail entry (UUID).
 * @param props.recordAuditTrailId Unique identifier of the audit trail entry
 *   (UUID).
 * @path /healthcarePlatform/systemAdmin/patientRecords/:patientRecordId/recordAuditTrails/:recordAuditTrailId
 * @accessor api.functional.healthcarePlatform.systemAdmin.patientRecords.recordAuditTrails.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the patient record with the audit trail entry
     * (UUID).
     */
    patientRecordId: string & tags.Format<"uuid">;

    /** Unique identifier of the audit trail entry (UUID). */
    recordAuditTrailId: string & tags.Format<"uuid">;
  };
  export type Response = IHealthcarePlatformRecordAuditTrail;

  export const METADATA = {
    method: "GET",
    path: "/healthcarePlatform/systemAdmin/patientRecords/:patientRecordId/recordAuditTrails/:recordAuditTrailId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/healthcarePlatform/systemAdmin/patientRecords/${encodeURIComponent(props.patientRecordId ?? "null")}/recordAuditTrails/${encodeURIComponent(props.recordAuditTrailId ?? "null")}`;
  export const random = (): IHealthcarePlatformRecordAuditTrail =>
    typia.random<IHealthcarePlatformRecordAuditTrail>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("patientRecordId")(() =>
        typia.assert(props.patientRecordId),
      );
      assert.param("recordAuditTrailId")(() =>
        typia.assert(props.recordAuditTrailId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
