import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformNurse } from "../../../structures/IHealthcarePlatformNurse";

/**
 * Register a new nurse account and issue authentication tokens (relates to
 * healthcare_platform_nurses Prisma table).
 *
 * This API endpoint allows the registration of a nurse (clinical staff) user
 * within the healthcarePlatform service. The operation is based on the
 * healthcare_platform_nurses Prisma model, which includes fields such as email
 * (unique business email), full_name (legal name), phone (optional contact
 * number), created_at, updated_at, and deleted_at for soft deletion. Upon
 * successful registration, a new nurse record is created and initial
 * authentication tokens (JWT) are provided.
 *
 * This endpoint strictly enforces the uniqueness of the nurse's email and
 * ensures essential fields are captured, with timestamps for regulatory
 * compliance. Immediately after creation, the nurse receives an access token
 * and refresh token for system login and workflow participation, utilizing the
 * available fields within the nurse schema. The process reflects organizational
 * policy for nurse onboarding and handed-off assignment to departments or
 * organizations is tracked via separate assignment tables and not handled
 * directly here.
 *
 * Security considerations include validation that the provided email is
 * business-eligible and does not collide with existing active nurse accounts.
 * The password or credential is managed per organizationâ€™s policy and may be
 * provisioned at a later step, but must correspond to nurse schema fields and
 * not infer non-existent schema attributes. Permission grants are automatic for
 * the nurse role as defined in RBAC, constrained by Prisma schema enforcement.
 *
 * Other operations that may be needed in the nurse onboarding process (e.g.,
 * license verification, department assignment) are handled by separate APIs.
 * This join endpoint is exclusively for creating the initial nurse account;
 * audit, update, and deletion flows are not in scope here but are enforced via
 * soft deletion using the deleted_at column.
 *
 * Expected behavior and error handling includes clear messaging on duplicate
 * email, required field omission, and processing of business logic errors.
 * Related authentication operations such as login and token refresh are
 * separately implemented, and profile management is handled via the nurse
 * update endpoint.
 *
 * @param props.connection
 * @param props.body Payload required for nurse registration including fields
 *   email, full_name, phone (if present) referencing nurse schema.
 * @setHeader token.access Authorization
 *
 * @path /auth/nurse/join
 * @accessor api.functional.auth.nurse.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Payload required for nurse registration including fields email,
     * full_name, phone (if present) referencing nurse schema.
     */
    body: IHealthcarePlatformNurse.IJoin;
  };
  export type Body = IHealthcarePlatformNurse.IJoin;
  export type Response = IHealthcarePlatformNurse.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/nurse/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/nurse/join";
  export const random = (): IHealthcarePlatformNurse.IAuthorized =>
    typia.random<IHealthcarePlatformNurse.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate nurse user and issue tokens using nurse schema and
 * authentication record (healthcare_platform_nurses).
 *
 * This API operation allows a nurse (clinical staff) user to log in to the
 * healthcarePlatform system and receive authentication tokens. Login is
 * performed using fields defined in the healthcare_platform_nurses and
 * healthcare_platform_user_authentications tables (email for username,
 * credential fields managed in the linked user authentication table). The
 * operation enforces that only active nurses (deleted_at is null) with valid
 * authentication credentials can login, referencing real Prisma schema fields
 * only.
 *
 * Implementation details include validation of the nurse's email via the Prisma
 * model and matching of submitted credentials via the user authentication
 * provider, referencing the provider (local, SSO, etc.) and provider key. JWT
 * and refresh tokens are issued for use in subsequent authenticated workflows
 * and permissioned operations, linking session context to the authenticated
 * nurse record. The nurse's record status and account creation/updates are
 * reflected as per schema.
 *
 * Business context reflects that nurse logins must be fully auditable and
 * comply with all organizational login policy regarding credential validity,
 * unique user identity, and regulatory audit requirements. Login attempts
 * against soft-deleted (deleted_at not null) or invalidated accounts are denied
 * with explicit error reporting, and failed attempt outcomes are tracked
 * externally for security.
 *
 * Security considerations are driven by compliance, ensuring that no
 * non-existent schema fields (such as non-configured multi-factor
 * authentication) are referenced. Token expiry, revocation, and related
 * credential handling are deferred to session/token lifecycle operations. Audit
 * trails are enforced via companion audit table entries in the broader
 * enterprise system.
 *
 * Related operations include registration (join), token refresh, and password
 * reset (if available), which are separated per schema constraints. This
 * endpoint does NOT implement MFA by default; password resets, recovery, or
 * device binding are handled by other endpoints when fields exist.
 *
 * @param props.connection
 * @param props.body Login payload referencing nurse email/credential fields as
 *   in nurse schema and authentication table.
 * @setHeader token.access Authorization
 *
 * @path /auth/nurse/login
 * @accessor api.functional.auth.nurse.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Login payload referencing nurse email/credential fields as in nurse
     * schema and authentication table.
     */
    body: IHealthcarePlatformNurse.ILogin;
  };
  export type Body = IHealthcarePlatformNurse.ILogin;
  export type Response = IHealthcarePlatformNurse.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/nurse/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/nurse/login";
  export const random = (): IHealthcarePlatformNurse.IAuthorized =>
    typia.random<IHealthcarePlatformNurse.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh nurse authentication session (issue new JWTs) using nurse schema and
 * session token (healthcare_platform_nurses,
 * healthcare_platform_auth_sessions).
 *
 * This API operation refreshes an existing authenticated session for a nurse
 * (clinical staff user), returning new JWT and refresh tokens for continued
 * authenticated access to the healthcarePlatform system. The operation
 * references healthcare_platform_nurses (for nurse user context) and
 * healthcare_platform_auth_sessions (for refresh token lifecycle and audit),
 * verifying that the provided refresh token corresponds to an active nurse
 * account (deleted_at is null) per the Prisma schema.
 *
 * The implementation checks the validity and expiry of the refresh token using
 * only fields from the auth_sessions schema, performing error reporting for
 * invalid or mismapped tokens. If validation succeeds, it issues new tokens and
 * returns the latest nurse descriptor, reflecting updated fields as per schema
 * (created_at, updated_at, etc.). Token refresh is required for long-running or
 * session-limited workflows as per business rule, but does not alter or update
 * underlying nurse user records or audit logs directly here.
 *
 * This endpoint integrates with the overall authentication workflow for nurse
 * users, enabling continued secure access without forcing re-login (as long as
 * the session is valid and user is not soft-deleted). Successful flows are
 * fully covered by current schema; failed or expired refresh operations are
 * explicitly denied, referencing only those schema fields that exist.
 *
 * Security and audit logic is managed by other infrastructure; this endpoint
 * does not add fields or logic for session termination or multi-device
 * handling. Token lifetimes, audit events, and nurse user attribute integrity
 * are covered by external workflows. Soft-delete (deleted_at) status must be
 * null for account to be eligible for token refresh.
 *
 * Related authentication operations for session management, login, or password
 * reset (if implemented) are handled via separate endpoints, as per schema
 * fields.
 *
 * @param props.connection
 * @param props.body Refresh token request referencing nurse session and refresh
 *   token fields only.
 * @setHeader token.access Authorization
 *
 * @path /auth/nurse/refresh
 * @accessor api.functional.auth.nurse.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token request referencing nurse session and refresh token
     * fields only.
     */
    body: IHealthcarePlatformNurse.IRefresh;
  };
  export type Body = IHealthcarePlatformNurse.IRefresh;
  export type Response = IHealthcarePlatformNurse.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/nurse/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/nurse/refresh";
  export const random = (): IHealthcarePlatformNurse.IAuthorized =>
    typia.random<IHealthcarePlatformNurse.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
