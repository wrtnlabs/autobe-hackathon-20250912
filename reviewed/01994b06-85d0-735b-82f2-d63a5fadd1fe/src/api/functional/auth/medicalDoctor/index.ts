import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IHealthcarePlatformMedicalDoctor } from "../../../structures/IHealthcarePlatformMedicalDoctor";

/**
 * Create/register new medical doctor account and issue initial tokens
 * (healthcare_platform_medicaldoctors).
 *
 * Registers a new licensed medical doctor as a system user, validates all
 * provided business credentials (email and NPI number), and issues an initial
 * set of JWT access and refresh tokens for secure platform access. The
 * registration process records audit events, creates a user record in
 * 'healthcare_platform_medicaldoctors', and triggers credential verification
 * and compliance workflows. Only doctors with valid, unique business email and
 * NPI are onboarded; errors trigger actionable client feedback per business
 * rules. All operation details and constraints are derived from the Prisma
 * schema and business requirements for healthcare member roles.
 *
 * @param props.connection
 * @param props.body Doctor registration/credential data for onboarding.
 * @setHeader token.access Authorization
 *
 * @path /auth/medicalDoctor/join
 * @accessor api.functional.auth.medicalDoctor.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Doctor registration/credential data for onboarding. */
    body: IHealthcarePlatformMedicalDoctor.IJoin;
  };
  export type Body = IHealthcarePlatformMedicalDoctor.IJoin;
  export type Response = IHealthcarePlatformMedicalDoctor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/medicalDoctor/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/medicalDoctor/join";
  export const random = (): IHealthcarePlatformMedicalDoctor.IAuthorized =>
    typia.random<IHealthcarePlatformMedicalDoctor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate/login (issue tokens) for a medical doctor
 * (healthcare_platform_medicaldoctors).
 *
 * Authenticates a registered medical doctor by verifying provided email and
 * password credentials against the 'healthcare_platform_medicaldoctors' schema
 * (ensuring the doctor account is active, email matches, and password hash is
 * valid). On success, issues new JWT tokens and records all required login
 * audit events. Returns access/refresh tokens using DTO response specification.
 * Errors include invalid credentials, suspended accounts, or failed compliance
 * checks. This operation forms part of the strict member login flow documented
 * for the healthcarePlatform medical role.
 *
 * @param props.connection
 * @param props.body Login credentials for doctor authentication (email,
 *   password).
 * @setHeader token.access Authorization
 *
 * @path /auth/medicalDoctor/login
 * @accessor api.functional.auth.medicalDoctor.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login credentials for doctor authentication (email, password). */
    body: IHealthcarePlatformMedicalDoctor.ILogin;
  };
  export type Body = IHealthcarePlatformMedicalDoctor.ILogin;
  export type Response = IHealthcarePlatformMedicalDoctor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/medicalDoctor/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/medicalDoctor/login";
  export const random = (): IHealthcarePlatformMedicalDoctor.IAuthorized =>
    typia.random<IHealthcarePlatformMedicalDoctor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT tokens for medical doctor session
 * (healthcare_platform_auth_sessions).
 *
 * Allows an authenticated medical doctor to exchange a valid and unexpired
 * refresh token for a new pair of JWT tokens, prolonging authenticated platform
 * access. The Prisma database table 'healthcare_platform_auth_sessions' is used
 * to validate token status, assignment, and session context before issuing new
 * tokens. Operation records audit logs for compliance. This endpoint is
 * fundamental to secure session management for the doctor/member role within
 * the healthcarePlatform system. Errors are returned for invalid, expired, or
 * revoked tokens.
 *
 * @param props.connection
 * @param props.body Request a new session using an authorized refresh token.
 * @setHeader token.access Authorization
 *
 * @path /auth/medicalDoctor/refresh
 * @accessor api.functional.auth.medicalDoctor.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Request a new session using an authorized refresh token. */
    body: IHealthcarePlatformMedicalDoctor.IRefresh;
  };
  export type Body = IHealthcarePlatformMedicalDoctor.IRefresh;
  export type Response = IHealthcarePlatformMedicalDoctor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/medicalDoctor/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/medicalDoctor/refresh";
  export const random = (): IHealthcarePlatformMedicalDoctor.IAuthorized =>
    typia.random<IHealthcarePlatformMedicalDoctor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
