import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { posthealthcarePlatformSystemAdminUserCredentials } from "../../../../providers/posthealthcarePlatformSystemAdminUserCredentials";
import { SystemadminAuth } from "../../../../decorators/SystemadminAuth";
import { SystemadminPayload } from "../../../../decorators/payload/SystemadminPayload";
import { patchhealthcarePlatformSystemAdminUserCredentials } from "../../../../providers/patchhealthcarePlatformSystemAdminUserCredentials";
import { gethealthcarePlatformSystemAdminUserCredentialsUserCredentialId } from "../../../../providers/gethealthcarePlatformSystemAdminUserCredentialsUserCredentialId";
import { puthealthcarePlatformSystemAdminUserCredentialsUserCredentialId } from "../../../../providers/puthealthcarePlatformSystemAdminUserCredentialsUserCredentialId";
import { deletehealthcarePlatformSystemAdminUserCredentialsUserCredentialId } from "../../../../providers/deletehealthcarePlatformSystemAdminUserCredentialsUserCredentialId";

import { IHealthcarePlatformUserCredential } from "../../../../api/structures/IHealthcarePlatformUserCredential";
import { IPageIHealthcarePlatformUserCredential } from "../../../../api/structures/IPageIHealthcarePlatformUserCredential";

@Controller("/healthcarePlatform/systemAdmin/userCredentials")
export class HealthcareplatformSystemadminUsercredentialsController {
  /**
   * Archive a new user credential value record in the
   * healthcare_platform_user_credentials table.
   *
   * This operation allows system or organization administrators to archive a
   * new credential for any user or actor covered by the healthcarePlatform's
   * authentication system. The request captures user_id, user_type
   * (systemAdmin, orgAdmin, etc.), credential_type (password, sso, certificate,
   * webauthn, etc.), credential_hash (the credential value, typically hashed),
   * and relevant timestamps.
   *
   * Archiving user credentials supports regulatory mandates, SSO rotation
   * policies, and password reuse prevention. Credential archive entries are
   * append-only and must never be edited after creation. Sensitive values, such
   * as credential_hash, must be handled securely; cleartext must never be
   * allowed. All creation events are logged to the audit trail for security and
   * compliance needs.
   *
   * Attempting to create a credential archive entry for a non-existent or
   * unauthorized user must result in a compliance-audited error. Only
   * authorized systemAdmin or organizationAdmin roles should be allowed to use
   * this endpoint.
   *
   * @param connection
   * @param body Credential record including user_id, credential type, and
   *   credential hash.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @SystemadminAuth()
    systemAdmin: SystemadminPayload,
    @TypedBody()
    body: IHealthcarePlatformUserCredential.ICreate,
  ): Promise<IHealthcarePlatformUserCredential> {
    try {
      return await posthealthcarePlatformSystemAdminUserCredentials({
        systemAdmin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and paginate archived user credential records in the
   * healthcare_platform_user_credentials table (hashes never exposed).
   *
   * This operation allows authorized system or organization administrators to
   * perform an advanced query over the user credential history stored in the
   * healthcare_platform_user_credentials table. These records support
   * compliance, regulatory, and incident response audits and should never
   * contain or expose sensitive credential material such as hashes. Any
   * returned record must omit credential_hash fields, and access is strictly
   * limited to privileged administrative roles. Non-authorized access attempts
   * should be denied and tracked in the system's audit log. This operation is
   * crucial for meeting HIPAA, SOC 2, and organizational audit requirements,
   * with a focus on security and auditability.
   *
   * @param connection
   * @param body Filter and pagination options for searching archived user
   *   credentials.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @SystemadminAuth()
    systemAdmin: SystemadminPayload,
    @TypedBody()
    body: IHealthcarePlatformUserCredential.IRequest,
  ): Promise<IPageIHealthcarePlatformUserCredential.ISummary> {
    try {
      return await patchhealthcarePlatformSystemAdminUserCredentials({
        systemAdmin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Retrieve details of an archived user credential entry by its ID from the
   * healthcare_platform_user_credentials table. Never expose hashes in API
   * responses.
   *
   * This operation provides secure, role-restricted access to an individual
   * archived user credential entry in the healthcare_platform_user_credentials
   * table, identified by userCredentialId (UUID). Credential archives support
   * security, compliance, and rollback workflows; API consumers must never
   * receive sensitive credential_hash fields in any response. This endpoint is
   * for use by administrative and security audit roles only, and all operations
   * must be logged for compliance. Unauthorized or inappropriate access
   * attempts should be denied with audit warning.
   *
   * @param connection
   * @param userCredentialId Unique identifier for the archived user credential
   *   record to retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":userCredentialId")
  public async at(
    @SystemadminAuth()
    systemAdmin: SystemadminPayload,
    @TypedParam("userCredentialId")
    userCredentialId: string & tags.Format<"uuid">,
  ): Promise<IHealthcarePlatformUserCredential> {
    try {
      return await gethealthcarePlatformSystemAdminUserCredentialsUserCredentialId(
        {
          systemAdmin,
          userCredentialId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an archived user credential record in the
   * healthcarePlatform_user_credentials table.
   *
   * Update a user's credential archive record in the healthcarePlatform. This
   * operation targets the healthcare_platform_user_credentials table and is
   * intended for occasions such as password or SSO credential rotation,
   * archival, or roll-forward. Each credential record retains its type,
   * credential hash (not active hash), archive timestamps, and relevant
   * metadata.
   *
   * Only authorized system administrators should perform this update. Updated
   * fields must adhere strictly to security and compliance standards, and every
   * update is logged for audit purposes. This API must enforce that only
   * archived (not currently active) credential records are updated.
   *
   * Updates must validate the credential type and ensure the new value meets
   * application constraints (e.g., password hash structure if used, or external
   * SSO details for SSO-type credentials). Related endpoints for credential
   * history retrieval or credential creation may be referenced to ensure proper
   * workflow integration. Any errors encountered—such as attempts to update an
   * active credential, submit an invalid type, or violate audit trace
   * requirements—must be clearly detailed and rejected by the endpoint with
   * audit events triggered.
   *
   * @param connection
   * @param userCredentialId Unique identifier for the user credential record to
   *   update (UUID in healthcare_platform_user_credentials)
   * @param body Updated credential information for the target user credential
   *   record.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":userCredentialId")
  public async update(
    @SystemadminAuth()
    systemAdmin: SystemadminPayload,
    @TypedParam("userCredentialId")
    userCredentialId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IHealthcarePlatformUserCredential.IUpdate,
  ): Promise<IHealthcarePlatformUserCredential> {
    try {
      return await puthealthcarePlatformSystemAdminUserCredentialsUserCredentialId(
        {
          systemAdmin,
          userCredentialId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Archive (soft-delete) a user credential record in the
   * healthcarePlatform_user_credentials table.
   *
   * Delete (archive) a user credential record, marking it as retired in the
   * healthcare_platform_user_credentials table of healthcarePlatform. This
   * action sets the deleted_at timestamp and ensures audit records remain
   * intact for regulatory purposes. No actual data is erased—credentials are
   * preserved for compliance and audit.
   *
   * This operation must be invoked only by system administrators, and it is
   * audit-logged. Attempts to delete the currently active (in-use) credential
   * or to hard-delete a credential record should be rejected. The endpoint
   * should confirm archival only for existing, allowed credentials and return
   * appropriate errors if business or compliance constraints are violated.
   * Related APIs may include credential list, update, and credential retrieval
   * for auditing and review workflows.
   *
   * @param connection
   * @param userCredentialId Unique identifier for the user credential record to
   *   archive (UUID in healthcare_platform_user_credentials)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":userCredentialId")
  public async erase(
    @SystemadminAuth()
    systemAdmin: SystemadminPayload,
    @TypedParam("userCredentialId")
    userCredentialId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletehealthcarePlatformSystemAdminUserCredentialsUserCredentialId(
        {
          systemAdmin,
          userCredentialId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
