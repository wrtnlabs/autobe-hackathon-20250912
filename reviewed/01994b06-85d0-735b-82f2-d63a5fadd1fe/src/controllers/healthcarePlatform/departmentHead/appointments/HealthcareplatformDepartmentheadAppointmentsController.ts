import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { posthealthcarePlatformDepartmentHeadAppointments } from "../../../../providers/posthealthcarePlatformDepartmentHeadAppointments";
import { DepartmentheadAuth } from "../../../../decorators/DepartmentheadAuth";
import { DepartmentheadPayload } from "../../../../decorators/payload/DepartmentheadPayload";
import { patchhealthcarePlatformDepartmentHeadAppointments } from "../../../../providers/patchhealthcarePlatformDepartmentHeadAppointments";
import { gethealthcarePlatformDepartmentHeadAppointmentsAppointmentId } from "../../../../providers/gethealthcarePlatformDepartmentHeadAppointmentsAppointmentId";
import { puthealthcarePlatformDepartmentHeadAppointmentsAppointmentId } from "../../../../providers/puthealthcarePlatformDepartmentHeadAppointmentsAppointmentId";
import { deletehealthcarePlatformDepartmentHeadAppointmentsAppointmentId } from "../../../../providers/deletehealthcarePlatformDepartmentHeadAppointmentsAppointmentId";

import { IHealthcarePlatformAppointment } from "../../../../api/structures/IHealthcarePlatformAppointment";
import { IPageIHealthcarePlatformAppointment } from "../../../../api/structures/IPageIHealthcarePlatformAppointment";

@Controller("/healthcarePlatform/departmentHead/appointments")
export class HealthcareplatformDepartmentheadAppointmentsController {
  /**
   * Create a new appointment in healthcare_platform_appointments table.
   *
   * Creates a new appointment event within the healthcare platform, linking the
   * provided organization, provider, patient, status, type, and time fields.
   * This operation checks for resource and schedule availability, enforces
   * access control based on the user's role, and integrates with the
   * multi-tenant structure for isolation. Validation rules require that booking
   * does not conflict with existing appointments for both provider and patient,
   * and that the status code, organization, and provider are valid.
   *
   * On success, the operation returns a complete appointment record as defined
   * in the Prisma schema, including references to related entities. Potential
   * errors include invalid entity references, scheduling conflicts,
   * insufficient permissions, or missing required fields. The created
   * appointment is immediately available for further management (e.g.,
   * updating, reminder scheduling) by authorized roles (receptionists, admins,
   * providers).
   *
   * These APIs are integrated with business logic to ensure compliance,
   * auditability, and operational safety in healthcare scheduling.
   *
   * @param connection
   * @param body Details required to create a new appointment, including
   *   organization, provider, patient, status, type, time, and optional
   *   metadata.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @DepartmentheadAuth()
    departmentHead: DepartmentheadPayload,
    @TypedBody()
    body: IHealthcarePlatformAppointment.ICreate,
  ): Promise<IHealthcarePlatformAppointment> {
    try {
      return await posthealthcarePlatformDepartmentHeadAppointments({
        departmentHead,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and paginate appointments across providers, patients, and
   * departments (healthcare_platform_appointments).
   *
   * Search, paginate, and filter scheduled appointments in the system. The
   * healthcare_platform_appointments schema enables robust querying by
   * provider, patient, organization, department, date range, appointment type,
   * resource, and more. Filtering logic enforces role-based data access
   * boundaries—doctors, nurses can see appointments relevant to their patients
   * or department, receptionists can view organizational schedules, and
   * patients can query their own slots only.
   *
   * The request body allows for compound filters, sorting (by start_time,
   * status, provider, etc.), and pagination (page number, page size, result
   * window). Business logic ensures that only users with proper assignment and
   * role may query appointments. Attempting to view or search schedules outside
   * one's organizational or patient scope is denied with a clear error. Privacy
   * and data minimization constraints are observed throughout.
   *
   * Audit logging records filter usage and all access events for compliance.
   * The response includes paginated appointment summaries (without PHI)
   * suitable for calendar views or dashboard widgets. Full appointment details
   * require additional API calls where permitted. This operation is suitable
   * for integration with both staff-oriented and patient self-service
   * scheduling interfaces.
   *
   * @param connection
   * @param body Search, filtering, and pagination parameters for appointments.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @DepartmentheadAuth()
    departmentHead: DepartmentheadPayload,
    @TypedBody()
    body: IHealthcarePlatformAppointment.IRequest,
  ): Promise<IPageIHealthcarePlatformAppointment.ISummary> {
    try {
      return await patchhealthcarePlatformDepartmentHeadAppointments({
        departmentHead,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Fetch detailed information for a specific appointment by ID
   * (healthcare_platform_appointments).
   *
   * Retrieve full detail for a single appointment event. The
   * healthcare_platform_appointments table captures all scheduling
   * details—organization, department, provider, patient, room/equipment,
   * status, time window, and description. User access is strictly controlled:
   * only assigned provider, patient, or authorized staff roles may fetch
   * appointment data.
   *
   * The path parameter appointmentId uniquely identifies the appointment to
   * retrieve. The system enforces RBAC/organizational boundaries, ensuring
   * patients only see their own appointment details, providers see theirs, and
   * admins/receptionists have wider access. Business logic may redact or
   * minimize PHI in patient-facing responses.
   *
   * Audit logs are created for each access to appointment details in accordance
   * with regulatory requirements. Related operations include PATCH
   * /appointments for searching, and PUT/DELETE for update/deletion. This
   * operation returns the appointment record in detail if authorized, or an
   * error if not permitted.
   *
   * @param connection
   * @param appointmentId Unique identifier of the appointment event.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":appointmentId")
  public async at(
    @DepartmentheadAuth()
    departmentHead: DepartmentheadPayload,
    @TypedParam("appointmentId")
    appointmentId: string & tags.Format<"uuid">,
  ): Promise<IHealthcarePlatformAppointment> {
    try {
      return await gethealthcarePlatformDepartmentHeadAppointmentsAppointmentId(
        {
          departmentHead,
          appointmentId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing appointment by ID in healthcare_platform_appointments
   * table.
   *
   * Modifies the details of an existing appointment in the healthcare platform,
   * allowing changes such as time, status, provider, or supporting fields. The
   * operation enforces business rules including: no time slot overlap, ensuring
   * status transitions are allowed for the given state, and confirming the user
   * is permitted to update the appointment (ownership or role-based
   * restriction).
   *
   * If the update involves changing critical properties like provider or time,
   * the system checks for conflicts and may trigger downstream updates (e.g.,
   * room/equipment reallocation, reminders, or telemedicine session updates).
   * Audit logs are generated for clinical, billing, and operational compliance.
   * Error handling includes conflict, not found, or permission errors.
   *
   * All changes are immediately reflected in the appointment record, and the
   * updated appointment is returned on success.
   *
   * @param connection
   * @param appointmentId Unique identifier of the appointment to update
   * @param body Fields and values to update for the appointment. Can include
   *   time, status, provider, description, room, equipment, etc.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":appointmentId")
  public async update(
    @DepartmentheadAuth()
    departmentHead: DepartmentheadPayload,
    @TypedParam("appointmentId")
    appointmentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IHealthcarePlatformAppointment.IUpdate,
  ): Promise<IHealthcarePlatformAppointment> {
    try {
      return await puthealthcarePlatformDepartmentHeadAppointmentsAppointmentId(
        {
          departmentHead,
          appointmentId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete (soft) an appointment by ID in healthcare_platform_appointments
   * table.
   *
   * Deletes (soft delete via deleted_at field) an appointment by unique
   * identifier. The method enforces access control so only authorized roles
   * within the appointment's organization/department may mark it deleted.
   * Business logic checks include: existence, reference integrity, and
   * protection for appointments involved in billing or legal workflows.
   *
   * Upon success, the appointment is removed from active schedules and
   * workflows but is retained for audit and compliance. Attempts to erase an
   * appointment outside the user’s permitted scope or on protected records
   * (e.g., closed billing, locked by compliance) return appropriate errors. All
   * delete actions are logged in the audit subsystem.
   *
   * @param connection
   * @param appointmentId Unique identifier of the appointment to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":appointmentId")
  public async erase(
    @DepartmentheadAuth()
    departmentHead: DepartmentheadPayload,
    @TypedParam("appointmentId")
    appointmentId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletehealthcarePlatformDepartmentHeadAppointmentsAppointmentId(
        {
          departmentHead,
          appointmentId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
