import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { posthealthcarePlatformReceptionistAppointmentsAppointmentIdReminders } from "../../../../../providers/posthealthcarePlatformReceptionistAppointmentsAppointmentIdReminders";
import { ReceptionistAuth } from "../../../../../decorators/ReceptionistAuth";
import { ReceptionistPayload } from "../../../../../decorators/payload/ReceptionistPayload";
import { patchhealthcarePlatformReceptionistAppointmentsAppointmentIdReminders } from "../../../../../providers/patchhealthcarePlatformReceptionistAppointmentsAppointmentIdReminders";
import { gethealthcarePlatformReceptionistAppointmentsAppointmentIdRemindersReminderId } from "../../../../../providers/gethealthcarePlatformReceptionistAppointmentsAppointmentIdRemindersReminderId";
import { puthealthcarePlatformReceptionistAppointmentsAppointmentIdRemindersReminderId } from "../../../../../providers/puthealthcarePlatformReceptionistAppointmentsAppointmentIdRemindersReminderId";
import { deletehealthcarePlatformReceptionistAppointmentsAppointmentIdRemindersReminderId } from "../../../../../providers/deletehealthcarePlatformReceptionistAppointmentsAppointmentIdRemindersReminderId";

import { IHealthcarePlatformAppointmentReminder } from "../../../../../api/structures/IHealthcarePlatformAppointmentReminder";
import { IPageIHealthcarePlatformAppointmentReminder } from "../../../../../api/structures/IPageIHealthcarePlatformAppointmentReminder";

@Controller(
  "/healthcarePlatform/receptionist/appointments/:appointmentId/reminders",
)
export class HealthcareplatformReceptionistAppointmentsRemindersController {
  /**
   * Schedule a new reminder for an appointment
   * (healthcare_platform_appointment_reminders).
   *
   * Register a new reminder to be sent prior to the specified appointment,
   * including details such as reminder time, recipient role/type, delivery
   * channel (e.g., SMS, email), and message content/subject.
   *
   * Business logic validates that the appointment exists and is not cancelled,
   * that the requested recipient and channel are allowed for this organization,
   * and that the scheduled time for the reminder is within acceptable business
   * windows (no reminders in the past, respects minimum scheduling lead time,
   * etc).
   *
   * Security: Only users with sufficient credentials (e.g., staff assigned to
   * the appointment or scheduling admin roles) may create reminders; the system
   * checks permissions, role bindings, and appointment status before allowing
   * creation. All creation attempts—success or failure—are logged for
   * compliance and audit tracking.
   *
   * Related APIs: This creation operation is part of the larger appointment
   * management workflow and should be used in conjunction with the GET and PUT
   * endpoints for reminders. The parent appointment serves as the workflow
   * boundary, and reminder records are not managed outside of their
   * appointment’s lifecycle.
   *
   * @param connection
   * @param appointmentId Unique identifier for the appointment associated with
   *   this reminder.
   * @param body Information required to create a new appointment reminder,
   *   including target delivery time, recipient, channel, and content.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @ReceptionistAuth()
    receptionist: ReceptionistPayload,
    @TypedParam("appointmentId")
    appointmentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IHealthcarePlatformAppointmentReminder.ICreate,
  ): Promise<IHealthcarePlatformAppointmentReminder> {
    try {
      return await posthealthcarePlatformReceptionistAppointmentsAppointmentIdReminders(
        {
          receptionist,
          appointmentId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * List reminder notifications for an appointment (paginated/filterable).
   *
   * Retrieves all reminders (notification events) associated with a specific
   * appointment ID. Returned results may be filtered/paginated and include all
   * sent/pending/failed reminders, complete with recipient information,
   * delivery status, and notification metadata. Used for staff to monitor and
   * troubleshoot notification workflows, verify SLA compliance, or support
   * patient/provider inquiries.
   *
   * Business logic ensures that only users with access rights to the
   * appointment (receptionist, provider, organization admin, etc.) can access
   * the reminder history. The returned records provide audit support and can be
   * leveraged for notification monitoring, patient service, or regulatory
   * review. Errors include access denied, invalid appointment, or no reminders
   * found.
   *
   * @param connection
   * @param appointmentId Unique identifier of the target appointment whose
   *   reminders to list
   * @param body Search, filter, and pagination criteria for reminder retrieval
   *   (status, delivery channel, recipient, time window, paging).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @ReceptionistAuth()
    receptionist: ReceptionistPayload,
    @TypedParam("appointmentId")
    appointmentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IHealthcarePlatformAppointmentReminder.IRequest,
  ): Promise<IPageIHealthcarePlatformAppointmentReminder> {
    try {
      return await patchhealthcarePlatformReceptionistAppointmentsAppointmentIdReminders(
        {
          receptionist,
          appointmentId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a specific appointment reminder by ID for review or audit
   * (healthcare_platform_appointment_reminders).
   *
   * Retrieve notification reminder information for a specific appointment
   * reminder identified by appointmentId and reminderId. This enables
   * organizational staff or the recipient (e.g. patient) to query the status
   * and content of reminders sent prior to an appointment—including delivery
   * time, channel, status (sent, failed, pending), and recipient details.
   *
   * Security is enforced to ensure only users associated with the organization,
   * appointment, or as the recipient can access the reminder details. Sensitive
   * fields like delivery channel, user, or content may be masked for
   * unauthorized access attempts or if restricted by organizational policy.
   *
   * Reminder entities in this table are subsidiary and not manipulated directly
   * outside of the parent appointment lifecycle, fitting strictly within
   * business and audit flows. All reads are logged for compliance tracking and
   * SLA monitoring.
   *
   * Error handling: If the reminderId or appointmentId are invalid, or if the
   * user lacks permission, the system will respond with an appropriate error
   * message and log the access attempt for audit. Soft-deleted reminders are
   * not visible in standard queries.
   *
   * @param connection
   * @param appointmentId Unique identifier for the appointment to which this
   *   reminder belongs.
   * @param reminderId Unique identifier of the reminder to retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":reminderId")
  public async at(
    @ReceptionistAuth()
    receptionist: ReceptionistPayload,
    @TypedParam("appointmentId")
    appointmentId: string & tags.Format<"uuid">,
    @TypedParam("reminderId")
    reminderId: string & tags.Format<"uuid">,
  ): Promise<IHealthcarePlatformAppointmentReminder> {
    try {
      return await gethealthcarePlatformReceptionistAppointmentsAppointmentIdRemindersReminderId(
        {
          receptionist,
          appointmentId,
          reminderId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing appointment reminder
   * (healthcare_platform_appointment_reminders).
   *
   * Modify scheduling or content for an existing reminder attached to an
   * appointment, identified by appointmentId and reminderId. Typical updates
   * include: rescheduling reminder delivery time, updating recipient
   * user/channel, or changing the notification message or escalation policy.
   *
   * Business and compliance logic ensures that only reminders in statuses
   * permitting modification (e.g., not yet delivered or expired) may be
   * updated, and that changes comply with organization calendar and SLA
   * constraints. Attempts to update reminders for appointments that are
   * cancelled, in the past, or soft-deleted will be rejected.
   *
   * Security: Only authorized staff (e.g., appointment scheduler, org admin)
   * can modify reminders. All successful and failed attempts are logged for
   * audit. Soft-deleted or already-delivered reminders cannot be edited.
   *
   * Error handling includes role and status checks (405 or 403 if not editable
   * or unauthorized) and clear validation errors for scheduling windows,
   * recipient, or channel issues.
   *
   * @param connection
   * @param appointmentId Unique identifier for the appointment to which this
   *   reminder belongs.
   * @param reminderId Unique identifier for the reminder to update.
   * @param body The update information for the appointment reminder (e.g., new
   *   time, recipient, or content).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":reminderId")
  public async update(
    @ReceptionistAuth()
    receptionist: ReceptionistPayload,
    @TypedParam("appointmentId")
    appointmentId: string & tags.Format<"uuid">,
    @TypedParam("reminderId")
    reminderId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IHealthcarePlatformAppointmentReminder.IUpdate,
  ): Promise<IHealthcarePlatformAppointmentReminder> {
    try {
      return await puthealthcarePlatformReceptionistAppointmentsAppointmentIdRemindersReminderId(
        {
          receptionist,
          appointmentId,
          reminderId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Soft-delete an appointment reminder
   * (healthcare_platform_appointment_reminders).
   *
   * Remove (soft-delete) an appointment reminder, identified by appointmentId
   * and reminderId. The operation marks the record as deleted by setting the
   * deleted_at field but does not physically erase reminder data, preserving
   * all audit and compliance information in accordance with healthcare
   * regulatory requirements.
   *
   * Security: Only users with explicit assignment (e.g., admin, scheduler) may
   * delete a reminder, and cannot delete reminders already delivered or
   * archived unless performing an escalated, reviewed action. The system logs
   * all delete events (both successful and failed attempts), including user,
   * reason, and timestamp for regulatory review.
   *
   * Related operations: This endpoint is closely tied to appointment management
   * and notification systems; hard deletes are not permitted via this
   * interface. Restore or audit review of deleted notifications requires a
   * separate process, managed by compliance or IT admins.
   *
   * @param connection
   * @param appointmentId Unique identifier for the appointment from which to
   *   delete the reminder.
   * @param reminderId Unique identifier for the reminder to delete.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":reminderId")
  public async erase(
    @ReceptionistAuth()
    receptionist: ReceptionistPayload,
    @TypedParam("appointmentId")
    appointmentId: string & tags.Format<"uuid">,
    @TypedParam("reminderId")
    reminderId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletehealthcarePlatformReceptionistAppointmentsAppointmentIdRemindersReminderId(
        {
          receptionist,
          appointmentId,
          reminderId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
