import jwt from "jsonwebtoken";
import { MyGlobal } from "../MyGlobal";
import typia, { tags } from "typia";
import { Prisma } from "@prisma/client";
import { v4 } from "uuid";
import { toISOStringSafe } from "../util/toISOStringSafe";
import { IHealthcarePlatformClinicalAlert } from "@ORGANIZATION/PROJECT-api/lib/structures/IHealthcarePlatformClinicalAlert";
import { IPageIHealthcarePlatformClinicalAlert } from "@ORGANIZATION/PROJECT-api/lib/structures/IPageIHealthcarePlatformClinicalAlert";
import { SystemadminPayload } from "../decorators/payload/SystemadminPayload";

/**
 * Search and paginate clinical alerts generated by the CDS engine in the
 * healthcare_platform_clinical_alerts table.
 *
 * This operation enables a system administrator to query, filter, and paginate
 * clinical alert (CDS alert) records across all organizations and departments.
 * Supports searching by organization, department, decision support rule,
 * status, type, subject summary, and date/time window. Returns paginated
 * results with strong typing, correct date/uuid formatting for all fields, and
 * immutable functional code structure. Strictly avoids using native Date and
 * does not use 'as' for type assertions.
 *
 * @param props - SystemAdmin: The authenticated system administrator making the
 *   request (SystemadminPayload) body: Filter/sort/pagination payload, see
 *   IHealthcarePlatformClinicalAlert.IRequest for allowed parameters
 * @returns Paginated and filtered page of clinical alerts matching the given
 *   filters and RBAC scope (if any)
 * @throws {Error} If there is a database error or an unsupported sort field is
 *   requested
 */
export async function patchhealthcarePlatformSystemAdminClinicalAlerts(props: {
  systemAdmin: SystemadminPayload;
  body: IHealthcarePlatformClinicalAlert.IRequest;
}): Promise<IPageIHealthcarePlatformClinicalAlert> {
  const { body } = props;

  // Clamp pagination inputs
  const rawPage = body.page !== undefined ? body.page : 1;
  const rawLimit = body.limit !== undefined ? body.limit : 50;
  // Enforce minimum and maximum bounds
  const page = rawPage > 0 ? rawPage : 1;
  const limit = rawLimit > 0 ? (rawLimit > 100 ? 100 : rawLimit) : 50;
  const skip = (page - 1) * limit;

  // Compose immutable where clause, only including filters that are defined/not-null
  const where = {
    deleted_at: null,
    ...(body.organization_id !== undefined && {
      organization_id: body.organization_id,
    }),
    ...(body.department_id !== undefined &&
      body.department_id !== null && {
        department_id: body.department_id,
      }),
    ...(body.decision_support_rule_id !== undefined && {
      decision_support_rule_id: body.decision_support_rule_id,
    }),
    ...(body.alert_type !== undefined && {
      alert_type: body.alert_type,
    }),
    ...(body.status !== undefined && {
      status: body.status,
    }),
    ...(body.subject_summary !== undefined &&
      body.subject_summary !== null &&
      body.subject_summary.length > 0 && {
        subject_summary: { contains: body.subject_summary },
      }),
    ...(body.start_date !== undefined || body.end_date !== undefined
      ? {
          created_at: {
            ...(body.start_date !== undefined &&
              body.start_date !== null && {
                gte: body.start_date,
              }),
            ...(body.end_date !== undefined &&
              body.end_date !== null && {
                lte: body.end_date,
              }),
          },
        }
      : {}),
  };

  // Determine sort field: safe only on allowed keys, else fallback to created_at desc
  const allowedSortKeys = [
    "created_at",
    "status",
    "alert_type",
    "subject_summary",
  ];
  let orderBy: Record<string, "asc" | "desc"> = { created_at: "desc" };
  if (
    typeof body.sort === "string" &&
    body.sort.length > 0 &&
    allowedSortKeys.includes(body.sort.replace(/^[-+]/, ""))
  ) {
    const sortKey = body.sort.replace(/^[-+]/, "");
    const order: "asc" | "desc" = body.sort.startsWith("-") ? "desc" : "asc";
    orderBy = { [sortKey]: order };
  }

  // Batch query to DB, no Date usage
  const [alerts, total] = await Promise.all([
    MyGlobal.prisma.healthcare_platform_clinical_alerts.findMany({
      where,
      orderBy,
      skip: Number(skip),
      take: Number(limit),
    }),
    MyGlobal.prisma.healthcare_platform_clinical_alerts.count({ where }),
  ]);

  // Map to DTO, always converting Date-time fields to string using toISOStringSafe
  const data = alerts.map((row) => ({
    id: row.id,
    decision_support_rule_id: row.decision_support_rule_id,
    triggered_by_user_id:
      row.triggered_by_user_id !== null &&
      row.triggered_by_user_id !== undefined
        ? row.triggered_by_user_id
        : undefined,
    organization_id: row.organization_id,
    department_id:
      row.department_id !== null && row.department_id !== undefined
        ? row.department_id
        : undefined,
    alert_type: row.alert_type,
    subject_summary: row.subject_summary,
    detail:
      row.detail !== null && row.detail !== undefined ? row.detail : undefined,
    status: row.status,
    acknowledged_at:
      row.acknowledged_at !== null && row.acknowledged_at !== undefined
        ? toISOStringSafe(row.acknowledged_at)
        : undefined,
    resolved_at:
      row.resolved_at !== null && row.resolved_at !== undefined
        ? toISOStringSafe(row.resolved_at)
        : undefined,
    created_at: toISOStringSafe(row.created_at),
    updated_at: toISOStringSafe(row.updated_at),
    deleted_at:
      row.deleted_at !== null && row.deleted_at !== undefined
        ? toISOStringSafe(row.deleted_at)
        : undefined,
  }));

  // Map pagination fields to plain numbers for compatibility (see typia)
  return {
    pagination: {
      current: Number(page),
      limit: Number(limit),
      records: Number(total),
      pages: Number(Math.ceil(total / limit)),
    },
    data,
  };
}
