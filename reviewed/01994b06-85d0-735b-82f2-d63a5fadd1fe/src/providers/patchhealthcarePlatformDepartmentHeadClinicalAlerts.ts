import jwt from "jsonwebtoken";
import { MyGlobal } from "../MyGlobal";
import typia, { tags } from "typia";
import { Prisma } from "@prisma/client";
import { v4 } from "uuid";
import { toISOStringSafe } from "../util/toISOStringSafe";
import { IHealthcarePlatformClinicalAlert } from "@ORGANIZATION/PROJECT-api/lib/structures/IHealthcarePlatformClinicalAlert";
import { IPageIHealthcarePlatformClinicalAlert } from "@ORGANIZATION/PROJECT-api/lib/structures/IPageIHealthcarePlatformClinicalAlert";
import { DepartmentheadPayload } from "../decorators/payload/DepartmentheadPayload";

/**
 * Search and paginate clinical alerts generated by the CDS engine.
 *
 * This operation retrieves a paginated list of clinical alert records from the
 * healthcare_platform_clinical_alerts table, filtered by request criteria such
 * as status, organization, department, decision support rule, alert type,
 * subject, and date/time ranges. The returned results include business fields
 * and datetime/timestamps as ISO 8601 strings.
 *
 * The endpoint strictly limits results to the department head's organization,
 * and optionally their department, per strict RBAC. Pagination and ordering are
 * supported, and all fields are mapped to the output DTO contract with no
 * native Date usage, type assertions, or skipped validations.
 *
 * @param props - DepartmentHead: DepartmentheadPayload – the authenticated
 *   department head, enforcing org RBAC body:
 *   IHealthcarePlatformClinicalAlert.IRequest – search and filter criteria for
 *   query
 * @returns IPageIHealthcarePlatformClinicalAlert – the paged results and
 *   pagination metadata
 * @throws {Error} If validation, RBAC, or query logic fails.
 */
export async function patchhealthcarePlatformDepartmentHeadClinicalAlerts(props: {
  departmentHead: DepartmentheadPayload;
  body: IHealthcarePlatformClinicalAlert.IRequest;
}): Promise<IPageIHealthcarePlatformClinicalAlert> {
  const { departmentHead, body } = props;

  // Strategy: Extract pagination, sanitize values, assemble strict Prisma where clause.
  // Always limit alerts to department head's org. Optionally filter by department, status, etc.

  const page = body.page !== undefined && body.page > 0 ? body.page : 1;
  const limit = body.limit !== undefined && body.limit > 0 ? body.limit : 50;
  const skip = (page - 1) * limit;
  // Accept only safe sort fields (no SQL injection risk)
  const allowedSortFields = [
    "created_at",
    "updated_at",
    "status",
    "alert_type",
    "subject_summary",
    "decision_support_rule_id",
    "resolved_at",
    "acknowledged_at",
  ];
  const sortField = allowedSortFields.includes(body.sort ?? "")
    ? (body.sort ?? "created_at")
    : "created_at";
  const orderBy = { [sortField]: "desc" as const };

  // Organization scope is always strictly enforced – never allow cross-org RBAC leak
  const where: Record<string, unknown> = {
    organization_id: departmentHead.id,
    deleted_at: null,
    ...(body.department_id !== undefined &&
      body.department_id !== null && { department_id: body.department_id }),
    ...(body.status !== undefined &&
      body.status !== null && { status: body.status }),
    ...(body.alert_type !== undefined &&
      body.alert_type !== null && { alert_type: body.alert_type }),
    ...(body.decision_support_rule_id !== undefined &&
      body.decision_support_rule_id !== null && {
        decision_support_rule_id: body.decision_support_rule_id,
      }),
    ...(body.subject_summary !== undefined &&
      body.subject_summary !== null && {
        subject_summary: { contains: body.subject_summary },
      }),
    ...((body.start_date !== undefined && body.start_date !== null) ||
    (body.end_date !== undefined && body.end_date !== null)
      ? {
          created_at: {
            ...(body.start_date !== undefined &&
              body.start_date !== null && { gte: body.start_date }),
            ...(body.end_date !== undefined &&
              body.end_date !== null && { lte: body.end_date }),
          },
        }
      : {}),
  };

  const [rows, total] = await Promise.all([
    MyGlobal.prisma.healthcare_platform_clinical_alerts.findMany({
      where,
      orderBy,
      skip,
      take: limit,
    }),
    MyGlobal.prisma.healthcare_platform_clinical_alerts.count({ where }),
  ]);

  const data = rows.map((row) => {
    // All date handling must be as string & tags.Format<'date-time'>; undefined/null as per API
    return {
      id: row.id,
      decision_support_rule_id: row.decision_support_rule_id,
      triggered_by_user_id:
        row.triggered_by_user_id === null
          ? undefined
          : row.triggered_by_user_id,
      organization_id: row.organization_id,
      department_id: row.department_id === null ? undefined : row.department_id,
      alert_type: row.alert_type,
      subject_summary: row.subject_summary,
      detail: row.detail === null ? undefined : row.detail,
      status: row.status,
      acknowledged_at:
        row.acknowledged_at === null
          ? undefined
          : toISOStringSafe(row.acknowledged_at),
      resolved_at:
        row.resolved_at === null ? undefined : toISOStringSafe(row.resolved_at),
      created_at: toISOStringSafe(row.created_at),
      updated_at: toISOStringSafe(row.updated_at),
      deleted_at:
        row.deleted_at === null ? undefined : toISOStringSafe(row.deleted_at),
    };
  });

  return {
    pagination: {
      current: Number(page),
      limit: Number(limit),
      records: total,
      pages: Math.ceil(total / limit),
    },
    data,
  };
}
