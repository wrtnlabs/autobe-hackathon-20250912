import { IConnection } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";

import { ILibraryManagementGuestUser } from "../../../structures/ILibraryManagementGuestUser";

/**
 * Create a guest user identity record in library_management_guestusers to
 * enable temporary guest access.
 *
 * Register a new guest user (unauthenticated) by creating a temporary identity
 * record to support library management guest features like
 * adding/viewing/searching books. This join operation is public and issues
 * temporary authorization tokens. It works against the
 * library_management_guestusers table, which stores guest user IDs and
 * timestamps. No credentials or active login are required for guests.
 *
 * The operation provides foundational temporary access for guests consistent
 * with the guest kind role.
 *
 * This operation does not require any request body parameters.
 *
 * @param props.connection
 * @setHeader token.access Authorization
 *
 * @path /auth/guestUser/join
 * @accessor api.functional.auth.guestUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(connection: IConnection): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Response = ILibraryManagementGuestUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestUser/join",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestUser/join";
  export const random = (): ILibraryManagementGuestUser.IAuthorized =>
    typia.random<ILibraryManagementGuestUser.IAuthorized>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Refresh guest user authorization tokens without login credentials.
 *
 * Refresh authorization tokens for guest users to maintain temporary session
 * continuity without user credentials. Operates in the context of
 * library_management_guestusers.
 *
 * Accepts refresh tokens via authentication headers (not in the body).
 *
 * Returns refreshed token authorization responses.
 *
 * @param props.connection
 * @setHeader token.access Authorization
 *
 * @path /auth/guestUser/refresh
 * @accessor api.functional.auth.guestUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Response = ILibraryManagementGuestUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestUser/refresh",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestUser/refresh";
  export const random = (): ILibraryManagementGuestUser.IAuthorized =>
    typia.random<ILibraryManagementGuestUser.IAuthorized>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}
