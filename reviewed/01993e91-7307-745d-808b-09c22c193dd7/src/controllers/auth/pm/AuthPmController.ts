import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthPmJoin } from "../../../providers/postauthPmJoin";
import { PmAuth } from "../../../decorators/PmAuth";
import { PmPayload } from "../../../decorators/payload/PmPayload";
import { postauthPmLogin } from "../../../providers/postauthPmLogin";
import { postauthPmRefresh } from "../../../providers/postauthPmRefresh";

import { ITaskManagementPm } from "../../../api/structures/ITaskManagementPm";

@Controller("/auth/pm")
export class AuthPmController {
  /**
   * Register new Project Manager user in task_management_pm table.
   *
   * Create a new Project Manager (PM) account with secure credentials and issue
   * initial JWT tokens. The endpoint receives user registration data and
   * securely stores the PM user record.
   *
   * The `task_management_pm` table fields involved include `email` (unique
   * login identifier), `password_hash` (secure password storage), `name`
   * (user's full name), and timestamp fields for auditing account creation.
   *
   * This operation enables new PMs to register for the task management system,
   * establishing their identity and allowing subsequent authentication.
   *
   * Security considerations include validation of email uniqueness and password
   * hashing prior to database insertion.
   *
   * This registration operation has no authorization requirement as it is meant
   * for public access.
   *
   * @param connection
   * @param body Create a new Project Manager (PM) account with necessary
   *   details
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @PmAuth()
    pm: PmPayload,
    @TypedBody()
    body: ITaskManagementPm.ICreate,
  ): Promise<ITaskManagementPm.IAuthorized> {
    try {
      return await postauthPmJoin({
        pm,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Login existing Project Manager user.
   *
   * Authenticate Project Manager (PM) user by verifying credentials and issue
   * JWT tokens.
   *
   * This login operation uses `email` and `password` parameters validated
   * against stored `password_hash` in `task_management_pm`.
   *
   * Successful authentication returns authorization tokens without exposing
   * sensitive user data.
   *
   * Security controls include protection against brute force and session
   * hijacking.
   *
   * Login is a public endpoint to allow PM users to obtain access tokens.
   *
   * @param connection
   * @param body Login credentials for Project Manager user
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @PmAuth()
    pm: PmPayload,
    @TypedBody()
    body: ITaskManagementPm.ILogin,
  ): Promise<ITaskManagementPm.IAuthorized> {
    try {
      return await postauthPmLogin({
        pm,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh tokens for Project Manager.
   *
   * Refresh JWT authorization tokens for authenticated Project Manager user
   * using a valid refresh token.
   *
   * This operation ensures continued authorized access without requiring
   * re-authentication.
   *
   * Security checks include token validation and session consistency.
   *
   * Only accessible by authenticated PM users with valid refresh tokens.
   *
   * @param connection
   * @param body Refresh token request for Project Manager
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @PmAuth()
    pm: PmPayload,
    @TypedBody()
    body: ITaskManagementPm.IRefresh,
  ): Promise<ITaskManagementPm.IAuthorized> {
    try {
      return await postauthPmRefresh({
        pm,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
