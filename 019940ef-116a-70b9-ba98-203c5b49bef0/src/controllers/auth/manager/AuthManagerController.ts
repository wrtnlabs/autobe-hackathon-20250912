import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthManagerJoin } from "../../../providers/postauthManagerJoin";
import { ManagerAuth } from "../../../decorators/ManagerAuth";
import { ManagerPayload } from "../../../decorators/payload/ManagerPayload";
import { postauthManagerLogin } from "../../../providers/postauthManagerLogin";
import { postauthManagerRefresh } from "../../../providers/postauthManagerRefresh";

import { IJobPerformanceEvalManager } from "../../../api/structures/IJobPerformanceEvalManager";

@Controller("/auth/manager")
export class AuthManagerController {
  /**
   * Register manager account, creates job_performance_eval_managers user and
   * returns JWT tokens.
   *
   * Register a new manager account by providing valid email and password
   * credentials. This operation creates a new manager entity in the
   * job_performance_eval_managers table and returns JWT tokens for subsequent
   * authentication.
   *
   * The operation ensures email uniqueness by checking against existing entries
   * in job_performance_eval_managers.email.
   *
   * Password must be securely hashed and stored as password_hash.
   *
   * Returns authorized JWT tokens upon successful registration.
   *
   * This is a public endpoint with no authentication required.
   *
   * Related to login and token refresh operations to maintain authentication
   * lifecycle.
   *
   * @param connection
   * @param body Manager registration request containing email and password
   *   credentials.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @ManagerAuth()
    manager: ManagerPayload,
    @TypedBody()
    body: IJobPerformanceEvalManager.ICreate,
  ): Promise<IJobPerformanceEvalManager.IAuthorized> {
    try {
      return await postauthManagerJoin({
        manager,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate manager and issue JWT tokens.
   *
   * Authenticate manager with email and password and issue JWT tokens upon
   * successful validation.
   *
   * This operation checks credentials against the
   * job_performance_eval_managers.email and password_hash fields.
   *
   * Returns JWT access and refresh tokens required for session authorization.
   *
   * Does not require prior authentication.
   *
   * Related to join and token refresh operations for lifecycle management.
   *
   * @param connection
   * @param body Manager login request with email and password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @ManagerAuth()
    manager: ManagerPayload,
    @TypedBody()
    body: IJobPerformanceEvalManager.ILogin,
  ): Promise<IJobPerformanceEvalManager.IAuthorized> {
    try {
      return await postauthManagerLogin({
        manager,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh JWT tokens for manager role.
   *
   * Refresh JWT tokens for manager with a valid refresh token.
   *
   * Ensures continued authenticated sessions.
   *
   * No prior login required when a valid refresh token is presented.
   *
   * Returns new JWT tokens upon success.
   *
   * Related to join and login lifecycle operations.
   *
   * @param connection
   * @param body Refresh token request with current refresh token.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @ManagerAuth()
    manager: ManagerPayload,
    @TypedBody()
    body: IJobPerformanceEvalManager.IRefresh,
  ): Promise<IJobPerformanceEvalManager.IAuthorized> {
    try {
      return await postauthManagerRefresh({
        manager,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
