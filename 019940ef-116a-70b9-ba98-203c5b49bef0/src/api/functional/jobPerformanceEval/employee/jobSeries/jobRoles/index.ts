import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IJobPerformanceEvalJobRole } from "../../../../../structures/IJobPerformanceEvalJobRole";
import { IPageIJobPerformanceEvalJobRole } from "../../../../../structures/IPageIJobPerformanceEvalJobRole";

/**
 * Create a new job role under a specified job series.
 *
 * This POST operation allows for creation of a new job role linked to a
 * specific job series.
 *
 * The jobSeriesId path parameter ensures the role is correctly associated with
 * the parent job series.
 *
 * The request body captures all required and optional job role details,
 * following the schema's definitions for creation data.
 *
 * The newly created job role entity is returned upon success for immediate
 * client-side use.
 *
 * Authorization is granted to employees and managers with appropriate
 * privileges to add job roles.
 *
 * @param props.connection
 * @param props.jobSeriesId UUID of the parent job series
 * @param props.body New job role creation data
 * @path /jobPerformanceEval/employee/jobSeries/:jobSeriesId/jobRoles
 * @accessor api.functional.jobPerformanceEval.employee.jobSeries.jobRoles.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** UUID of the parent job series */
    jobSeriesId: string & tags.Format<"uuid">;

    /** New job role creation data */
    body: IJobPerformanceEvalJobRole.ICreate;
  };
  export type Body = IJobPerformanceEvalJobRole.ICreate;
  export type Response = IJobPerformanceEvalJobRole;

  export const METADATA = {
    method: "POST",
    path: "/jobPerformanceEval/employee/jobSeries/:jobSeriesId/jobRoles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/jobPerformanceEval/employee/jobSeries/${encodeURIComponent(props.jobSeriesId ?? "null")}/jobRoles`;
  export const random = (): IJobPerformanceEvalJobRole =>
    typia.random<IJobPerformanceEvalJobRole>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("jobSeriesId")(() => typia.assert(props.jobSeriesId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list job roles within a job series with pagination and filtering.
 *
 * This PATCH operation enables clients to search and retrieve a paginated list
 * of job roles under a specified job series.
 *
 * The jobSeriesId path parameter scopes the roles within the specified job
 * series. The request body supports various filtering options such as job role
 * name, growth level, and other attributes.
 *
 * Results are paginated and sortable, providing efficient querying capabilities
 * for large datasets.
 *
 * Authorization is set to allow employees and managers to access this
 * operation.
 *
 * The response contains a paginated collection of job role summaries, useful
 * for display in UI listings or further processing.
 *
 * @param props.connection
 * @param props.jobSeriesId UUID of the job series to list roles for
 * @param props.body Filter and pagination parameters for job role search
 * @path /jobPerformanceEval/employee/jobSeries/:jobSeriesId/jobRoles
 * @accessor api.functional.jobPerformanceEval.employee.jobSeries.jobRoles.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** UUID of the job series to list roles for */
    jobSeriesId: string & tags.Format<"uuid">;

    /** Filter and pagination parameters for job role search */
    body: IJobPerformanceEvalJobRole.IRequest;
  };
  export type Body = IJobPerformanceEvalJobRole.IRequest;
  export type Response = IPageIJobPerformanceEvalJobRole.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/jobPerformanceEval/employee/jobSeries/:jobSeriesId/jobRoles",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/jobPerformanceEval/employee/jobSeries/${encodeURIComponent(props.jobSeriesId ?? "null")}/jobRoles`;
  export const random = (): IPageIJobPerformanceEvalJobRole.ISummary =>
    typia.random<IPageIJobPerformanceEvalJobRole.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("jobSeriesId")(() => typia.assert(props.jobSeriesId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get detailed information of a specific job role by ID under a job series.
 *
 * This GET operation fetches detailed information of a specific job role
 * identified by jobRoleId, scoped within a job series identified by
 * jobSeriesId.
 *
 * The endpoint ensures hierarchical integrity by requiring the parent
 * jobSeriesId.
 *
 * Authorized employees and managers can retrieve fields including code, name,
 * description, growth level, creation and update timestamps.
 *
 * No request body is necessary. The operation returns a full entity
 * representation for use in detailed views or editing.
 *
 * @param props.connection
 * @param props.jobSeriesId UUID of the parent job series
 * @param props.jobRoleId UUID of the target job role
 * @path /jobPerformanceEval/employee/jobSeries/:jobSeriesId/jobRoles/:jobRoleId
 * @accessor api.functional.jobPerformanceEval.employee.jobSeries.jobRoles.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the parent job series */
    jobSeriesId: string & tags.Format<"uuid">;

    /** UUID of the target job role */
    jobRoleId: string & tags.Format<"uuid">;
  };
  export type Response = IJobPerformanceEvalJobRole;

  export const METADATA = {
    method: "GET",
    path: "/jobPerformanceEval/employee/jobSeries/:jobSeriesId/jobRoles/:jobRoleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/jobPerformanceEval/employee/jobSeries/${encodeURIComponent(props.jobSeriesId ?? "null")}/jobRoles/${encodeURIComponent(props.jobRoleId ?? "null")}`;
  export const random = (): IJobPerformanceEvalJobRole =>
    typia.random<IJobPerformanceEvalJobRole>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("jobSeriesId")(() => typia.assert(props.jobSeriesId));
      assert.param("jobRoleId")(() => typia.assert(props.jobRoleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a specific job role in a job series.
 *
 * This endpoint updates details of a specific job role attached to a job
 * series, enabling editing of role code, name, description, and growth level
 * classifications. It operates on the 'job_performance_eval_job_roles' table in
 * the database, which stores the hierarchical job role structures used for
 * employee job assignments and evaluations.
 *
 * Users with appropriate privileges such as 'employee' or 'manager' roles can
 * modify job role details to keep job definitions current and aligned with
 * organizational needs.
 *
 * The operation enforces validation rules for unique codes and proper data
 * types. It uses path parameters 'jobSeriesId' and 'jobRoleId' to target the
 * precise job role resource while preserving referential integrity in the job
 * hierarchy.
 *
 * In case of data conflicts such as duplicate codes, the operation will reject
 * the update with appropriate errors.
 *
 * @param props.connection
 * @param props.jobSeriesId Unique identifier of the target job series
 * @param props.jobRoleId Unique identifier of the target job role
 * @param props.body Update data for job role
 * @path /jobPerformanceEval/employee/jobSeries/:jobSeriesId/jobRoles/:jobRoleId
 * @accessor api.functional.jobPerformanceEval.employee.jobSeries.jobRoles.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target job series */
    jobSeriesId: string & tags.Format<"uuid">;

    /** Unique identifier of the target job role */
    jobRoleId: string & tags.Format<"uuid">;

    /** Update data for job role */
    body: IJobPerformanceEvalJobRole.IUpdate;
  };
  export type Body = IJobPerformanceEvalJobRole.IUpdate;
  export type Response = IJobPerformanceEvalJobRole;

  export const METADATA = {
    method: "PUT",
    path: "/jobPerformanceEval/employee/jobSeries/:jobSeriesId/jobRoles/:jobRoleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/jobPerformanceEval/employee/jobSeries/${encodeURIComponent(props.jobSeriesId ?? "null")}/jobRoles/${encodeURIComponent(props.jobRoleId ?? "null")}`;
  export const random = (): IJobPerformanceEvalJobRole =>
    typia.random<IJobPerformanceEvalJobRole>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("jobSeriesId")(() => typia.assert(props.jobSeriesId));
      assert.param("jobRoleId")(() => typia.assert(props.jobRoleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a job role from a job series.
 *
 * Deletes a job role permanently from the given job series by its identifier.
 * This operation affects the 'job_performance_eval_job_roles' table, removing
 * the job role record entirely from the database.
 *
 * While the 'job_performance_eval_job_roles' table supports a 'deleted_at'
 * field for soft deletion, this operation performs hard delete, permanently
 * removing data without recovery.
 *
 * Users with 'employee' or 'manager' roles are authorized to carry out this
 * operation.
 *
 * There is no request body or returned response content for this deletion.
 * Appropriate errors will be returned if the identifiers do not exist.
 *
 * @param props.connection
 * @param props.jobSeriesId Unique identifier of the target job series
 * @param props.jobRoleId Unique identifier of the target job role
 * @path /jobPerformanceEval/employee/jobSeries/:jobSeriesId/jobRoles/:jobRoleId
 * @accessor api.functional.jobPerformanceEval.employee.jobSeries.jobRoles.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target job series */
    jobSeriesId: string & tags.Format<"uuid">;

    /** Unique identifier of the target job role */
    jobRoleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/jobPerformanceEval/employee/jobSeries/:jobSeriesId/jobRoles/:jobRoleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/jobPerformanceEval/employee/jobSeries/${encodeURIComponent(props.jobSeriesId ?? "null")}/jobRoles/${encodeURIComponent(props.jobRoleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("jobSeriesId")(() => typia.assert(props.jobSeriesId));
      assert.param("jobRoleId")(() => typia.assert(props.jobRoleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
